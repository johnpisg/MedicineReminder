# Jibestream`s Android SDK
## Quick Overview

## Introduction
The Jibestream Android SDK's is very flexible and powerful 2D map engine, allowing the developer to implement rapidly maps with custom behaviour.

### SDK Rendering - Canvas
The internal architecture is based on the [Scene Graph ](https://en.wikipedia.org/wiki/Scene_graph) data structure and rendering is engineered utilizing the Canvas technology, in order to achieve the best performance and usability on the constrained hardware environment that the platform runs onto.
The Android [Canvas API](http://developer.android.com/reference/android/graphics/Canvas.html) provides easy to use primitives that the developer implementing the SDK must be comfortable with, thus a prerequisite for efficiently utilizing the SDK the developer must have some understanding of the Canvas.

### SDK base class Element
The base for every view rendered is the Element class. It provides the rudimentary logic that all elements share. Two more classes inherit from the Element class ElementMap and ElementIcon that contain the applicable logic for styling them as their internal drawing structure differ. 
Element class and subclasses are composed with the following common properties.

#### Spatial Positioning
The Transform class an abstraction for spatial transformations. Helper method have been implemented for relative and absolute values.
The developer can achieve complicated transformations with parent - child relationships and offsets.

 ```Java
      final Element el = m.getElementList().get(0);
      Transform transform = el.getTransform();
      transform.addScale(float);
      transform.setRotation(float);
      transform.addTranslationX(float);
      transform.addScaleOffset(float);
      transform.addChild(aOtherTransform);
```

##### Spatial Constraints
Two spatial constraints are available for convenience "Constant Scale" and "Heads Up". 
###### "Constant Scale" - Element size not changing
The setConstantScale() function has an effect of maintaining the same size by ignoring any inherited transformations and camera zoom changes. 
```Java
  element.setConstantScale(boolean);
```
###### "Heads Up" - Element rotation not changing
The setHeadsUp() function has an effect of maintaining the same orientation by ignoring any camera roll changes. 
```Java
  element.setHeadsUp(boolean);
```
###### "Heads Up Flip" - two rotation values reflecting each other.
 setHeadsUpFlip() function will augment the headsUp function by returning two possible values with 180 degrees difference, very useful for text labels. 
   ```Java
     element.setHeadsUpFlip(boolean);
   ```

#### Visual Representation
IShape interface for setting the elements visual representation. 
There is a convenient base Shape class that implements the interfaces methods that the developer can inherit from and utilize. Additionally there are several subclasses with predefined primitive shapes documented further in this document. 
link to "SDK Primitive Shapes:

 ```Java
  final Element el = m.getElementList().get(0);
  Circle circle = new Circle();
  circle.setRadius(5f);
  el.setShape(circle);
 ```

#### Venue level
The level / map an Element will be rendered on. The index is defined by the VenueData class the data model structure found on the M instance 
```Java
  MapFull[] maps = m.venueData.maps;
  element.setLevel(0);
  int indexOfMaoEntry = element.getLevel();
```

#### Behaviour States
"Activeness" the main flag that determines if an element is eligible to participates in all the SDK's cycles.
Select, Update, Collision, Render. 
 ```Java
 element.setActive(boolean);
 boolean isActive = element.isActive(boolean);
 ```
"Selectable" determines if the SDK will consider the element and dispatch an event based on the users touch gestures.
 ```Java
 element.setSelectable(boolean);
 boolean isSelectable = element.isSelectable(boolean);
 ```

"Visibility" controls the visibility of the element, excludes itself from being rendered.
 ```Java
 element.setVisible(boolean);
 boolean isVisible = element.isVisible(boolean);
 ```
 
"Collidable" if the element will be considered in the collision detection cycle.
 ```Java
 element.setCollidable(boolean);
 boolean isCollidable = element.isCollidable(boolean);
 ```
 
"InViewSpace" Sets the reference point of the transformation to the camera's viewport, element will be in screen space not in "map" space. 
This is handy to position GUI elements that need to constrain themselves to the view's edges.
 ```Java
 element.setInViewSpace(boolean);
 ```

#### Stylistic States
As well for ease the most common styleable states besides the "idle" state have been implemented, specifically a "Selectable" and "Highlightable" state is in place. Even the naming convention used for these extra states connotate to a particular use, the developer can utilize these an associate them with any requirement they may have. 
 ```Java
      el.setHighlightState(boolean);
      el.setSelectState(boolean);
 ```
link to styling

### SDK inter communication - Eventbus
  The chosen method for communication among the different components is the android's internal dispatch mechanism [LocalBroadcastManager](http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html).
  The developer can obtain a reference to the instance with the following code:
  ```Java
  LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
  ```

## SDK Setup Overview
To successfully display a map the following outlines the steps involved.  
  1. Obtain the data for a map.
  2. Instantiate a map.
  3. Create an instance of the map`s viewport and connect it to map instance.


### Getting venue's data
In order to populate a map we must first get its data from the backend, we can achieve this by invoking the static method VenueDataService.getData() and by listening on the platform's LocalBroadcastManager event bus for the VenueDataService.DONE message.
On a successfully response the SDK will store the data and provide the filename within the bundle of the Intent.
Example snippet provided bellow.

```Java
  BasicAuthentication basicAuthentication = new BasicAuthentication("userValue","passcodeValue","apiValue","languageCodeValue");
  LocalBroadcastManager.getInstance(this).registerReceiver(broadcastReceiver, new IntentFilter(VenueDataService.DONE));
  LocalBroadcastManager.getInstance(this).registerReceiver(broadcastReceiver, new IntentFilter(VenueDataService.ERROR));
  VenueDataService.getData(context, url, projectId, basicAuthentication);

  private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
      LocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
      String action = intent.getAction();
      switch (action) {
        case VenueDataService.DONE:
          // Get the filename with the data
          String filename = intent.getStringExtra(VenueDataService.KEY_FILENAME);
          M m = binder.getM();
          LocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiverFrameworkInit, new IntentFilterEngine(m, IntentFilterEngine.COMPLETE));
          m.start(filename, R.raw.config);
          //
          break;
        case VenueDataService.ERROR:
          // handle error
          break;
      }
    }
  };
```

The 3 VenueDataService.getData() parameters are:
- *String*: The server endpoint where you will get all your data from.
- *int*: The location/project ID of the map/building to display.
- *BasicAuthentication*: BasicAuthentication instance if applicable, can be null if there is no authentication in place.

## Map Model - M class
The model for the venue map is encapsulated with the M class. It holds all convenient states, map information and the view representations of the parsed information.

### SDK VenueData - Data Model
The data model returned from the UXM is hosted in the venueData field and its described in this document. link
```Java
  VenueData venueData = m.venueData;
'''

### Instantiating a map
Keeping a reference within your application is mandatory and depending on your needs you might want to create a service or a static variable for easy referencing and persistenting the state outside an activity's lifecycle.

```Java
  m = new M(context);
```

#### Setting up the M
The M class has the following lifecycle:

1. **Start**
2. **Complete**
3. **Resume**
4. **Pause**
5. **Stop**
6. **Destroy**

##### M`s Start state
Dispatching: IntentFilterEngine.START
Dispatched when the user calls the following function.

```Java
 m.start(String fileName, int config);
```

 Which bootstraps the map, parsing and populating according to the venues data set found in the provided filename contents.
 If there is a config resource present that any relevant settings to the platform will be taken in consideration.
 Relative settings are limited to the visibility and the idle visual representational state of the view types.

```Java
    LocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiverFrameworkInit, new IntentFilterEngine(m, IntentFilterEngine.COMPLETE));
    m.start(filename, R.raw.config);
```

##### M`s Complete state
Dispatching: IntentFilterEngine.COMPLETE
Dictates the completeness of the parsing, population phases found according to the VenueData returned filename contents.
Addition of custom elements and custom styles overrides should happen here.

```Java
    LocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiverFrameworkComplete, new IntentFilterEngine(m, IntentFilterEngine.COMPLETE));
    m.start(filename, R.raw.config);

    private BroadcastReceiver broadcastReceiverFrameworkComplete = new BroadcastReceiver() {
      @Override
      public void onReceive(Context context, Intent intent) {
        LocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiverFrameworkInit);

          // Custom idle styles for mover representations
          RenderStyle stairsStyle = new RenderStyle(Paint.Style.FILL);
          stairsStyle.paintFill.setColor(ColorsMaterialDesign.RED9);
          m.cssStyles.setStairs(stairsStyle, true);

          RenderStyle escalatorsStyle = new RenderStyle(Paint.Style.FILL);
          escalatorsStyle.paintFill.setColor(ColorsMaterialDesign.RED7);
          m.cssStyles.setEscalators(escalatorsStyle, true);

          RenderStyle elevatorsStyle = new RenderStyle(Paint.Style.FILL);
          elevatorsStyle.paintFill.setColor(ColorsMaterialDesign.RED5);
          m.cssStyles.setElevators(elevatorsStyle, true);

          // Custom elements addition to the map
          ElementMap custom = new CustomElement();
          m.addToMap(new MiniMap());
      }
    };
```

##### M`s Resume state
Dispatching: IntentFilterEngine.RESUME
resumes M instance, causes updates to happen in respond to the device's display events.

##### M's Pause state
Dispatching: IntentFilterEngine.PAUSE
pauses M instance, causes to stop listening to the device's display events.

##### M's Stop state
Dispatching: IntentFilterEngine.STOP
reset M for new venue data

##### M's Destroy state
Dispatching: IntentFilterEngine.DESTROY
destroys M

## Venue Data
All the information stored on the UXM is neatly stored locally in data objects that the implementor can traverse and inspect to obtain the necessary information he/she requires.
The parent object that host all the values is the VenueData class that can be accessed on the instance of the M class.
```Java
  final VenueData venueData = m.venueData;        
```

### Available Types
The android SDK has the following types that can be extended and customized. 
These types are defined on each venue's levels representation (SVG) or the UXM and any desired behaviour can be achieved, by extending them and defining the looks and the behaviour the project needs.

* Amenity
* Unit
* UnitLabel
* Obstacle
* Escalator
* Elevators
* Stair
* ParkingLot
* StreetMajor
* StreetMinor
* StreetSmallAlley
* MallBoundary
* Restroom
* Corridor
* Background
* YouAreHere
* Route
* Pin
* MoverHead
* MoverTail
* WayfindKiosk
* Kiosk

All of the generated instances will be available on the display list.
 
#### Amenities
Amenities types are defined and populated on the UXM, the Android SDK would receive the list for the specific venue and instantiated them using the base Amenity class type or the provided custom implementation. 
The data types are found on the M instance under the venueData.amenities field. 
```Java
  final com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[] amenities = m.venueData.amenities;
```

#### Unit, Obstacle, Escalator, Elevators, Stair, ParkingLot, StreetMajor, StreetMinor, StreetSmallAlley, MallBoundary, Restroom, Corridor, Kiosk, Background
 On the source SVG representation for each level of a venue, elements are decorated with a specific set of class names that the Android SDK will parse and instantiate with their relative type. These elements will be initially styled with the found css values and the styles are stored on the m instance field cssStyles. The CssStyles class is a HashMap with key the css class name and for the value a RenderStyle object.
 Helper methods to retrieve or set these styles are also available.
 ```Java
  final CssStyles cssStyles = m.cssStyles;
  cssStyles.setElevators(RenderStyle, boolean);
```

##### Units and UnitLabels
Units and UnitLabels implement the IPreProcessedElem interface that provides the Destinations, Waypoints and IDs these elements are associated with. 
 ```Java
  Unit unit;
  final int[] waypointIDs = unit.getWaypointIDs();
  final int[] destinationIDs = unit.getDestinationIDs();
```

##### UnitLabels
Unitlabel is an element with a text representation in order to label the underlying Unit. The designers define the region for each Unit with a rectangle known as the "LBox", the Android SDK migrates this structure to a UnitLabel type. The LBox x/y values will be found in the Unitlabel transform field and the LBox width/height will be found in the Unitlabel width/height getters.
 ```Java
  UnitLabel unitLabel;
  final float width = unitLabel.getWidth();
  final float height = unitLabel.getHeight();
  final float translationX = unitLabel.getTransform().getTranslationX();
  final float translationY = unitLabel.getTransform().getTranslationY();
```

#### WayfindKiosk
This type is instantiated from the devices data and represented with a star shape.
 ```Java
```
 
#### YouAreHere, Route, Pin, MoverHead, MoverTail.
These element appear only when wayfinding has been activated by setting the fromWaypoint and toWaypoint.

#### Custom Types Assignment.
After instantiation the developer can assign the logic for custom behavior by extending the relevant base class and setting the class field M.classLib to point to the custom classes.

```Java
  m = new M(context);
  m.classLib.unitLabelClass = UnitLabelsSameSize.class;
  m.classLib.amenityClass = AmenityCustomScale.class;
```

#### Custom Type implementation
The Android SDK provides powerful ways to create custom behaviours on the predefined and for any custom elements. The possibilities are endless and though the SDK provides allot of functionality out of the box, there will be times that a certain look or behaviour must be achieved.
The developer can achieve this by extending a base class of the desired type and overriding the callback functions found on all map elements. 
One restriction is that constructors must provide empty signatures since instantiation will happen while parsing the maps data.
Bellow are the callbacks available with a brief description.

---
Initialization happens here, runs once on every element the first time the engine starts.
```Java
void onCreate(Context context, M m, long timeElapsed, long timeTotal, Camera camera);
```
when overriding the developer needs to call 
```Java
setIsInitialized(true)
```
so the callback wont be called again in the elements lifecycle.

---

Updates happen here, runs every frame.
```Java
void onUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera);
```

---

Physics updates or an other post updates happen here, called every frame
```Java
void onPostUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera);
```

---

On collision detection enter runs on custom frame rate defined in the model: M
```Java
void onCollision(M m, ArrayList<Element> collidesWith, long timeElapsed, long timeTotal, int fps, Camera camera);
```

---

Post callback runs after onCollision fn runs on custom frame rate defined in the model: M
```Java
void onPostCollision(M m, long timeElapsed, long timeTotal, int fps, Camera camera);
```

---

Users wont need to override unless there is a need to define a custom transformation  
```Java
Matrix onPreRender(M m, long timeElapsed, long timeTotal, int fps, Camera camera);
```

---

Canvas draw calls placed here, the engine will call this function once a frame for every element
```Java
void onRender(Canvas canvas, Paint touchPaint);
```

---

Callback when destroy has been called on M instance.
```Java
void onDestroy(Context context);
```

---

Example of custom unit labels.

```Java
// extend the base class of UnitLabels
public class UnitLabelsSameSize extends com.jibestream.jibestreamandroidlibrary.elements.UnitLabel {
private static final int STEP = 255/20;
private final Paint paint;
private Rect bounds = new Rect();
private float textOffsetY;
private float textWidth;

// make sure the constructor takes no parameters.
public UnitLabelsSameSize() {
  setConstantScale(true);
  paint = new Paint();
  paint.setTextSize(30);
  paint.setTextAlign(Paint.Align.CENTER);
  paint.setColor(ColorsMaterialDesign.GREY9);
  paint.setAntiAlias(true);
  calc();
}

// react to updated text for the label
@Override
public void setText(String s) {
  super.setText(s);
  calc();
}

private void calc() {
  final String text = getText();
  if (text == null) return;
  paint.getTextBounds(text, 0, text.length(), bounds);
  textWidth = bounds.width();
  textOffsetY = bounds.height() * 0.5f;
}

private boolean testDesiredVisibility(float cameraZoom) {
  float calculatedWidth = width * cameraZoom;
  if (calculatedWidth < textWidth) {
    return true;
  } else {
    return false;
  }
}

@Override
public void onCreate(Context context, M m, long timeElapsed, long timeTotal, Camera camera) {
  super.onCreate(context, m, timeElapsed, timeTotal, camera);
  if (testDesiredVisibility(camera.zoom)) {
    setVisible(false);
    paint.setAlpha(0);
  } else {
    setVisible(true);
    paint.setAlpha(255);
  }
}

// Update the label every frame
@Override
public void onUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera) {
  super.onUpdate(m, timeElapsed, timeTotal, fps, camera);
  if (textString == null || textString.isEmpty()) {
    setVisible(false);
  }
  super.onPreRender(m, timeElapsed, timeTotal, fps, camera);
  if (testDesiredVisibility(camera.zoom)) {
    addAlpha(-STEP*3);
  } else {
    addAlpha(STEP);
  }
}

private void addAlpha(int v) {
  v = paint.getAlpha() + v;
  if (v < 0) {
    paint.setAlpha(0);
  } else if (v > 255) {
    paint.setAlpha(255);
  } else {
    paint.setAlpha(v);
  }
  if (paint.getAlpha() > 0) {
    setVisible(true);
  } else {
    setVisible(false);
  }
}

// override the SDK's rendering implementation and define the look of the label
@Override
public void onRender(Canvas canvas, Paint touchPaint) {
  canvas.save();
  canvas.concat(transformation);
  canvas.translate(offsetX, offsetY);
  canvas.translate(0, textOffsetY);
  canvas.drawText(textString, 0, 0, paint);
  canvas.restore();
}
}
```


#### Custom Element implementation
The user can add custom elements to the map by creating a class that extends ElementMap and define the behaviour as demonstrated above.
Example of a custom element

```Java
public class Popup extends ElementMap {

private String titleString = "Title";
private String subTitleString = "SubTitle";
private String bodyString = "Lorem ipsum dolor sit amet, consectetur.";
private final TextStaticLayout titleStaticLayout = new TextStaticLayout();
private final TextStaticLayout subTitleStaticLayout = new TextStaticLayout();
private final TextStaticLayout bodyStaticLayout = new TextStaticLayout();

private int width = 400;
private JPath jPath;
private Path path;
private MultiShape multiShape;

public Popup() {
  this(null, null, null);
}

public Popup(String titleString, String subTitleString, String bodyString) {
  super();
  if (titleString != null) this.titleString = titleString;
  if (subTitleString != null) this.subTitleString = subTitleString;
  if (bodyString != null) this.bodyString = bodyString;

  jPath = new JPath();
  path = new Path();
  jPath.setPath(path);
  multiShape = new MultiShape();
  multiShape.iShapes.add(jPath);
  multiShape.iShapes.add(titleStaticLayout);
  multiShape.iShapes.add(subTitleStaticLayout);
  multiShape.iShapes.add(bodyStaticLayout);
  setShape(multiShape);
  calc();
}

private void calc() {
  titleStaticLayout.setTextString(titleString);
  final int padding = 20;
  titleStaticLayout.setWidth(width - padding * 2);
  titleStaticLayout.setOffsetX(padding);

  subTitleStaticLayout.setTextString(subTitleString);
  subTitleStaticLayout.setWidth(width - padding * 2);
  subTitleStaticLayout.setOffsetX(padding);

  bodyStaticLayout.setTextString(bodyString);
  bodyStaticLayout.setWidth(width - padding * 2);
  bodyStaticLayout.setOffsetX(padding);


  float accumY = padding;
  titleStaticLayout.setOffsetY(accumY);
  accumY += titleStaticLayout.getHeight();
  accumY += 5;
  subTitleStaticLayout.setOffsetY(accumY);
  accumY += subTitleStaticLayout.getHeight();
  accumY += 5;
  bodyStaticLayout.setOffsetY(accumY);
  accumY += bodyStaticLayout.getHeight();
  accumY += padding;

  path.reset();
  path.moveTo(0, 0);
  path.lineTo(width, 0);
  path.lineTo(width, accumY);
  float halfW = width * 0.5f;
  path.lineTo(halfW + 50, accumY);
  path.lineTo(200, accumY + 50);
  path.lineTo(halfW - 50, accumY);
  path.lineTo(0, accumY);
  path.close();

  multiShape.setOffsetX(-halfW);
  multiShape.setOffsetY(-accumY - 50f);
}


public String getTitleString() {
  return titleString;
}

public void setTitleString(String titleString) {
  this.titleString = titleString;
  calc();
}

public String getSubTitleString() {
  return subTitleString;
}

public void setSubTitleString(String subTitleString) {
  this.subTitleString = subTitleString;
  calc();
}

public String getBodyString() {
  return bodyString;
}

public void setBodyString(String bodyString) {
  this.bodyString = bodyString;
  calc();
}

public TextStaticLayout getBodyStaticLayout() {
  return bodyStaticLayout;
}


public TextStaticLayout getTitleStaticLayout() {
  return titleStaticLayout;
}


public TextStaticLayout getSubTitleStaticLayout() {
  return subTitleStaticLayout;
}

public int getWidth() {
  return width;
}

public void setWidth(int width) {
  this.width = width;
  calc();
}
```

After the map is complete the user can add custom elements

```Java
  Popup popUp = new Popup();
  //
  popUp.setSelectable(true);
  popUp.setVisible(false);
  popUp.setHeadsUp(true);
  popUp.setConstantScale(true);
  //
  m.addToMap(popUp);


// Listen to events broadcasted by the framework
    LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
    localBroadcastManager.registerReceiver(broadcastRieverTouchLong, new IntentFilterTouch(m, IntentFilterTouch.TYPE_LONG_PRESS));
    localBroadcastManager.registerReceiver(broadcastReceiverTouchSinglePopUp, new IntentFilterTouch(m, IntentFilterTouch.TYPE_SINGLE));

  broadcastRieverTouchLong = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
      IntentTouch intentTouch = (IntentTouch) intent;
      final Element element = m.getElementWithID(intentTouch.id);
      Unit unit = null;
      if (element instanceof Unit) {
        unit = (Unit) element;
      }
      if (unit != null) {
        popUp.setVisible(false);
        final Destination[] destinations = unit.getDestinations();
        if (destinations != null && destinations.length > 0) {
          final Destination destination = destinations[0];
          if (destination == null) return;
          popUp.setLevel(element.getLevel());
          popUp.setTitleString(destination.name);
          //
          if (destination.category != null && destination.category.length > 3) {
            String asString = destination.category[0] + ", " + destination.category[1] + ", " + destination.category[2];
            int max = Math.min(50, asString.length() - 1);
            String s = asString.substring(0, max) + "...";
            popUp.setSubTitleString(s);
          } else {
            popUp.setSubTitleString("");
          }
          //
          if (destination.description != null && destination.description.length() > 0) {
            int maxBodyString = Math.min(300, destination.description.length() - 1);
            String bodyString = destination.description.substring(0, maxBodyString) + "...";
            popUp.setBodyString(bodyString);
          }
          final Waypoint[] waypointsOfDestination = Building.getWaypointsOfDestination(m, unit.getDestinations()[0]);
          popUp.getTransform().setTranslationX(waypointsOfDestination[0].x);
          popUp.getTransform().setTranslationY(waypointsOfDestination[0].y);
//          unit.addChild(popUp);
          popUp.setVisible(true);
        }
      }
    }
  };


  broadcastReceiverTouchSinglePopUp = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
      IntentTouch intentTouch = (IntentTouch) intent;
      if (intentTouch.id == popUp.id) {
        popUp.setVisible(false);
      }
    }
  };

```
### SDK Primitive Shapes
Most of the Canvas drawing calls have been wrapped within a Shape class that provides persistent state.

#### List of primitives
* Circle 
* Line
* Oval
* Polygon
* Rectangle
* Square
* Star
* Text
* TextFit
* TextStaticLayout
* JPath
* TwoDent
* MultiShape
 
#### Extending base class Shape - onDraw()
The developer creates a custom shape by extending the convenient base Shape class and overriding the onDraw() with the draw calls that describe the visual look.
  
```Java
 @Override
 public void onDraw(Canvas canvas, Paint paint) {
   canvas.drawPath(trigPath, paint);
   canvas.drawRoundRect(bounds, 5f, 5f, paint);
   canvas.save();
   canvas.translate(0, textOffsetY);
   staticLayout.draw(canvas);
   canvas.restore();
 }
```

##### Shape's Bounding Box - getBBox()
The abstract nature of defining what to be drawn creates a coupling need for a region that encompass the drawn area. This region must be defined if the element that will host the custom shape will be involved in the Collision detection cycle, or the bounds will be used to frame the camera to it and finally there are no multiple visual states.  
If there is no need for any of the mentioned functionality the developer can override the OnRender() callback straight on the Element class and place the drawing call there.
  
```Java
@Override
public RectF getBBox() {
  return aRect;
}
```
 
### The RenderStyle class
This class defines the look of a Shape link, it adapts the cascading styles sheet (CSS) approach by providing the ability to have a fill and/or a stroke.
```Java  
  RenderStyle unitStyle = new RenderStyle(Paint.Style.FILL_AND_STROKE);
  unitStyle.paintFill.setColor(ColorsMaterialDesign.GREY7);
  unitStyle.paintStroke.setColor(ColorsMaterialDesign.GREY9);
  unitStyle.paintStroke.setStrokeWidth(0.25f);
  unitStyle.paintStroke.setAntiAlias(true);
```

### The ElementMap class
The ElementMap class is the base class of all the predefined types except the Amenity type, as there are stylistic structural differences.
```Java
  elementMap.setStyleIdle(RenderStyle style);
  elementMap.setStyleSelected(RenderStyle style);
  elementMap.setStyleHighlighted(RenderStyle style);
 ```
 
### Ground conventions
In order to support multiple states for SVG elements the designers can group elements with the following conventions. 
* Background
* Middle ground
* Foreground

The Android SDK provides the base ElementIcon and RenderStyleIcon class for these types. 

### The RenderStyleIcon class
This class provides the ability to style the collection of Shapes defined with "Ground Conventions"
```Java
  RenderStyleIcon renderStyleIconIdle = new RenderStyleIcon();
  //
  renderStyleIconIdle.renderStyleBG.paintFill.setColor(ColorsMaterialDesign.GREY3);
  renderStyleIconIdle.renderStyleBG.paintFill.setAntiAlias(true);
  //
  renderStyleIconIdle.renderStyleMG = new RenderStyle(Paint.Style.FILL_AND_STROKE);
  renderStyleIconIdle.renderStyleMG.paintFill.setColor(ColorsMaterialDesign.GREY5);
  renderStyleIconIdle.renderStyleMG.paintFill.setAntiAlias(true);
  renderStyleIconIdle.renderStyleMG.paintStroke.setColor(ColorsMaterialDesign.GREY8);
  renderStyleIconIdle.renderStyleMG.paintStroke.setStrokeWidth(5);
  //
  renderStyleIconIdle.renderStyleFG.paintFill.setColor(ColorsMaterialDesign.GREY8);
  renderStyleIconIdle.renderStyleFG.paintFill.setAntiAlias(true);
  //
  anElementIcon.setStyleIdle(renderStyleIconIdle);
```
### The ElementIcon class
The ElementIcon provides support for the SDK's Selected and Highlighted states for SVG elements with the "Ground Conventions"
renderStyleIconIdle, renderStyleIconSelected, renderStyleIconHighlighted
are the public fields available.

### The EngineView class
You must instantiate the frameworks EngineView class and connect it to the M class
```Java
    engineView = (EngineView) findViewById(R.id.engineview);
    m.setEngineView(engineView);
    m.onResume();
```

Defining the view in xml layout would look something to this.

```XML
<com.jibestream.jibestreamandroidlibrary.main.EngineView
                android:id="@+id/engineview"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                />            
```
#### Engine's events dispatches.
The EngineView implements the simple gestures from the platform and for convenience propagates the events by dispatching them via the LocalBroadcastManager.
If the user wishes for some reason to react to one of the following events.

* EngineView.SURFACE_CREATED
* EngineView.SURFACE_DESTROYED
* EngineView.SURFACE_CHANGED
* EngineView.ON_TOUCH_EVENT
* EngineView.ON_ROTATION
* EngineView.ON_SCALE
* EngineView.ON_DOWN
* EngineView.ON_SINGLE_TAP_UP
* EngineView.ON_SINGLE_TAP_CONFIRMED
* EngineView.ON_DOUBLE_TAP
* EngineView.ON_SCROLL
* EngineView.ON_LONGPRESS
* EngineView.ON_FLING

```Java

LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.SURFACE_CREATED));
localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.SURFACE_DESTROYED));

BroadcastReceiver broadcastRecieverEngineView = new BroadcastReceiver() {
  @Override
  public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (engineView.id != intent.getIntExtra("id", -1)) return;
    switch (action) {
      case EngineView.SURFACE_CREATED:

        break;
      case EngineView.SURFACE_DESTROYED:

        break;
    }
  }
};
```

### Model and Building
All engine's states are stored under the class M from here you can retrieve state`s values either from public fields
or from getters and setters if a state dispatches an Event.
M maintains all data and Building is a static class with helper methods attached to it.

#### Accessing the Element list.
All the elements can be accessed from the following method. Its important to synchronize against the returned list.
```Java
  ArrayList<Element> elementList = m.getElementList();
  synchronized (elementList) {
     for (Element element : elementList) {
          if (!(element instanceof Unit)) continue;
          unit = ((Unit) element);
     }
  }
```

#### Displaying a different level.
To display a different level of the venue there a few methods available.

Setting relatively to current level
```Java
  m.prevLevel();
  m.nextLevel();
```
Setting explicitly by providing map's the data object.
```Java
  MapFull map = m.venueData.maps[el.getLevel()];
  m.setLevel(map);
```
Setting it by providing the index of the level as it appears in the m.venueData.maps array.
```Java
  m.setCurrentMapIndex(int);
```
#### Showing the wayfind route.
The developer can show the route by setting the M.setFromWaypoint() and the M.setToWaypoint() and can reset by nullifying the setters. 

```Java
  Waypoint waypointFrom = Building.getWaypointsOfDestination(m, aDestinationFrom)[0];
  m.setFromWaypoint(aWaypointFrom);
//
  Waypoint waypointTo = Building.getWaypointsOfDestination(m, aDestinationTo)[0];
  m.setToWaypoint(waypointTo);
```
#### Manipulating the view
Each instance of M class comes with a camera that the developer can manipulate.
The frame of reference is within map coordinates and the center of the camera is the origin point of the transformations applied to it.

```Java
      m.camera.setRoll(aFloat);
      //
      m.camera.setTranslation(x,y);
```

##### Frame a region
In allot of cases the developer would like to place the camera in a fashion that frames a certain region.

```Java
      m.camera.zoomTo(aRectF, padding);
```

##### Frame a visual element.
When desired to frame a particular map element the developer can obtain the bounding box of the element and use it as the region the camera will frame to.

```Java
    Element el;
    m.camera.zoomTo(el.getBBox(), 10);
    // 
    m.setLevel(m.venueData.maps[el.getLevel()]);
```


##### Framing the Camera to a Destination with no shape associated with
When a Destination has been populated on the UXM with no relative associated graphical shape, one has to create a region of interest by referring to the waypoint the Destination has been assigned to.
```Java
  // Your references 
  M m;
  Destination destination;
  // A destination can be instantiated on numerous waypoints
  final Waypoint[] waypointsOfDestination = Building.getWaypointsOfDestination(m, destination);
  // so define which waypoint you are interested in 
  final Waypoint waypoint = waypointsOfDestination[0];
  final int levelIndexOfWaypointWithID = Building.getLevelIndexOfWaypointWithID(m, waypoint.id);
  m.setCurrentMapIndex(levelIndexOfWaypointWithID);
  // create a rect from a point and inflate it
  final float x = waypoint.x;
  final float y = waypoint.y;
  RectF rectF = new RectF(x,y,x,y);
  // pixel padding
  float padding = 100;
  rectF.inset(-padding,-padding);
  m.camera.zoomTo(rectF);
```
##### Hiding Types
To collectively set the visibility of the the predefined types 
```Java
  m.setActiveHUDs(boolean);
  m.setActiveLabels(boolean);
  m.setActiveMapLabels(boolean);
  m.setActiveAmenities(boolean);
```
##### Hiding Amenities types
Amenities types are dynamically created on the UXM and the SDK stores a boolean array for controlling the visibility of each particular type. It can be accessed from
```Java
  // retrieve
  boolean[] states = m.getAmenitiesVisibility();
  // set
  m.setAmenitiesVisibility(states);
```
 The order of the array is aligned with the entries of the data object entries of the Amenity type.
```Java
      Amenity[] amenities = m.venueData.amenities;
```

#### Listening to an element touch event.
The developer can set if a certain type or an individual element is selectable.
By default the Unit Type is selectable and in the SDK will broadcast an event whenever a user interacted with the visual representation.
An example follows how to react to double tapping on a Unit and framing that unit within the viewport.

```Java
LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
localBroadcastManager.registerReceiver(broadcastReceiverTouchDouble, new IntentFilterTouch(m, IntentFilterTouch.TYPE_DOUBLE));
//
broadcastReceiverTouchDouble = new BroadcastReceiver() {
  @Override
  public void onReceive(Context context, Intent intent) {

    IntentTouch intentTouch = (IntentTouch) intent;
    final Element element = m.getElementWithID(intentTouch.id);

    if (element instanceof Unit) {
      Unit unit = (Unit) element;
      m.camera.zoomTo(unit.getBBox(), 10);
    }
  }
};
```

#### Highlight Categories
```Java
  Category category = m.venueData.categories[int];
  Building.unHighlightUnits(m);
  Building.highlightUnitsByCategory(m, category);
```
#### Capture Snapshot
```Java
  // position the camera to frame a unit by getting the element's bounding box.
  final Element element = elements.get(0);
  m.setLevel(m.venueData.maps[element.getLevel()]);
  int paddingInPixes = 10;
  m.camera.zoomTo(element.getBBox(), paddingInPixes);
  //
  final Bitmap bitmap = Bitmap.createBitmap((int) m.camera.getViewport().width(), (int) m.camera.getViewport().height(), Bitmap.Config.ARGB_8888);
  Canvas canvas = new Canvas(bitmap);
  m.renderToCanvas(canvas, new M.RenderCallback() {
    @Override
    public void onRender() {
      runOnUiThread(new Runnable() {
        @Override
        public void run() {
          // update the ImageView
          mapImageView.setImageBitmap(bitmap);
        }
      });
    }
  });
```
#### Creating a Custom Shape
Create a Shape that describes the desired representation by overriding  the onDraw() callback and getBBox() method
```Java
public class CustomShape extends com.jibestream.jibestreamandroidlibrary.shapes.Shape {
//...
@Override
public void onDraw(Canvas canvas, Paint paint) {
  // save the canvas matrix if a transformation will be applied
  canvas.save();
  // accommodate for the offset applied
  canvas.translate(offsetX, offsetY);
  // start drawing here
  canvas.drawPath(path, paint);
  //  ...more drawing calls
  // restore the matrix state
  canvas.restore();
}
//...
@Override
public RectF getBBox() {
  // return the a Rectangle that describes the region of drawing 
  return bbox;
}
```

#### Adding Movers as Icons
Representational graphical shapes for Mover types are defined within the map but 
 sometimes its desired to reinforce their presence when styling them is not enough. The following snippet provides a simple solution.
 ```Java
   for (com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Path path : m.venueData.paths) {
     final int type = path.type;
     if (type == PathType.PATH_TYPE_NORMAL_PATH) continue;
     for (int wpID : path.waypoints) {
       final Waypoint waypoint = Building.getWaypointsById(m, wpID);
       final int level = Building.getLevelIndexOfWaypointWithID(m, waypoint.id);
       final ElementIcon elementIcon;
       elementIcon = new ElementIcon();
       elementIcon.setHeadsUp(true);
       elementIcon.setLevel(level);
       elementIcon.getTransform().setScale(0.3f);
       elementIcon.getTransform().setTranslationX(waypoint.x);
       elementIcon.getTransform().setTranslationY(waypoint.y);
       m.addToMap(elementIcon);
       int size = m.venueData.pathTypes.length;
       for (int i = 0; i < size; i++) {
         final PathType pathType = m.venueData.pathTypes[i];
         if (pathType.pathTypeId == path.type) {
           IconShape iconShape = m.iconShapeLib.getIcon(pathType.typeName);
           elementIcon.setShape(iconShape);
           break;
         }
       }
     }
   }
 ```