package com.jibestream.androidsdk.customElements;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PathMeasure;
import android.graphics.RectF;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;

import com.jibestream.jibestreamandroidlibrary.elements.*;
import com.jibestream.jibestreamandroidlibrary.intentFilters.IntentFilterMap;
import com.jibestream.jibestreamandroidlibrary.intentFilters.IntentFilterWayfind;
import com.jibestream.jibestreamandroidlibrary.intents.IntentMap;
import com.jibestream.jibestreamandroidlibrary.intents.IntentWayfind;
import com.jibestream.jibestreamandroidlibrary.main.Camera;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.ASNode;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.PathPerFloor;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapFull;
import com.jibestream.jibestreamandroidlibrary.shapes.Circle;
import com.jibestream.jibestreamandroidlibrary.shapes.IconShape;
import com.jibestream.jibestreamandroidlibrary.shapes.Shape;
import com.jibestream.jibestreamandroidlibrary.shapes.Star;
import com.jibestream.jibestreamandroidlibrary.styles.RenderStyle;
import com.jibestream.jibestreamandroidlibrary.styles.RenderStyleIcon;
import com.jibestream.jibestreamandroidlibrary.utils.ColorsMaterialDesign;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by emmanuel on 2016-04-11.
 */
public class WayfindManager {

private static final String TAG = "WayfindManager";
private M m;
private Context context;
public ElementMap youAreHere;
public ElementMap pin;
public RouteCustom route;
public ElementIcon moverHead;
public ElementIcon moverTail;
public PathPerFloor[] pathPerFloors;
public Handler handler;
public ArrayList<Segment> segments;

public WayfindManager(M m, Context context) {
  this.m = m;
  this.context = context;
  // Disable sdks wayfinding elements
  m.youAreHere.setActive(false);
  m.pin.setActive(false);
  m.moverA.setActive(false);
  m.moverB.setActive(false);
  m.route.setActive(false);
  // instantiate appropriate elements
  youAreHere = new ElementMap();
  pin = new ElementMap();
  route = new RouteCustom();
  moverHead = new ElementIcon();
  moverTail = new ElementIcon();
  // Set constraints
  youAreHere.setHeadsUp(true);
  youAreHere.setConstantScale(true);
  pin.setHeadsUp(true);
  pin.setConstantScale(true);
  moverHead.setConstantScale(true);
  moverTail.setConstantScale(true);
  moverHead.setHeadsUp(true);
  moverTail.setHeadsUp(true);
  // Assign the shape each element will have
  youAreHere.setShape(new Circle(20f));
  pin.setShape(new Star(30, 20, 5));
  // Compensate for size
  moverHead.getTransform().setScale(0.9f);
  moverTail.getTransform().setScale(0.9f);
  // offset
  moverHead.setOffsetY(-25);
  moverTail.setOffsetY(-25);
  // Define styles
  final RenderStyle renderStyleYAH = new RenderStyle(Paint.Style.FILL_AND_STROKE);
  renderStyleYAH.setFillColor(ColorsMaterialDesign.AMBERA7);
  renderStyleYAH.paintFill.setShadowLayer(8, 0, 0, 0x88263238);
  renderStyleYAH.paintFill.setAntiAlias(true);
  renderStyleYAH.setStrokeColor(ColorsMaterialDesign.RED6);
  renderStyleYAH.paintStroke.setAntiAlias(true);
  renderStyleYAH.setStrokeWidth(2f);
  youAreHere.setStyleIdle(renderStyleYAH);
  final RenderStyle renderStylePin = new RenderStyle(Paint.Style.FILL_AND_STROKE);
  renderStylePin.setFillColor(ColorsMaterialDesign.AMBERA7);
  renderStylePin.paintFill.setShadowLayer(8, 0, 0, 0x88263238);
  renderStylePin.setStrokeColor(ColorsMaterialDesign.RED8);
  renderStylePin.setStrokeWidth(2f);
  pin.setStyleIdle(renderStylePin);
  final RenderStyle renderStyleRoute = new RenderStyle(Paint.Style.FILL);
  renderStyleRoute.setFillColor(ColorsMaterialDesign.AMBERA7);
  route.setStyleIdle(renderStyleRoute);
  // Movers since they are  ElementIcon s we need a RenderStyleIcon instead
  final RenderStyleIcon renderStyleIconMovers = new RenderStyleIcon();
  renderStyleIconMovers.renderStyleFG = renderStyleYAH;
  renderStyleIconMovers.renderStyleMG.paintFill.setColor(ColorsMaterialDesign.RED8);
  final RenderStyle renderStyleBG = new RenderStyle(Paint.Style.FILL_AND_STROKE);
  renderStyleBG.setFillColor(ColorsMaterialDesign.AMBERA7);
  renderStyleBG.paintFill.setAntiAlias(true);
  renderStyleBG.setStrokeColor(ColorsMaterialDesign.AMBER9);
  renderStyleBG.paintStroke.setAntiAlias(true);
  renderStyleBG.setStrokeWidth(2f);
  renderStyleIconMovers.renderStyleBG = renderStyleBG;
  moverHead.setStyleIdle(renderStyleIconMovers);
  moverTail.setStyleIdle(renderStyleIconMovers);
  // Add to the map
  m.addToMap(route);
  m.addToMap(moverTail);
  m.addToMap(moverHead);
  m.addToMap(youAreHere);
  m.addToMap(pin);
  //

  handler = new Handler(Looper.getMainLooper(), callback);
}

public void start() {
  LocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiverWayfind, new IntentFilterWayfind(m, IntentFilterWayfind.ACTION));
  LocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiverMap, new IntentFilterMap(m, IntentFilterMap.ACTION));
}

public void stop() {
  LocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiverWayfind);
  LocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiverMap);
}


public Handler.Callback callback = new Handler.Callback() {
  @Override
  public boolean handleMessage(Message msg) {
    return false;
  }
};

public void startAnimation() {
  if (segments != null) {
    handler.post(segments.get(0));
  }
}

public void stoptAnimation() {
  if (segments != null) {
    for (int i = 0; i < segments.size(); i++) {
      Segment segment = segments.get(i);
      handler.removeCallbacks(segment);
    }
  }
}

final BroadcastReceiver broadcastReceiverWayfind = new BroadcastReceiver() {
  @Override
  public void onReceive(Context context, Intent intent) {
    Log.i(TAG, "wayfind");
    stoptAnimation();
    IntentWayfind intentWayfind = (IntentWayfind) intent;
    pathPerFloors = intentWayfind.pathPerFloors;
    if (pathPerFloors == null) return;
    final MapFull currentMap = m.getCurrentMap();
    showHideWayfindElements(currentMap.map.mapId);

    int length = pathPerFloors.length;
    segments = new ArrayList<>();
    for (int i = 0; i < length; i++) {
      PathPerFloor pathPerFloor = pathPerFloors[i];
      if (pathPerFloor.points.length < 2) continue;
      final int mapId = pathPerFloor.mapId;
      final MapFull mapFull = m.getMapWithID(mapId);
      segments.add(new Segment(m, mapFull, handler, context));
    }
    length = segments.size();
    for (int i = 0; i < length; i++) {
      if (i + 1 < length) segments.get(i).setNext(segments.get(i + 1));
    }
    // shoudl be triggered from elsewhere
    startAnimation();
  }
};

final BroadcastReceiver broadcastReceiverMap = new BroadcastReceiver() {
  @Override
  public void onReceive(Context context, Intent intent) {
    Log.i(TAG, "map");
    IntentMap intentMap = (IntentMap) intent;
    final int indexCurrent = intentMap.indexCurrent;
    final MapFull mapFull = m.venueData.maps[indexCurrent];
    showHideWayfindElements(mapFull.map.mapId);
  }
};

private void showHideWayfindElements(int mapId) {
  youAreHere.setVisible(false);
  pin.setVisible(false);
  moverHead.setVisible(false);
  moverTail.setVisible(false);
  route.setVisible(false);
  //
  if (pathPerFloors == null) return;
  if (pathPerFloors.length == 0) return;
  PathPerFloor pathForCurrentFloor = getPathPerFloorOfMap(pathPerFloors, mapId);
  if (pathForCurrentFloor == null) return;
  if (pathForCurrentFloor.points.length <= 1) return;
  final int index = Arrays.asList(pathPerFloors).indexOf(pathForCurrentFloor);
  final int totalPaths = pathPerFloors.length;
  int levelsIndexWithMapID = m.getLevelsIndexWithMapID(pathForCurrentFloor.mapId);
  /// YAH--------------------------------------
  if (index == 0) {
    PathPerFloor firstPathPerFloor = pathPerFloors[0];
    youAreHere.getTransform().setTranslationX((float) firstPathPerFloor.points[0].x);
    youAreHere.getTransform().setTranslationY((float) firstPathPerFloor.points[0].y);
//    youAreHere.setLevel(getLevelsIndexWithMapID(firstPathPerFloor.mapId));
    youAreHere.setVisible(true);
  }

  /// PIN--------------------------------------
  if (index == totalPaths - 1) {
    PathPerFloor lastPathPerFloor = pathPerFloors[pathPerFloors.length - 1];
    int lastPointIndex = lastPathPerFloor.points.length - 1;
    pin.getTransform().setTranslationX((float) lastPathPerFloor.points[lastPointIndex].x);
    pin.getTransform().setTranslationY((float) lastPathPerFloor.points[lastPointIndex].y);
//    pin.setLevel(getLevelsIndexWithMapID(lastPathPerFloor.mapId));
    pin.setVisible(true);
  }

  /// ROUTE--------------------------------------
  if (levelsIndexWithMapID == m.getCurrentMapIndex()) {
    final Path androidPath = getAndroidPath(pathForCurrentFloor);
    ((PathCustomAnimatable) route.getShape()).setPath(androidPath);
    route.setVisible(true);
  }

  /// MOVERS--------------------------------------
  String shapeID;
  IconShape icon;
  if (totalPaths > 1) {// on multiple floors
    if (index == 0) {// First seq
      shapeID = pathForCurrentFloor.pathType.description;
      icon = m.iconShapeLib.getIcon(shapeID);
      moverTail.setShape(icon);
      moverTail.setVisible(true);
    } else if (index == totalPaths - 1) { // Last seq
      shapeID = pathPerFloors[index - 1].pathType.description;
      icon = m.iconShapeLib.getIcon(shapeID);
      moverHead.setShape(icon);
      moverHead.setVisible(true);
    } else if (0 < index && index < totalPaths) { // between
      moverHead.setVisible(true);
      moverTail.setVisible(true);

      shapeID = pathPerFloors[index - 1].pathType.description;
      icon = m.iconShapeLib.getIcon(shapeID);
      moverHead.setShape(icon);
      shapeID = pathForCurrentFloor.pathType.description;
      icon = m.iconShapeLib.getIcon(shapeID);
      moverTail.setShape(icon);
    }
  } else { // one floor
  }
  moverHead.getTransform().setTranslationX((float) pathForCurrentFloor.points[0].x);
  moverHead.getTransform().setTranslationY((float) pathForCurrentFloor.points[0].y);
  int lastInt = pathForCurrentFloor.points.length - 1;
  moverTail.getTransform().setTranslationX((float) pathForCurrentFloor.points[lastInt].x);
  moverTail.getTransform().setTranslationY((float) pathForCurrentFloor.points[lastInt].y);
}

/**
 * Return PathPerFloor for specified map
 *
 * @param pathPerFloors PathPerFloor[] object returned from wayfind algo.
 * @param mapId         MapFull.map.mapId
 * @return
 */
private PathPerFloor getPathPerFloorOfMap(PathPerFloor[] pathPerFloors, int mapId) {
  if (pathPerFloors == null) return null;
  final int lengthPaths = pathPerFloors.length;
  if (lengthPaths == 0) return null;
  PathPerFloor pathPerFloor = null;
  for (int i = 0; i < lengthPaths; i++) {
    final PathPerFloor perFloor = pathPerFloors[i];
    if (perFloor.mapId == mapId) {
      pathPerFloor = perFloor;
      break;
    }
  }
  return pathPerFloor;
}

/**
 * Converts PathPerFloor points to android.graphics.Path
 *
 * @param pathPerFloor
 * @return
 */
private Path getAndroidPath(PathPerFloor pathPerFloor) {
  if (pathPerFloor == null) return null;
  Path path = new Path();
  final ASNode[] points = pathPerFloor.points;
  final int lengthPnts = points.length;
  for (int j = 0; j < lengthPnts; j++) {
    ASNode asNode = points[j];
    if (j == 0) {
      path.moveTo((float) asNode.x, (float) asNode.y);
    } else {
      path.lineTo((float) asNode.x, (float) asNode.y);
    }
  }
  return path;
}

private static class Segment implements Runnable {
  private M m;
  private MapFull mapFull;
  private Segment next;
  private Handler handler;
  private Context context;

  public Segment(M m, MapFull mapFull, Handler handler, Context context) {
    this.m = m;
    this.mapFull = mapFull;
    this.handler = handler;
    this.context = context;
  }

  @Override
  public synchronized void run() {
    Log.i(TAG, "set level " + mapFull.map.mapId);
    m.setLevel(mapFull);
    m.camera.zoomTo(m.route.getBBox(), 100);// TODO: 2016-04-11 passroute
    final BroadcastReceiver br = new BroadcastReceiver() {
      @Override
      public void onReceive(Context context, Intent intent) {
        Log.i(TAG, "path_complete");
        LocalBroadcastManager.getInstance(context).unregisterReceiver(this);
        if (next != null) {
          handler.postDelayed(next, 1000);
        }
      }
    };
    LocalBroadcastManager.getInstance(context).registerReceiver(br, new IntentFilter(PathCustomAnimatable.PATH_COMPLETE));
  }

  public synchronized void setNext(Segment next) {
    this.next = next;
  }
}

public static class RouteCustom extends ElementMap {

  public PathCustomAnimatable pathCustomAnimatable;

  @Override
  public void onCreate(Context context, M m, long timeElapsed, long timeTotal, Camera camera) {
    super.onCreate(context, m, timeElapsed, timeTotal, camera);
    // use our custom shape
    pathCustomAnimatable = new PathCustomAnimatable(context);
    setShape(pathCustomAnimatable);
  }

  @Override
  public void onUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera) {
    final float cameraZoom = camera.getScale();
    // update the shape`s size according to zoom level.
    pathCustomAnimatable.setMult(cameraZoom);
  }

}

// No animated path is provided by the android platform
// so indeed we need to hack with circles
public static class PathCustomAnimatable extends Shape {
  public static String PATH_COMPLETE = "PATH-COMPLETE";
  //
  private Path path = new Path();
  // dictates the width of the path
  private float circleSize = 3f;
  private float circleSizeAdapted = circleSize;
  // a multiplier to draw more circles per frame
  private float speedScale = 5f;
  // accumulator that will match the path`s length
  private float steps = 0;
  private float pathLength;
  private PathMeasure pathMeasure = new PathMeasure();
  private final Object lock = new Object();
  private float[] point = new float[]{0f, 0f};
  // will be adapted according to size
  private float stride;
  // for broadcasting
  private Context context;
  // run once flag
  public boolean isComplete = false;
  // paint when path animation is complete in order to do a simple drawPath call
  public Paint paintForCompletedAnimation;

  public PathCustomAnimatable(Context context) {
    this.context = context;
    paintForCompletedAnimation = new Paint();
    paintForCompletedAnimation.setStyle(Paint.Style.STROKE);
    paintForCompletedAnimation.setStrokeJoin(Paint.Join.ROUND);
  }

  private void calc() {
    synchronized (lock) {
      pathMeasure.setPath(path, false);
      stride = circleSizeAdapted * 0.5f;
      pathLength = pathMeasure.getLength();
    }
    final RectF bbox = new RectF();
    path.computeBounds(bbox, true);
    setBBox(bbox);
    paintForCompletedAnimation.setStrokeWidth(circleSizeAdapted * 2f);
  }

  public void setPath(Path path) {
    if (path == null) return;
    synchronized (lock) {
      this.path.set(path);
      isComplete = false;
      steps = 0;
      calc();
    }
  }

  public void setMult(float multi) {
    circleSizeAdapted = circleSize * multi;
    calc();
  }

  @Override
  public void onDraw(Canvas canvas, Paint paint) {
    if (isComplete) {
      // switch to a more efficient rendering once animation is complete
      paintForCompletedAnimation.setColor(paint.getColor());
      synchronized (lock) {
        canvas.drawPath(path, paintForCompletedAnimation);
      }
    } else {
      synchronized (lock) {
        // animation drawing
        for (float i = 0; i < steps; i += stride) {
          pathMeasure.getPosTan(i, point, null);
          canvas.drawCircle(point[0], point[1], circleSizeAdapted, paint);
        }
      }
    }
    // checks
    if (steps <= pathLength) {
      steps += stride * speedScale;
    } else {
      steps = pathLength;
      if (!isComplete) {
        // Broadcast a message to catch and set the next level
        final LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(context.getApplicationContext());
        lbm.sendBroadcast(new Intent(PATH_COMPLETE));
        isComplete = true;
      }
    }
  }
}
}