package com.jibestream.androidsdk.customElements;

import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.RectF;

import com.jibestream.androidsdk.customShape.UnitLabelBubbleShape;
import com.jibestream.jibestreamandroidlibrary.elements.Element;
import com.jibestream.jibestreamandroidlibrary.main.Camera;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.shapes.IShape;
import com.jibestream.jibestreamandroidlibrary.styles.RenderStyle;
import com.jibestream.jibestreamandroidlibrary.math.Transform;
import com.jibestream.jibestreamandroidlibrary.math.Vec;
import com.jibestream.jibestreamandroidlibrary.utils.ColorsMaterialDesign;

import java.util.ArrayList;
import java.util.Random;

/**
 * Created by emmanuel on 15-07-05.
 */
public class UnitLabelBubble extends com.jibestream.jibestreamandroidlibrary.elements.UnitLabel {
public int MAX_COLLISONS_THRESHHOLD;
public static final float SCALE_THRESHHOLD = 0.5f;
private final Paint paintDir;
public final Transform collisionTransform;
public final Transform scaleToScnCntrT;
private float maxRadius;
private float desiredScale = 1f;
private final Vec desiredTranslationV = new Vec();
private int howManyTimesCollided;
private UnitLabelBubbleShape unitLabelBubbleShape;
private boolean showBubbles = true;
private final Matrix bboxMatrix = new Matrix();
/**
 * Ability to inform later elements if the current element has been
 * modified from a previous element that it collided with.
 */
private final Paint paintDebug;
private volatile Camera camera;
private Matrix transformationLocal = new Matrix();

public UnitLabelBubble() {
  super();

  setCollidable(true);
  setHeadsUp(true);
  setHeadsUpFlip(false);
//  setBoundingBoxVisible(true);

  styleIdle = new RenderStyle();
  styleIdle.setFillColor(ColorsMaterialDesign.GREY9);
//  styleIdle.paintFill.setColor(Color.BLACK);
//  styleIdle.paintFill.setAlpha((int) (255f*0.7f));
  styleIdle.paintFill.setAntiAlias(true);

  collisionTransform = new Transform();
  scaleToScnCntrT = new Transform();

  getTransform().addChild(collisionTransform);
  collisionTransform.addChild(scaleToScnCntrT);

  unitLabelBubbleShape = new UnitLabelBubbleShape();

  paintDebug = new Paint();
  paintDebug.setStyle(Paint.Style.STROKE);
  paintDebug.setColor(ColorsMaterialDesign.AMBER7);
  paintDebug.setStrokeWidth(1);

  paintDir = new Paint();
  paintDir.setStyle(Paint.Style.STROKE);
  paintDir.setColor(ColorsMaterialDesign.CYAN7);
  paintDir.setStrokeWidth(3);

  MAX_COLLISONS_THRESHHOLD = new Random(System.currentTimeMillis()).nextInt(11) + 3;
}

private void calc() {
  float minSide = Math.min(width, height) * 0.33f;
  maxRadius = (float) Math.sqrt(minSide * minSide + minSide * minSide) * 0.8f;
}

@Override
public void onCollision(M m, ArrayList<Element> collidesWith, long timeElapsed, long timeTotal, int fps, Camera camera) {
  howManyTimesCollided++;

  desiredTranslationV.rst();
  Vec thisV = new Vec(collisionTransform.getGlobalTransX(), collisionTransform.getGlobalTransY());

  for (int i = 0; i < collidesWith.size(); i++) {
    if (!(collidesWith.get(i) instanceof UnitLabelBubble)) continue;
    UnitLabelBubble unitLabelBubble = (UnitLabelBubble) collidesWith.get(i);
    Vec otherV = new Vec(unitLabelBubble.collisionTransform.getGlobalTransX(), unitLabelBubble.collisionTransform.getGlobalTransY());
    Vec dV = Vec.sub(otherV, thisV);
    desiredTranslationV.add(dV);
  }
  desiredTranslationV.div(collidesWith.size()).inv();

  if (Vec.add(desiredTranslationV, thisV).len() > maxRadius) {
    desiredTranslationV.nrm().mul(maxRadius);
  }
  desiredTranslationV.mul(0.5f);


  // scaling
  desiredScale -= 0.1f;

  // bubble threshold checks
  if (howManyTimesCollided > MAX_COLLISONS_THRESHHOLD ||
      desiredScale < SCALE_THRESHHOLD) {
    setCollidable(false);
    desiredScale = 0;
    desiredTranslationV.set(0, 0);
  }
}

@Override
public void onUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera) {
  if (camera == null) return;
  this.camera = camera;

//  collisionTransform.validate();
//  scaleToScnCntrT.validate();

  if (!showBubbles) return;

  float scaleX = collisionTransform.getScaleX();

  if (scaleX < 0.1) {
    showBubbles = false;
    setHeadsUp(false);
    setHeadsUpFlip(true);
  }

  if (scaleX > desiredScale) {
    float v = scaleX - ((scaleX - desiredScale) * 0.5f);
    collisionTransform.setScale(v);
  }

  Vec difV = Vec.sub(collisionTransform.getTranslation(), desiredTranslationV);
  if (difV.len() > 1f) {
    collisionTransform.setTranslation(
        Vec.sub(collisionTransform.getTranslation(), difV.mul(0.5f))
    );
  }

  //Scale to center of screen
  Vec scrnV = getTransform().getScreenTrans(camera.getMatrix());
  Vec scnCntrV = new Vec(
      camera.getViewport().centerX(),
      camera.getViewport().centerY()
  );
  scnCntrV.sub(scrnV);
  float mm = scnCntrV.lenSqr();
  mm = mm / 40000;//200px Sqr
  mm = Math.min(Math.max(mm, 0), 1f);
  mm = 1f - mm;
  mm += 1f;
//  float recip = 1f / scaleX;
//  mm = Math.min(Math.max(mm, 0.8f), recip);
  mm = Math.min(Math.max(mm, 0.8f), 1.5f);
  scaleToScnCntrT.addScale((mm - scaleToScnCntrT.getScaleX()) * 0.5f);
  //
//  transformationLocal.set(getTransform().getGlobalMatrix());
//  if (showBubbles) {
//    transformationLocal.set(scaleToScnCntrT.getGlobalMatrix());
//    transformationLocal.set(transform.getGlobalMatrix());
//    Matrix scaleToScnCntrTGlobalMatrix = scaleToScnCntrT.getGlobalMatrix();
//    transformationLocal.postConcat(scaleToScnCntrTGlobalMatrix);
//    transformation.set(transformationLocal);
//  } else {
    super.onUpdate(m,timeElapsed, timeTotal, fps, camera);
//  }
}

@Override
public void onRender(Canvas canvas, Paint touchPaint) {
  super.onRender(canvas, touchPaint);
  canvas.drawCircle(0, 0, 5, paintDebug);
}

@Override
public IShape getShape() {
  if (showBubbles) {
    return unitLabelBubbleShape;
  } else {
    return super.getShape();
  }
}

@Override
public RectF getBBox() {
  if (showBubbles) {
    final RectF bbox = getBBox();
    bbox.set(unitLabelBubbleShape.getBBox());
    bboxMatrix.set(camera.getMatrix());
    bboxMatrix.preConcat(collisionTransform.getGlobalMatrix());
    bboxMatrix.mapRect(bbox);
    bbox.offset(getOffsetX(), getOffsetY());
    return bbox;
  } else {
    return super.getBBox();
  }
}

@Override
public void setText(String s) {
  super.setText(s);
  unitLabelBubbleShape.setTextString(s);
}

@Override
public void setWidth(float width) {
  super.setWidth(width);
  unitLabelBubbleShape.setWidth(width);
  calc();
}

@Override
public void setHeight(float height) {
  super.setHeight(height);
  unitLabelBubbleShape.setHeight(height);
  calc();
}

@Override
public int compareTo(Element another) {
  if (another instanceof UnitLabelBubble) {
    UnitLabelBubble anotherUnitLabelBubble = (UnitLabelBubble) another;
    if (anotherUnitLabelBubble.getDestinations() != null) {
      int score;
      score = this.getDestinations()[0].sponsoredRating - anotherUnitLabelBubble.getDestinations()[0].sponsoredRating;
      if (score == 0)
        score = (int) (((UnitLabelBubbleShape) getShape()).area - ((UnitLabelBubbleShape) another.getShape()).area);
      return score;
    }
  }
  return super.compareTo(another);
}
}
