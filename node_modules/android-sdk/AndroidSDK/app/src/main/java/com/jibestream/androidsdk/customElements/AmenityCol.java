package com.jibestream.androidsdk.customElements;

import android.content.Context;
import android.graphics.Matrix;

import com.jibestream.jibestreamandroidlibrary.elements.Element;
import com.jibestream.jibestreamandroidlibrary.main.Camera;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.math.Transform;
import com.jibestream.jibestreamandroidlibrary.math.Vec;

import java.util.ArrayList;
import java.util.Random;

/**
 * Created by emmanuel on 15-07-05.
 */
public class AmenityCol extends com.jibestream.jibestreamandroidlibrary.elements.Amenity {
public final int MAX_COLLISIONS_THRESHOLD;
private final Vec desiredTranslationV = new Vec();
private int howManyTimesCollided;

public AmenityCol() {
  super();
  setCollidable(true);
  setHeadsUp(true);
//  setConstantScale(true);
  getTransform().setScaleOffset(0.5f);
//  setBoundingBoxVisible(true);
  MAX_COLLISIONS_THRESHOLD = new Random(System.currentTimeMillis()).nextInt(20) + 10;
//  setOffsetY(-30);
}

@Override
public void onCreate(Context context, M m, long timeElapsed, long timeTotal, Camera camera) {
  super.onCreate(context, m, timeElapsed, timeTotal, camera);

  final Transform transform = getTransform();
  transform.setTranslationOffsetX(transform.getTranslationX());
  transform.setTranslationOffsetY(transform.getTranslationY());
  transform.setTranslationX(0);
  transform.setTranslationY(0);
}

@Override
public void onCollision(M m, ArrayList<Element> collidesWith, long timeElapsed, long timeTotal, int fps, Camera camera) {

  desiredTranslationV.rst();
  Vec thisV = getTransform().getGlobalTrans();

  for (int i = 0; i < collidesWith.size(); i++) {
    if (!(collidesWith.get(i) instanceof AmenityCol)) continue;
    AmenityCol otherAmenityCol = (AmenityCol) collidesWith.get(i);
    Vec otherV = otherAmenityCol.getTransform().getGlobalTrans();
    Vec dV = Vec.sub(otherV, thisV);

    if (dV.len() < 0.01f) {
      thisV.add(
          new Random(System.currentTimeMillis()).nextFloat(),
          new Random(System.currentTimeMillis()).nextFloat()
      );
    }

    desiredTranslationV.add(dV);
  }
  desiredTranslationV.div(collidesWith.size()).inv();

//  float maxRadius = getBBox().width() * 0.5f;
  float maxRadius = 5f;
  if (Vec.add(desiredTranslationV, thisV).len() > maxRadius) {
    desiredTranslationV.nrm().mul(maxRadius);
  }


  if (howManyTimesCollided > MAX_COLLISIONS_THRESHOLD) {
    setCollidable(false);
  }
  howManyTimesCollided++;
}

@Override
public void onUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera) {

  if (!isCollidable()) return;
//  transform.setTranslation(desiredTranslationV);
  final Transform transform = getTransform();
  Vec difV = Vec.sub(transform.getTranslation(), desiredTranslationV);
  if (difV.len() > 0.1f) {
    transform.setTranslation(
        Vec.sub(transform.getTranslation(), difV.mul(0.5f))
    );
  }

  //
  float cameraScale = camera.getScale();
  float cameraRec = 1f / cameraScale;
  float zoomThreshold = 2f;
  if (cameraRec > zoomThreshold) {
    final Matrix transformation = getTransformation();
    transformation.getValues(matrixArray);
    float x = matrixArray[Matrix.MTRANS_X];
    float y = matrixArray[Matrix.MTRANS_Y];
    transformation.postScale(cameraScale, cameraScale, x, y);
    transformation.postScale(zoomThreshold, zoomThreshold, x, y);
  }
}

private float[] matrixArray = new float[9];

}
