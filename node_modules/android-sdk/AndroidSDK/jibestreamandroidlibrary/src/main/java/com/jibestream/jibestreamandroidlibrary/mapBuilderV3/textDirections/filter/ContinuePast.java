package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter;

import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.Point;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Destination;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.Helpers;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.LineOfSight;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.TDInstruction;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by frankduffy on 2016-01-27.
 */
public class ContinuePast {
    public M model;
    public Helpers hlp;
    public LineOfSight los;

    public ContinuePast(M model){
        this.model = model;
        this.hlp = new Helpers();
        List<Destination> destinations = Arrays.asList(this.model.venueData.destinations);
        los = new LineOfSight(destinations, model);
    }

    public void continuePast(TDFilterInput inst) {

        if(inst.enableDistanceFilters) {
            if(inst.addTDifEmptyMeters > 0) {

                //Cake - The Distance
                float theDistance =  (float) hlp.convertMetersToPixels(inst.addTDifEmptyMeters, inst.xScale);

                int loopToContinuePast = inst.textDirectionsFloorArray.size() - 1;

                for(int i = 0; i < loopToContinuePast; i++) {
                    TDInstruction instruction1 = inst.textDirectionsFloorArray.get(i);
                    TDInstruction instruction2 = inst.textDirectionsFloorArray.get(i+1);

                    TDInstruction usedInstruction1 = null;
                    TDInstruction usedInstruction2 = null;

                    Waypoint waypoint1 = null;
                    usedInstruction1 = instruction1;
                    if (usedInstruction1.foldedPointsFront != null && usedInstruction1.foldedPointsFront.size() > 0){
                        usedInstruction1 = usedInstruction1.foldedPointsFront.get(usedInstruction1.foldedPointsFront.size() - 1);
                    }
                    waypoint1 = usedInstruction1.wp;
                    Point point1 = new Point(waypoint1.x, waypoint1.y, 0);

                    Waypoint waypoint2 = null;
                    usedInstruction2 = instruction2;
                    waypoint2 = usedInstruction2.wp;
                    Point point2 = new Point(waypoint2.x, waypoint2.y, 0);

                    float distanceInPX = (float) hlp.distanceBetween(point1, point2);

                    float difference = -1;
                    float evenDistance = -1;

                    int denominator = (int) (distanceInPX/theDistance);

                    if(denominator > 1) {

                        difference = (distanceInPX - (theDistance * denominator)) / denominator;
                        evenDistance = theDistance + difference;

                        for(int j = 0; j < (denominator-1); j++) {
                            Point newPoint = hlp.pointOnLineUsingDistanceFromStart(point1, point2, evenDistance);

                            newPoint = hlp.correctPathUsingWayfindPath(inst.useArrayOfFloorWaypoints, newPoint, 0);


                            TDInstruction nextInsertDir = new TDInstruction();
                            nextInsertDir.floor = inst.currentFloor.mapId;
                            nextInsertDir.floorName = inst.currentFloor.name;
                            nextInsertDir.wp = new Waypoint();
                            nextInsertDir.wp.x = newPoint.x;
                            nextInsertDir.wp.y = newPoint.y;
                            nextInsertDir.wp.mapId = inst.currentFloor.mapId;

                            nextInsertDir.direction = usedInstruction1.direction;

                            float angleToNext = (float) hlp.pointPairToBearingDegrees(point1, newPoint);
                            nextInsertDir.angleToNext = angleToNext;

                            float angleToNextOfPrevious = (float) hlp.pointPairToBearingDegrees(newPoint, point2);
                            nextInsertDir.angleToNextOfPreviousDirection = angleToNextOfPrevious;

                            Point returnClosestPoint = new Point(0,0,0);

                            //Line of Sight from closest Landmark xy
                            Destination tempLandmark = los.lineOfSightFromClosestLandmarkXY(
                                    newPoint,
                                    returnClosestPoint,
                                    nextInsertDir.direction,
                                    nextInsertDir.angleToNextOfPreviousDirection,
                                    Arrays.asList(inst.curCanvas)
                            );

                            if(tempLandmark != null) {
                                nextInsertDir.landmarkDestination = tempLandmark;

                                Waypoint[] landmarkWP = this.getWaypointsByDestinationId(nextInsertDir.landmarkDestination.id);

                                if(landmarkWP.length > 0) {
                                    nextInsertDir.landmarkWP = landmarkWP[0];
                                    float angle = (float) hlp.pointPairToBearingDegrees(newPoint, returnClosestPoint);
                                    nextInsertDir.angleToLandmark = angle;

                                    double angleToLandmarkDifference = nextInsertDir.angleToNextOfPreviousDirection - nextInsertDir.angleToLandmark;
                                    while(angleToLandmarkDifference < -180) angleToLandmarkDifference += 360;
                                    while(angleToLandmarkDifference > 180) angleToLandmarkDifference -= 360;

                                    nextInsertDir.directionToLandmark = hlp.directionFromAngle((double)angleToLandmarkDifference, null);
                                }
                            } else {
                                nextInsertDir.landmarkDestination = null;
                                nextInsertDir.landmarkWP = null;
                                nextInsertDir.angleToLandmark = -1;

                            }

                            if(nextInsertDir.landmarkDestination != null) {
                                ArrayList<String> stringList = new ArrayList<String>();
                                stringList.add("Continue Past %");
                                stringList.add(nextInsertDir.landmarkDestination.name);
                                nextInsertDir.output = hlp.stringWithFormat(stringList);
                            } else {
                                nextInsertDir.output = "Continue Past";
                            }

                            inst.textDirectionsFloorArray.add(i + 1, nextInsertDir);

                            loopToContinuePast++;
                            i++;

                            point1.x = newPoint.x;
                            point1.y = newPoint.y;

                        }
                    }
                }
            }
        }
    }

    public Waypoint[] getWaypointsByDestinationId(int destId) {
        ArrayList<Waypoint> wpList = new ArrayList<Waypoint>();
        for(int i = 0; i < this.model.venueData.waypoints.length; i++) {
            if (this.model.venueData.waypoints[i].associations == null) {
                continue;
            }
            for(int j = 0; j < this.model.venueData.waypoints[i].associations.length; j++) {
                if(this.model.venueData.waypoints[i].associations[j].entityTypeId == 1) {
                    if(this.model.venueData.waypoints[i].associations[j].entityId == destId) {
                        wpList.add(this.model.venueData.waypoints[i]);
                    }
                }
            }
        }

        return wpList.toArray(new Waypoint[wpList.size()]);
    }
}