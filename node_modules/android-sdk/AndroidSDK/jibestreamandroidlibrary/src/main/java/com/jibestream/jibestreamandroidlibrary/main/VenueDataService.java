package com.jibestream.jibestreamandroidlibrary.main;

import android.app.IntentService;
import android.content.Context;
import android.content.Intent;
import android.net.ConnectivityManager;
import android.os.Looper;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;

import com.google.gson.Gson;
import com.jibestream.jibestreamandroidlibrary.http.BasicAuthentication;
import com.jibestream.jibestreamandroidlibrary.http.HttpClient;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.NovomapV3Api;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.DestinationLabel;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Device;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.LocationFull;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapFull;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.PathType;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Refresh;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Uri;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;
import com.jibestream.jibestreamandroidlibrary.utils.InternalStorage;
import com.jibestream.jibestreamandroidlibrary.utils.Strings;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 * An {@link IntentService} subclass for handling asynchronous task requests in
 * a service on a separate handler thread.
 * <p/>
 * helper methods.
 */
public class VenueDataService extends IntentService {
  private static final String TAG = "VenueDataService";
  public static final String DONE = "com.jibestream.jibestreamandroidlibrary.main.action.DONE";
  public static final String ERROR = "com.jibestream.jibestreamandroidlibrary.main.action.ERROR";
  public static final String KEY_FILENAME = "com.jibestream.jibestreamandroidlibrary.main.extra.VENUEDATA_FILENAME";
  //
  private static final String ACTION_POPULATE = "com.jibestream.jibestreamandroidlibrary.main.action.ACTION_POPULATE";
  private static final String KEY_URL = "com.jibestream.jibestreamandroidlibrary.main.extra.KEY_URL";
  private static final String KEY_PROJECT_ID = "com.jibestream.jibestreamandroidlibrary.main.extra.KEY_PROJECT_ID";
  private static final String KEY_BASICAUTHENTICATION = "com.jibestream.jibestreamandroidlibrary.main.extra.KEY_BASICAUTHENTICATION";
  private static OnVenueDataServiceReadyCallback onVenueDataServiceReadyCallback;

  public VenueDataService() {
    super("VenueDataService");
  }


  /**
   * Starts this service to perform action Populate with the given parameters. If
   * the service is already performing a task this action will be queued.
   *
   * @see IntentService
   */
  public static void getData(Context context, String url, int projectId, BasicAuthentication basicAuthentication) {
    Intent intent = new Intent(context, VenueDataService.class);
    intent.setAction(ACTION_POPULATE);
    intent.putExtra(KEY_URL, url);
    intent.putExtra(KEY_PROJECT_ID, projectId);
    intent.putExtra(KEY_BASICAUTHENTICATION, basicAuthentication);
    context.startService(intent);
  }

  @Override
  protected void onHandleIntent(Intent intent) {
    if (intent == null) return;
    final String action = intent.getAction();
    if (action.equals(ACTION_POPULATE)) {
      String url = intent.getStringExtra(KEY_URL);
      final int projectId = intent.getIntExtra(KEY_PROJECT_ID, -1);
      BasicAuthentication basicAuthentication = intent.getParcelableExtra(KEY_BASICAUTHENTICATION);
      //
      final VenueData venueData = new VenueData(url, projectId, basicAuthentication);
      getData(getApplicationContext(), venueData, new Callbacks() {
        @Override
        public void onSuccess() {
          Intent intent = new Intent(DONE);
          intent.putExtra(KEY_FILENAME, String.valueOf(projectId));
          LocalBroadcastManager.getInstance(VenueDataService.this).sendBroadcast(intent);
          if (onVenueDataServiceReadyCallback != null) {
            runOnUiThread(new Runnable() {
              @Override
              public void run() {
                onVenueDataServiceReadyCallback.onVenueDataReady(String.valueOf(projectId));
              }
            });
          }
        }

        @Override
        public void onError() {
          Intent intent = new Intent(ERROR);
          LocalBroadcastManager.getInstance(VenueDataService.this).sendBroadcast(intent);
          if (onVenueDataServiceReadyCallback != null) {
            runOnUiThread(new Runnable() {
              @Override
              public void run() {
                onVenueDataServiceReadyCallback.onVenueDataError();
              }
            });
          }
        }
      });
    }
  }

  private static void getData(Context context, VenueData venueData, final Callbacks callbacks) {
    context = context.getApplicationContext();

    if (checkForConnectivity(context)) {
      Log.d(TAG, "We have internet");
      String filename = getFilename(venueData);
      boolean fileExists = InternalStorage.fileExists(context, filename);
      // do we have cache
      if (fileExists) {
        Log.d(TAG, "We have cache");
        String json = null;
        try {
          json = InternalStorage.readFile(context, filename);
        } catch (IOException e) {
          e.printStackTrace();
          Log.d(TAG, "Cant read file, will call full");
          fullCall(context, venueData, callbacks);
        }
        venueData.populateFromJson(json);
        getTimeStampAndCompareCached(context, venueData, callbacks);
      } else {
        Log.d(TAG, "No cache");
        fullCall(context, venueData, callbacks);
      }
    } else {
      Log.d(TAG, "No internet... ");
      checkForLocalJsonNoInternet(context, venueData, callbacks);
    }
  }

  private static boolean checkForConnectivity(Context context) {
    ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
    if (connectivityManager.getActiveNetworkInfo() == null || !connectivityManager.getActiveNetworkInfo().isConnected()) {
      return false;
    } else {
      return true;
    }
  }

  private static void checkForLocalJsonNoInternet(final Context context, VenueData venueData, final Callbacks callbacks) {
    String filename = getFilename(venueData);
    boolean fileExists = InternalStorage.fileExists(context, filename);
    if (fileExists) {
      String json = null;
      try {
        json = InternalStorage.readFile(context, filename);
      } catch (IOException e) {
        e.printStackTrace();
      }
      if (json != null) {
        Log.d(TAG, "But have cache ");
        venueData.populateFromJson(json);
        callbacks.onSuccess();
      } else {
        Log.e(TAG, "Cant continue... ");
        callbacks.onError();
      }
    } else {
      Log.e(TAG, "Cant continue... ");
      callbacks.onError();
    }
  }

  private static void getTimeStampAndCompareCached(final Context context, final VenueData venueData, final Callbacks callbacks) {
    if (venueData != null &&
            venueData.url != null && !venueData.url.isEmpty() &&
            venueData.projectID >= 0 &&
            venueData.deviceID >= 0) {
      Log.d(TAG, "getting timestamp");
      String reqUrl = NovomapV3Api.refresh(venueData.url, venueData.projectID, venueData.deviceID);
      HttpClient.downloadUrl(reqUrl, new HttpClient.DownloadCallbacks() {
        @Override
        public void onSuccess(String response) {
          Gson gson = new Gson();
          Refresh refresh = gson.fromJson(response, Refresh.class);
          if (Refresh.validate(refresh) &&
                  refresh.clientTimestamp.equalsIgnoreCase(venueData.timestamp)) {
            Log.d(TAG, "timestamp the same ");
            callbacks.onSuccess();
          } else {
            Log.d(TAG, "timestamp not the same.. fetching fresh one ");
            fullCall(context, venueData, callbacks);
          }
        }

        @Override
        public void onError(int responseCode) {
          Log.i(TAG, "cant get timestamp response will use existing cache anyhow");
          callbacks.onSuccess();
        }
      }, venueData.basicAuthentication);
    } else {
      Log.i(TAG, "cant call timestamp will use existing cache anyhow");
      callbacks.onSuccess();
    }
  }

  private static void fullCall(final Context context, final VenueData venueData, final Callbacks callbacks) {
    final String reqUrl = NovomapV3Api.getLocationFull(venueData.url, venueData.projectID);

    HttpClient.downloadUrl(reqUrl, new HttpClient.DownloadCallbacks() {
      @Override
      public void onSuccess(String response) {
        parseFull(context, response, venueData, callbacks);
      }

      @Override
      public void onError(int responseCode) {
        callbacks.onError();
      }
    }, venueData.basicAuthentication);
  }

  private static void parseFull(final Context context, String json, VenueData venueData, Callbacks callbacks) {
    Gson gson = new Gson();
    LocationFull locationFull = gson.fromJson(json, LocationFull.class);
//      Log.i(TAG, "getLocationFull " + response);
    venueData.destinations = locationFull.destinations;
    venueData.categories = locationFull.categories;
    venueData.paths = locationFull.paths;
    venueData.pathTypes = locationFull.pathTypes;
    venueData.maps = locationFull.maps;
    venueData.devices = locationFull.devices;
    venueData.amenities = locationFull.amenities;
    venueData.zones = locationFull.zones;

    ArrayList<Waypoint> waypointArrayList = new ArrayList<>();
    for (MapFull mapFull : venueData.maps) {
      if (mapFull.waypoints != null && mapFull.waypoints.length > 0) {
        Collections.addAll(waypointArrayList, mapFull.waypoints);
      }
    }
    venueData.waypoints = waypointArrayList.toArray(new Waypoint[waypointArrayList.size()]);

    // Sort the maps array according to the sequence int
    Collections.sort(Arrays.asList(venueData.maps), new Comparator<MapFull>() {
      public int compare(MapFull o1, MapFull o2) {
        if (o1.map.floorSequence == o2.map.floorSequence)
          return 0;
        return o1.map.floorSequence < o2.map.floorSequence ? -1 : 1;
      }
    });
    for (Device device : venueData.devices) {
      if (device.deviceTypeId == 4) {
        venueData.deviceID = device.id;
        break;
      }
    }
    secondCalls(context, venueData, callbacks);
  }

  private static void secondCalls(final Context context, final VenueData venueData, final Callbacks callbacks) {
    // start timestamp
//  Log.e(TAG, "secondCalls " + Thread.currentThread().getName());
    final String reqUrl = NovomapV3Api.refresh(venueData.url, venueData.deviceID, venueData.deviceID);
    venueData.counterTotalReq++;
    HttpClient.downloadUrl(reqUrl, new HttpClient.DownloadCallbacks() {
      @Override
      public void onSuccess(String response) {
        Gson gson = new Gson();
        Refresh refresh = gson.fromJson(response, Refresh.class);
        venueData.timestamp = refresh.clientTimestamp;
        incrementAndCheck(context, venueData, callbacks);
      }

      @Override
      public void onError(int responseCode) {
        incrementAndCheck(context, venueData, callbacks);
      }
    }, venueData.basicAuthentication);


    /**
     * Fetching all movertypes images
     */
    for (int i = 0; i < venueData.pathTypes.length; i++) {
      PathType pathType = venueData.pathTypes[i];
      final int mapIndex = i;
      if (pathType.pathtypeUri == null) continue;

      int j = 0;
      while (j < pathType.pathtypeUri.length) {
        final Uri uri = pathType.pathtypeUri[j];
        if (Strings.hasDotSVG(uri.filePath)) {
          j = Integer.MAX_VALUE;
          venueData.counterTotalReq++;
          final String url;
          if (Strings.hasProtocol(uri.filePath)) {
            url = uri.filePath;
          } else {
            url = venueData.url + uri.filePath;
          }
          HttpClient.downloadUrl(url, new HttpClient.DownloadCallbacks() {
            @Override
            public void onSuccess(String response) {
              venueData.pathTypes[mapIndex].svgDOM = response;
              incrementAndCheck(context, venueData, callbacks);
            }

            @Override
            public void onError(int responseCode) {
              Log.e(TAG, "Error getting Mover type SVG, responseCode:" + responseCode);
              callbacks.onError();
            }
          }, venueData.basicAuthentication);

          continue;
        }
        j++;
      }
    }

/**
 * Fetching images for each amenity type
 */
    for (int i = 0; i < venueData.amenities.length; i++) {
      Amenity amenity = venueData.amenities[i];
      final String pathToSVG = amenity.bean.filePath;
      final int index = i;
      if (pathToSVG != null) {
        venueData.counterTotalReq++;
        final String url;
        if (Strings.hasProtocol(pathToSVG)) {
          url = pathToSVG;
        } else {
          url = venueData.url + pathToSVG;
        }
        HttpClient.downloadUrl(url, new HttpClient.DownloadCallbacks() {
          @Override
          public void onSuccess(String response) {
            venueData.amenities[index].bean.filePathSVG = response;
            incrementAndCheck(context, venueData, callbacks);
          }

          @Override
          public void onError(int responseCode) {
            Log.e(TAG, "Error fetching Amenity`s SVG , responseCode:" + responseCode);
            callbacks.onError();
          }
        }, venueData.basicAuthentication);

      }
    }

/**
 * Fetching images for each DestinationLabel
 */
    for (int i = 0; i < venueData.maps.length; i++) {
      DestinationLabel[] destinationLabels = venueData.maps[i].destinationLabels;
      final int indexMap = i;
      for (int j = 0; j < destinationLabels.length; j++) {
        DestinationLabel destinationLabel = destinationLabels[j];
        final int indexLbls = j;
        if (destinationLabel != null) {

//        String pathToSVG = destinationLabel.filePath;
//        if (pathToSVG!=null) {
//          if (pathToSVG != null) {
//            counterTotalReq++;
//            VolleySingleton.getInstance(context).getRequestQueue().add(BaseCalls.getStringRequest(pathToSVG, new Response.Listener<String>() {
//              @Override
//              public void onResponse(String response) {
//                maps[indexMap].destinationLabels[indexLbls].iconSVGDOM = response;
//                incrementAndCheck();
//              }
//            }, new Response.ErrorListener() {
//              @Override
//              public void onErrorResponse(VolleyError error) {
//                Log.i(TAG, "Error fetching Amenity`s SVG " + error.toString());
//                incrementAndCheck();
//              }
//            }, basicAuthentication));
//          }
//
//        }
//
          String pathToPNG = destinationLabel.iconImagePath;
//        if (pathToPNG != null) {
//          venueData.counterTotalReq++;
//          VolleySingleton.getInstance(context).getRequestQueue().add(BaseCalls.getImageRequest(venueData.url, destinationLabel.iconImagePath, new Response.Listener<Bitmap>() {
//            @Override
//            public void onResponse(Bitmap response) {
//              venueData.maps[indexMap].destinationLabels[indexLbls].iconBitmap = response;
//              incrementAndCheck(venueData, callbacks);
//            }
//          }, new Response.ErrorListener() {
//            @Override
//            public void onErrorResponse(VolleyError error) {
//              Log.i(TAG, "Error getting Destination Bitmap " + error.toString());
//              incrementAndCheck(venueData, callbacks);
//            }
//          }, venueData.basicAuthentication));
//        }
        }
      }
    }

    /**
     * Getting all the helper images of the destinations
     */
    // TODO: 15-09-10 Disabled due to memory problems with old devices
//  for (int i = 0; i < destinations.length; i++) {
//    final Destination destination = destinations[i];
//
//    final int finalI = i;
//    if (destination.helperImage != null || destination.helperImage != "") {
//      if (Strings.hasDotPNGrJPGrJPEG(destination.helperImage)) {
//        VolleySingleton.getInstance(context).getRequestQueue().add(NovomapV3Api.getImageRequestFullPath(destination.helperImage, new Response.Listener<Bitmap>() {
//          @Override
//          public void onResponse(Bitmap response) {
//            destinations[finalI].helperImageBitmap = response;
//          }
//        }, errorListener()));
//      }
//    }
//  }


//  /**
//   * Fetching waypoints for each amenity in order to find its location
//   */
//  for (int i = 0; i < amenities.length; i++) {
//    Component amenity = amenities[i];
//    final int index = i;
//    VolleySingleton.getInstance(context).getRequestQueue().add(NovomapV3Api.getWaypointsOfAmenity(locationID, amenity.componentId, new Response.Listener<String>() {
//      @Override
//      public void onResponse(String response) {
//        Gson gson = new Gson();
//        Type type = new TypeToken<Waypoint[]>() {
//        }.getType();
//        Waypoint[] waypoints = gson.populateFromJson(response, type);
//        Log.e(TAG, response);
////        amenities[index].filePathBitmap = response;
//      }
//    }, errorListener()));
//  }
///**
// * fetching all amenity locations
// */
//  setLegendLocationsData(new DOLegend[mapFull.length][]);
//  for (int i = 0; i < mapFull.length; i++) {
//    DOMap map = mapFull[i];
//    final int index = i;
//    VolleySingleton.getInstance(context).getRequestQueue().add(NovomapV2Api.getLegendLocations(String.valueOf(map.mapId), new Listener<String>() {
//
//      public void onResponse(String response) {
//        Gson gson = new Gson();
//        Type type = new TypeToken<DOLegend[]>() {
//        }.getType();
//        DOLegend[] legendLocationData = gson.populateFromJson(response, type);
////        Log.i(TAG, "getLegendLocations " + response);
//        getLegendLocationsData()[index] = legendLocationData;
//
//        // find bitmaps
//        for (int j = 0; j < legendLocationData.length; j++) {
//          DOLegend doLegend = legendLocationData[j];
//         int typeId = doLegend.typeId;
//          for (int k = 0; k < amenities.length; k++) {
//            DOComponent legendType = amenities[k];
//            if(legendType.componentTypeId == typeId){
//              doLegend.bitmap = legendType.filePathBitmap;
//            }
//          }
//        }
//      }
//    }()));
//  }
//
}

  private static void incrementAndCheck(Context context, VenueData venueData, Callbacks callbacks) {
    venueData.counterReq++;
//        Log.i(TAG, ">>> " + String.valueOf(counterReq));
    if (venueData.counterReq == venueData.counterTotalReq) {
      Log.d(TAG, "All requests responded ");
      String json = venueData.toJson();
      Log.d(TAG, "Saving data");
      boolean saveDataOnDisk = InternalStorage.saveFile(context, getFilename(venueData), json);
      Log.d(TAG, "VenueData Saved: " + saveDataOnDisk);
      // Inform callback
      if (saveDataOnDisk) {
        callbacks.onSuccess();
      } else {
        callbacks.onError();
      }
    }
  }

  private static String getFilename(VenueData venueData) {
    String pid = Integer.toString(venueData.projectID);
    return pid;
  }

  private interface Callbacks {
    void onSuccess();

    void onError();
  }

  public interface OnVenueDataServiceReadyCallback {
    void onVenueDataReady(String projectId);

    void onVenueDataError();
  }

  public static void setOnVenueDataServiceReadyCallback(OnVenueDataServiceReadyCallback _onVenueDataServiceReadyCallback) {
    onVenueDataServiceReadyCallback = _onVenueDataServiceReadyCallback;
  }

  private void runOnUiThread(final Runnable runnable) {
    if (Looper.myLooper() != Looper.getMainLooper()) {
      new android.os.Handler(Looper.getMainLooper()).post(runnable);
    } else {
      runnable.run();
    }
  }
}
