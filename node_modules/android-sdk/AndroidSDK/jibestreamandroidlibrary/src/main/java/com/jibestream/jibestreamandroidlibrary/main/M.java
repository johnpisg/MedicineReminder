package com.jibestream.jibestreamandroidlibrary.main;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Rect;
import android.graphics.RectF;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.os.Process;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;
import android.view.Choreographer;
import android.view.MotionEvent;
import android.view.SurfaceHolder;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.jibestream.jibestreamandroidlibrary.R;
import com.jibestream.jibestreamandroidlibrary.elements.Amenity;
import com.jibestream.jibestreamandroidlibrary.elements.Background;
import com.jibestream.jibestreamandroidlibrary.elements.Corridor;
import com.jibestream.jibestreamandroidlibrary.elements.CustomArtLayer1;
import com.jibestream.jibestreamandroidlibrary.elements.CustomArtLayer2;
import com.jibestream.jibestreamandroidlibrary.elements.CustomArtLayer3;
import com.jibestream.jibestreamandroidlibrary.elements.CustomArtLayer4;
import com.jibestream.jibestreamandroidlibrary.elements.CustomArtLayer5;
import com.jibestream.jibestreamandroidlibrary.elements.CustomArtLayer6;
import com.jibestream.jibestreamandroidlibrary.elements.Element;
import com.jibestream.jibestreamandroidlibrary.elements.ElementCustom;
import com.jibestream.jibestreamandroidlibrary.elements.ElementHUD;
import com.jibestream.jibestreamandroidlibrary.elements.ElementIcon;
import com.jibestream.jibestreamandroidlibrary.elements.ElementMap;
import com.jibestream.jibestreamandroidlibrary.elements.Elevator;
import com.jibestream.jibestreamandroidlibrary.elements.Escalator;
import com.jibestream.jibestreamandroidlibrary.elements.Kiosk;
import com.jibestream.jibestreamandroidlibrary.elements.MallBoundary;
import com.jibestream.jibestreamandroidlibrary.elements.Mover;
import com.jibestream.jibestreamandroidlibrary.elements.Obstacle;
import com.jibestream.jibestreamandroidlibrary.elements.ParkingLot;
import com.jibestream.jibestreamandroidlibrary.elements.Pin;
import com.jibestream.jibestreamandroidlibrary.elements.Restroom;
import com.jibestream.jibestreamandroidlibrary.elements.Route;
import com.jibestream.jibestreamandroidlibrary.elements.Stair;
import com.jibestream.jibestreamandroidlibrary.elements.StreetMajor;
import com.jibestream.jibestreamandroidlibrary.elements.StreetMinor;
import com.jibestream.jibestreamandroidlibrary.elements.StreetSmallAlley;
import com.jibestream.jibestreamandroidlibrary.elements.Unit;
import com.jibestream.jibestreamandroidlibrary.elements.UnitLabel;
import com.jibestream.jibestreamandroidlibrary.elements.UserLocation;
import com.jibestream.jibestreamandroidlibrary.elements.WayfindKiosk;
import com.jibestream.jibestreamandroidlibrary.elements.YouAreHere;
import com.jibestream.jibestreamandroidlibrary.http.BasicAuthentication;
import com.jibestream.jibestreamandroidlibrary.intentFilters.IntentFilterActiveness;
import com.jibestream.jibestreamandroidlibrary.intentFilters.IntentFilterEngine;
import com.jibestream.jibestreamandroidlibrary.intentFilters.IntentFilterTouch;
import com.jibestream.jibestreamandroidlibrary.intents.IntentActiveness;
import com.jibestream.jibestreamandroidlibrary.intents.IntentAmenities;
import com.jibestream.jibestreamandroidlibrary.intents.IntentEngine;
import com.jibestream.jibestreamandroidlibrary.intents.IntentMap;
import com.jibestream.jibestreamandroidlibrary.intents.IntentTouch;
import com.jibestream.jibestreamandroidlibrary.intents.IntentWayfind;
import com.jibestream.jibestreamandroidlibrary.intents.IntentWaypoint;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.ASGrid;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.ASNode;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.ASSearch;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.PathPerFloor;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Category;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Destination;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.DestinationLabel;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.DestinationProximity;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Device;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapFull;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapLabel;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.PathType;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.WaypointEntityLink;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Zone;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.MakeTextDirections;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.TDInstruction;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.TextDirectionOptions;
import com.jibestream.jibestreamandroidlibrary.shapes.IShape;
import com.jibestream.jibestreamandroidlibrary.shapes.IconShape;
import com.jibestream.jibestreamandroidlibrary.shapes.JPath;
import com.jibestream.jibestreamandroidlibrary.shapes.Star;
import com.jibestream.jibestreamandroidlibrary.styles.CssStyles;
import com.jibestream.jibestreamandroidlibrary.styles.IconStyles;
import com.jibestream.jibestreamandroidlibrary.styles.RenderStyle;
import com.jibestream.jibestreamandroidlibrary.styles.configDOs.ConfigDO;
import com.jibestream.jibestreamandroidlibrary.styles.configDOs.ConfigStyleDO;
import com.jibestream.jibestreamandroidlibrary.styles.configDOs.ExportStyles;
import com.jibestream.jibestreamandroidlibrary.svg.SVGParser;
import com.jibestream.jibestreamandroidlibrary.utils.ColorsMaterialDesign;
import com.jibestream.jibestreamandroidlibrary.utils.InternalStorage;

import org.xmlpull.v1.XmlPullParserException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Model class that holds all shared data and
 * application state.
 * Created by emmanuel on 15-05-29.
 */
public class M implements Choreographer.FrameCallback {
  private OnMapReadyCallback onMapReadyCallback;

  //<editor-fold desc="Private Static CONSTANTS">
  private static final String TAG = "M";
  private static final String SDK_VERSION = "3.2.2";
  private static final int ON_CREATE = 0;
  private static final int ON_START = 1;
  private static final int ON_RESUME = 2;
  private static final int ON_PAUSE = 3;
  private static final int ON_STOP = 4;
  private static final int ON_DESTROY = 5;
  private static final int UPDATE = 6;
  private static final int HIT_TESTS = 7;
  private static final int RENDER = 8;
  private static final int RENDER_TO_CANVAS = 9;
  private static final int VSYNC_ADD = 100;
  private static final int VSYNC_REM = 101;
  private static final int SET_ENGINE_VIEW = 200;
  private static final int SET_ENGINE_STATE = 201;
  private static final int ADD_TO_MAP = 202;
  private static final int REMOVE_FROM__MAP = 203;
  private static final int SET_CURRENT_MAP = 205;
  private static final int SET_CURRENT_MAP_INDEX = 206;
  private static final int SET_ACTIVENESS_ON_TYPE = 207;
  private static final int SET_AMENITIES_VISIBILITY = 208;
  private static final int GET_WAYPOINT = 300;
  private static final int GET_WAYPOINTS_OF_DESTINATION = 301;
  private static final int GET_WAYPOINTS_OF_AMENITY = 302;
  private static final int FIND_CLOSEST_WAYPOINT_XY = 303;
  private static final int GET_CLOSEST_WAYPOINT_OF_AMENITY_TYPE_ID = 304;
  private static final int WAYFIND_TO_CLOSEST_AMENITY = 305;
  private static final int GET_WAYPOINTS_WITH_ZONE = 306;
  private static final int GET_DESTINATION_BY_ID = 400;
  private static final int GET_DESTINATIONS_OF_PROXIMITYS = 401;
  private static final int GET_DESTINATIONS_BY_QUERY = 402;
  private static final int GET_DESTINATIONS_OF_WAYPOINT = 403;
  private static final int GET_DESTINATIONS_BY_CLIENT_ID = 404;
  private static final int GET_DESTINATIONS_BY_CATEGORY_ID = 405;
  private static final int GET_DESTINATIONS_BY_ZONE = 406;
  private static final int GET_AMENITIES_BY_ID = 500;
  private static final int GET_AMENITIES_OF_WAYPOINT = 501;
  private static final int GET_ZONE_BY_ID = 600;
  private static final int GET_ELEMENT_BY_ID = 700;
  private static final int SET_SELECTION_STATE_BY_TYPE = 701;
  private static final int GET_ELEMENTS_BY_TYPE = 702;
  private static final int GET_ELEMENTS_OF_DESTINATION = 703;
  private static final int GET_ELEMENTS_BY_KEY_VALUE = 704;
//</editor-fold>

//<editor-fold desc="Public Statics">
  /**
   * The unique ID for this instance.
   */
  public final int mID = GUID.get();
  /**
   * Collision update interval
   * by default is set to zero, if collision detection is desirable implementorss need to set
   * a desired interval. A value of 60 will force collision detection to run every 60 frmaes.
   * Usually a value of 35 is sufficient.
   */
  public static volatile int COLLISION_UPDATES_INTERVAL = 0;
  /**
   * The amount of overflow in pixels for the buffered rendered image.
   */
  public static volatile int OVERFLOW_PIXELS_AMOUNT = 300;
//</editor-fold>

  //<editor-fold desc="Private fields Main">
  private volatile String engineState;
  private final ArrayList<Element> elementList = new ArrayList<>();
  private Element[] elementsForCurrentLevelRenderMapSpace;
  private Element[] elementsForCurrentLevelRenderViewSpace;
  private Element[] elementsForCurrentLevelUpdate;
  private final Object lockElementList = new Object();
  private final Object lockElementsForCurrentLevelUpdate = new Object();
  private final Object lockElementsForCurrentLevelRender = new Object();
  private boolean[] amenitiesVisibility;
  private volatile String configJsonInputString = null;
  //
  private volatile EngineView engineView;
  //
  private final Paint paintHit = new Paint();
  private final Paint paintDebug = new Paint();
  //
  private long timeStampInMillis;
  private int fps;
  private long timeTotal;
  private long prevTime;
  private long framesTotal;
  private long timeElapsed;
  private long milliAccum;
  private int framesTotalInSecond;
  ///////
  private final HandlerThread threadRender = new HandlerThread("RenderThread", Process.THREAD_PRIORITY_URGENT_DISPLAY);
  private final HandlerThread threadUpdate = new HandlerThread("UpdateThread", Process.THREAD_PRIORITY_URGENT_DISPLAY);
  private Handler handlerUpdate;
  private Handler handlerRender;
  private Context context;
  private volatile String lastFilenameLoaded = "";
  //
  private volatile boolean isRendering = false;
  private final Object lockBitmapCache = new Object();
  private volatile Bitmap bitmapCache;
  private Bitmap bitmapCacheA;
  private Bitmap bitmapCacheB;
  private final Canvas canvasCache = new Canvas();
  private Matrix rendCameraMatrix = new Matrix();
  private Matrix prevCameraMatrix = new Matrix();
  private Matrix currentCameraMatrix = new Matrix();
//</editor-fold>

  //<editor-fold desc="Private Fields activeness">
  private volatile boolean activeHUD = true;
  private volatile boolean activeLabels = true;
  private volatile boolean activeAmenities = true;
  private volatile boolean activeMapLabels = true;
  private volatile boolean activeDestinationLabels = true;
  private volatile boolean activeWayfindKiosks = true;
  private volatile boolean activeObstacles = true;
  private volatile boolean activeEscalators = true;
  private volatile boolean activeElevators = true;
  private volatile boolean activeStairs = true;
  private volatile boolean activeUnits = true;
  private volatile boolean activeParkingLots = true;
  private volatile boolean activeStreetsMajor = true;
  private volatile boolean activeStreetsMinor = true;
  private volatile boolean activeStreetsSmallAlleys = true;
  private volatile boolean activeMallBoundary = true;
  private volatile boolean activeBackground = true;
  private volatile boolean activeRestrooms = true;
  private volatile boolean activeCorridor = true;
  private volatile boolean activeKiosk = true;
  private volatile boolean activeArtLayer1 = true;
  private volatile boolean activeArtLayer2 = true;
  private volatile boolean activeArtLayer3 = true;
  private volatile boolean activeArtLayer4 = true;
  private volatile boolean activeArtLayer5 = true;
  private volatile boolean activeArtLayer6 = true;
  private volatile boolean activeCustomElement = true;
//</editor-fold>

  //<editor-fold desc="Private Fields Text Directions">
  private ASGrid asGrid;
  private ASSearch asSearch;
  //
  private Waypoint fromWaypoint;
  private Waypoint toWaypoint;
  private int accessLevel = 100;
  //
  private final Object lockPathPerFloor = new Object();
  private PathPerFloor[] pathPerFloors;
  private PathPerFloor pathForCurrentFloor;
  private Path androidPathForCurrentFloor;
//</editor-fold>

  //<editor-fold desc="Private Fields Map trackers">
  private int currentMapIndex;
  private MapFull defaultMap;
  private MapFull currentMap;
//</editor-fold>

//<editor-fold desc="Public fields ">
  /**
   * The {@link CssStyles} of this instance.
   * The initial styles found on the svg map will be stored
   * Users can add styles to this object to reference across components.
   */
  public CssStyles cssStyles;
  /**
   * The {@link IconStyles} of this instance.
   * modified by the SDK when the user interacts with the  {@link EngineView}.
   * Users can add styles to this object to reference across components.
   */
  public IconStyles iconStyles;
  /**
   * The {@link BitmapLib} of this instance.
   * Users can add bitmaps to this object to reference across components.
   */
  public BitmapLib bitmapLib;
  /**
   * The {@link IconShapeLib} of this instance.
   */
  public IconShapeLib iconShapeLib;
  /**
   * The {@link ClassLib} of this instance.
   */
  public ClassLib classLib;
  /**
   * The viewboxes found on each svg map accumulated in an array.
   * This is the viewport box of each SVG map.
   */
  public RectF[] floorViewboxes;
  /**
   * The default regions for each SVG map calculated from the combination of all the types:
   * {@link Unit}s and {@link ParkingLot}s.
   */
  public RectF[] defaultFramings;
///////
  /**
   * The {@link Camera} of this instance.
   * Besides setting values manually the virtual camera is also
   * modified by the SDK when the user interacts with the  {@link EngineView}.
   */
  public final Camera camera;
  /**
   * The {@link VenueData} of this instance.
   * The raw data stored on the UXM for the loaded venue, implementors can find here all the
   * information created on the backend and traverse the structures in order to obtain data that's
   * not exposed from the SDK.
   */
  public VenueData venueData;
  /**
   * The maximum number of megabytes the heap can expand to. A field that the SDK publicly exposes
   * from the following code:
   * maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
   */
  public final int maxMemory;
//</editor-fold>

//<editor-fold desc="Public Reference Fields, Elements">
  /**
   * The {@link Route} instance the SDK creates and uses in order to assist and remove the
   * necessity for implementors to create a custom one.
   */
  public Route route;
  /**
   * The {@link YouAreHere} instance the SDK creates and uses in order to assist and remove the
   * necessity for implementors to create a custom one.
   */
  public YouAreHere youAreHere;
  /**
   * The {@link Pin} instance the SDK creates and uses in order to assist and remove the
   * necessity for implementors to create a custom one.
   */
  public Pin pin;
  /**
   * The {@link com.jibestream.jibestreamandroidlibrary.elements.MoverHead} instance the SDK creates and uses in order to assist and remove the
   * necessity for implementors to create a custom one.
   */
  public Mover moverA;
  /**
   * The {@link com.jibestream.jibestreamandroidlibrary.elements.MoverTail} instance the SDK creates and uses in order to assist and remove the
   * necessity for implementors to create a custom one.
   */
  public Mover moverB;
  /**
   * The {@link UserLocation} instance the SDK creates and uses in order to assist and remove the
   * necessity for implementors to create a custom one.
   */
  public UserLocation userLocation;
//</editor-fold>

  //<editor-fold desc="BROADCASTRECEIVER-EngineView">
  public BroadcastReceiver broadcastRecieverEngineView = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
      String action = intent.getAction();
      if (engineView.id != intent.getIntExtra("id", -1)) return;
      switch (action) {
        case EngineView.SURFACE_CREATED:

          break;
        case EngineView.SURFACE_DESTROYED:

          break;
        case EngineView.SURFACE_CHANGED:
          int width = intent.getIntExtra("width", 0);
          int height = intent.getIntExtra("height", 0);
          Log.i(TAG, "w: " + width + " h: " + height);
          camera.setViewport(width, height);
          setOffscreenBitmap(width, height);
          break;
        case EngineView.ON_TOUCH_EVENT:
          boolean isUserInteracting = intent.getBooleanExtra("IsUserInteracting", false);
          camera.setIsUserInteracting(isUserInteracting);
          break;
        case EngineView.ON_ROTATION:
          float rotation = intent.getFloatExtra("rotation", 0);
          float x = intent.getFloatExtra("x", 0);
          float y = intent.getFloatExtra("y", 0);
          camera.addRoll(-rotation, x, y);
          break;
        case EngineView.ON_SCALE:
          float scale = intent.getFloatExtra("scale", 0);
          float focusX = intent.getFloatExtra("focusX", 0);
          float focusY = intent.getFloatExtra("focusY", 0);
          camera.addS(scale, focusX, focusY);
          break;
        case EngineView.ON_SCROLL:
          float distanceX = intent.getFloatExtra("distanceX", 0);
          float distanceY = intent.getFloatExtra("distanceY", 0);
          float cameraScale = camera.getScale();
          camera.addTranslateGlbl(distanceX * cameraScale, distanceY * cameraScale);
          break;
        case EngineView.ON_FLING:
          float velocityX = intent.getFloatExtra("velocityX", 0);
          float velocityY = intent.getFloatExtra("velocityY", 0);
          camera.fling(velocityX, velocityY);
          break;
        case EngineView.ON_DOWN:
          camera.forceFinish();
          break;
        case EngineView.ON_SINGLE_TAP_UP:
          hitTests(EngineView.ON_SINGLE_TAP_UP, (MotionEvent) intent.getParcelableExtra("motionEvent"));
          break;
        case EngineView.ON_SINGLE_TAP_CONFIRMED:
          hitTests(EngineView.ON_SINGLE_TAP_CONFIRMED, (MotionEvent) intent.getParcelableExtra("motionEvent"));
          break;
        case EngineView.ON_DOUBLE_TAP:
          hitTests(EngineView.ON_DOUBLE_TAP, (MotionEvent) intent.getParcelableExtra("motionEvent"));
          break;
        case EngineView.ON_LONGPRESS:
          hitTests(EngineView.ON_LONGPRESS, (MotionEvent) intent.getParcelableExtra("motionEvent"));
          break;
      }
    }
  };
//</editor-fold>

//<editor-fold desc="INTERFACES Callbacks">

  /**
   * Interface for asynchronous callbacks when rendering a snapshot.
   */
  public interface RenderCallback {
    void onRender();
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link Bitmap}.
   */
  public interface CallbackRenderToBitmap {
    void callback(Bitmap bitmap);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link Element}.
   */
  public interface CallbackElement {
    void callback(Element element);
  }

  /**
   * Interface for asynchronous callbacks when the return value is an array of {@link Element}.
   */
  public interface CallbackElements {
    void callback(Element[] elements);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link Unit}.
   */
  public interface CallbackUnit {
    void callback(Unit unit);
  }

  /**
   * Interface for asynchronous callbacks when the return value is an array of {@link Unit}.
   */
  public interface CallbackUnits {
    void callback(Unit[] units);
  }

  /**
   * Interface for asynchronous callbacks when the return value is an array of {@link PathPerFloor}.
   */
  public interface CallbackPathPerFloors {
    void callback(PathPerFloor[] pathPerFloors);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link MapFull}.
   */
  public interface CallbackMapFull {
    void callback(MapFull mapFull);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link Destination}.
   */
  public interface CallbackDestination {
    void callback(Destination destination);
  }


  /**
   * Interface for asynchronous callbacks when the return value is an array of {@link Destination}.
   */
  public interface CallbackDestinations {
    void callback(Destination[] destinations);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link Amenity}.
   */
  public interface CallbackAmenity {
    void callback(com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity amenity);
  }

  /**
   * Interface for asynchronous callbacks when the return value is an array of {@link com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity}.
   */
  public interface CallbackAmenities {
    void callback(com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[] amenities);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link Waypoint}.
   */
  public interface CallbackWaypoint {
    void callback(Waypoint waypoint);
  }

  /**
   * Interface for asynchronous callbacks when the return value is an array of {@link Waypoint}.
   */
  public interface CallbackWaypoints {
    void callback(Waypoint[] waypoints);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link RectF}.
   */
  public interface CallbackRectF {
    void callback(RectF rectF);
  }

  /**
   * Interface for asynchronous callbacks when the return value is a {@link Zone}.
   */
  public interface CallbackZone {
    void callback(Zone zone);
  }

  /**
   * Interface for asynchronous callbacks when initializing the loading data for the map
   */
  public interface OnMapReadyCallback {
    void onMapReady();
    void onMapResume();
    void onMapPause();
    void onMapStop();
    void onMapDestroy();
  }

  /**
   * Set the map ready callback in your activity where EngineView is also initialized
   *
   * @param onMapReadyCallback
   */
  public void setOnMapReadyCallback(OnMapReadyCallback onMapReadyCallback) {
    this.onMapReadyCallback = onMapReadyCallback;
  }
//</editor-fold>

  /**
   * Constructor method, creates a new instance of {@link M}
   *
   * @param context , must not be null.
   */
  public M(Context context) {
    this.context = context;
    //
    engineState = IntentFilterEngine.NONE;
    //
    //// TODO: 2016-01-04 ..... fontLib
    cssStyles = new CssStyles();
    iconStyles = new IconStyles();
    iconShapeLib = new IconShapeLib();
    classLib = new ClassLib();
    bitmapLib = new BitmapLib();
    bitmapLib.jibestream = BitmapFactory.decodeResource(context.getApplicationContext().getResources(), R.drawable.js);
    bitmapLib.youAreHere = BitmapFactory.decodeResource(context.getApplicationContext().getResources(), R.drawable.you_are_here);
    bitmapLib.userLocationIcon = BitmapFactory.decodeResource(context.getApplicationContext().getResources(), R.drawable.userlocation);
    bitmapLib.pin = BitmapFactory.decodeResource(context.getApplicationContext().getResources(), R.drawable.destination);
    //
    paintHit.setStyle(Paint.Style.FILL);
    //
    threadUpdate.start();
    threadRender.start();
    handlerUpdate = new Handler(threadUpdate.getLooper(), callbackUpdate);
    handlerRender = new Handler(threadRender.getLooper(), callbackRender);
    camera = new Camera(context, threadUpdate.getLooper());
    //
    maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);

    paintDebug.setStyle(Paint.Style.STROKE);
    paintDebug.setColor(ColorsMaterialDesign.AMBER5);
    paintDebug.setStrokeWidth(3);
    paintDebug.setAntiAlias(true);
//  paintDebug.setAlpha(20);
  }

//<editor-fold desc="++++++++++++++++++++++++++++++++++++++         M State fns">

  /**
   * Bootstraps a M instance with the relative information provided by the file generated from the
   * {@link VenueDataService#getData(Context, String, int, BasicAuthentication)} method.
   * This is the very first method to invoke after creating a new instance of this,
   * and should be called once for a specific venue.
   * IMPORTANT the {@link M#onResume()} method has to be triggered once the {@link IntentFilterEngine#COMPLETE} has been dispatched.
   * On success the SDK will dispatch an event {@link IntentFilterEngine#COMPLETE}.
   * On failure the SDK will dispatch an event {@link IntentFilterEngine#ERROR}.
   *
   * @param fileName The filename created from the {@link VenueDataService#getData(Context, String, int, BasicAuthentication)} method.
   * @param config   the XML string of a configuration file, may be null
   */
  public void start(String fileName, int config) {
    Message message = handlerUpdate.obtainMessage(ON_START, config, 0, fileName);
    handlerUpdate.sendMessage(message);
  }

  private void _start(String fileName, int config) {
    // are we loading the previous venue
    final boolean isLastVenue = lastFilenameLoaded.equalsIgnoreCase(fileName);
    if (!isLastVenue) {
      // Do we need to stop()?
      if (engineState.equalsIgnoreCase(IntentFilterEngine.PAUSE) ||
              engineState.equalsIgnoreCase(IntentFilterEngine.COMPLETE)) {
        _onStop();
      }
      this.lastFilenameLoaded = fileName;
      setEngineState(IntentFilterEngine.START);

      InputStream inputStream = null;
      if (config > 0) {
        inputStream = context.getResources().openRawResource(config);
      }
      String json;
      try {
        json = InternalStorage.readFile(context, fileName);
        venueData = VenueData.BuildFromJson(json);
        start(venueData, inputStream);
      } catch (IOException e) {
        e.printStackTrace();
      }
    } else {
//    setEngineComplete();
      _onResume();
    }
  }

  private void start(VenueData venueData, InputStream configJsonInputStream) {
    String json = null;
    if (configJsonInputStream != null) {
      StringBuilder text = new StringBuilder();
      try {
        BufferedReader br = new BufferedReader(new InputStreamReader(configJsonInputStream));
        String line;
        while ((line = br.readLine()) != null) {
          text.append(line);
          text.append('\n');
        }
        br.close();
        json = text.toString();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    start(venueData, json);

  }

  private void start(VenueData venueData, String configJsonInputString) {
    this.venueData = venueData;
    this.configJsonInputString = configJsonInputString;
    //
    boostrap(new Runnable() {
      @Override
      public void run() {
        setEngineComplete();
      }
    });
  }

  private void setEngineComplete() {
    if (engineView != null) {
      camera.zoomTo(defaultFramings[currentMapIndex]);
    }
    setEngineState(IntentFilterEngine.COMPLETE);
    if (onMapReadyCallback != null) {
      runOnUiThread(new Runnable() {
        @Override
        public void run() {
          onMapReadyCallback.onMapReady();
        }
      });
    }
  }

  /**
   * Method that resumes the operation of the engine. This method has to be called
   * after initial bootstrap (the event {@link IntentFilterEngine#COMPLETE} has been fired)
   * and every time after a {@link M#onPause()} has been invoked in order to resume.
   * IMPORTANT on failure invoking this method after the above cases
   * the engine will not operate properly.
   * On success the SDK will dispatch an event {@link IntentFilterEngine#RESUME}.
   */
  public void onResume() {
    Message message = handlerUpdate.obtainMessage(ON_RESUME);
    handlerUpdate.sendMessage(message);
  }

  private void _onResume() {
    if (!engineState.equalsIgnoreCase(IntentFilterEngine.RESUME)) {
      _update();//run once
      //
      LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.SURFACE_CREATED));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.SURFACE_DESTROYED));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.SURFACE_CHANGED));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_TOUCH_EVENT));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_ROTATION));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_SCALE));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_DOWN));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_SINGLE_TAP_UP));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_SINGLE_TAP_CONFIRMED));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_DOUBLE_TAP));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_SCROLL));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_LONGPRESS));
      localBroadcastManager.registerReceiver(broadcastRecieverEngineView, new IntentFilter(EngineView.ON_FLING));
      //
      setEngineState(IntentFilterEngine.RESUME);
      if (onMapReadyCallback != null) {
        runOnUiThread(new Runnable() {
          @Override
          public void run() {
            onMapReadyCallback.onMapResume();
          }
        });
      }
    }
    vsynchAdd();
  }

  /**
   * Complimentary method to {@link M#onResume()} causes the engine to pause all operations.
   * Implementors will invoke this method when there is no need to have the engine running.
   * Usually when no rendering occurs, as when no {@link EngineView} is visible or there is no
   * camera manipulation or capturing snapshots.
   */
  public void onPause() {
    Message message = handlerUpdate.obtainMessage(ON_PAUSE);
    handlerUpdate.sendMessage(message);
  }

  private void _onPause() {
    vsynchRem();
    LocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastRecieverEngineView);
    setEngineState(IntentFilterEngine.PAUSE);
    if (onMapReadyCallback != null) {
      runOnUiThread(new Runnable() {
        @Override
        public void run() {
          onMapReadyCallback.onMapPause();
        }
      });
    }
  }

  /**
   * Reset this instance by setting parameters to default values.
   * Implementors may use this to reset states for any previously loaded venue in order to load a new one.
   * On success the SDK will dispatch an event {@link IntentFilterEngine#STOP}.
   */
  public void onStop() {
    Message message = handlerUpdate.obtainMessage(ON_STOP);
    handlerUpdate.sendMessage(message);
  }

  private void _onStop() {
    vsynchRem();
    setEngineState(IntentFilterEngine.STOP);
    if (onMapReadyCallback != null) {
      runOnUiThread(new Runnable() {
        @Override
        public void run() {
          onMapReadyCallback.onMapStop();
        }
      });
    }
    //
    destroyLoop();
    //
    // TODO: 2016-03-02 remove only jibes
    handlerUpdate.removeCallbacksAndMessages(null);
    handlerRender.removeCallbacksAndMessages(null);
    //

    synchronized (lockElementList) {
      elementList.clear();
    }
    synchronized (lockElementsForCurrentLevelUpdate) {
      elementsForCurrentLevelUpdate = null;
    }
    synchronized (lockElementsForCurrentLevelRender) {
      elementsForCurrentLevelRenderMapSpace = null;
      elementsForCurrentLevelRenderViewSpace = null;
    }

    configJsonInputString = null;
//////// Wayfind
    asGrid = null;
    asSearch = null;
    //
    fromWaypoint = null;
    toWaypoint = null;
    accessLevel = 100;
    //
    synchronized (lockPathPerFloor) {
      pathPerFloors = null;
      pathForCurrentFloor = null;
      androidPathForCurrentFloor = null;
    }
///////
    currentMapIndex = 0;
    defaultMap = null;
    currentMap = null;
/////////////    VISIBILITY    /////////////////
    amenitiesVisibility = null;
/////////////    ACTIVENESS    /////////////////
    activeHUD = true;
    activeLabels = true;
    activeAmenities = true;
    activeMapLabels = true;
    activeDestinationLabels = true;
    activeWayfindKiosks = true;
    activeObstacles = true;
    activeEscalators = true;
    activeElevators = true;
    activeStairs = true;
    activeUnits = true;
    activeParkingLots = true;
    activeStreetsMajor = true;
    activeStreetsMinor = true;
    activeStreetsSmallAlleys = true;
    activeMallBoundary = true;
    activeBackground = true;
    activeRestrooms = true;
    activeCorridor = true;
    activeKiosk = true;
    activeArtLayer1 = true;
    activeArtLayer2 = true;
    activeArtLayer3 = true;
    activeArtLayer4 = true;
    activeArtLayer5 = true;
    activeArtLayer6 = true;
    activeCustomElement = true;
///////
    venueData = null;
///////
    engineView = null;
///////
    camera.init();
///////
    fps = 0;
    timeTotal = 0;
    prevTime = 0;
    framesTotal = 0;
    milliAccum = 0;
    framesTotalInSecond = 0;
    //
//  bitmapLib.kill();
  }

  /**
   * Completely destroy this instance.
   * On success the SDK will dispatch an event {@link IntentFilterEngine#DESTROY}
   * followed by a {@link IntentFilterEngine#NONE}.
   */
  public void onDestroy() {
    Message message = handlerUpdate.obtainMessage(ON_DESTROY);
    handlerUpdate.sendMessage(message);
  }

  private void _onDestroy() {
    vsynchRem();
    setEngineState(IntentFilterEngine.DESTROY);
    if (onMapReadyCallback != null) {
      runOnUiThread(new Runnable() {
        @Override
        public void run() {
          onMapReadyCallback.onMapDestroy();
        }
      });
    }
    //
    destroyLoop();
    // TODO: 2016-03-02 remove only jibes
    handlerUpdate.removeCallbacksAndMessages(null);
    handlerRender.removeCallbacksAndMessages(null);
    setEngineState(IntentFilterEngine.NONE);
//  bitmapLib.kill();
  }

  /**
   * Set the {@link EngineView}, the SDK`s required view where rendering will happen.
   * Implementors must invoke this method every time a new layout has been inflated.
   *
   * @param engineView
   */
  public void setEngineView(EngineView engineView) {
    Message message = handlerUpdate.obtainMessage(SET_ENGINE_VIEW, engineView);
    handlerUpdate.sendMessage(message);
  }

  private void _setEngineView(EngineView engineView) {
    this.engineView = engineView;
    final int width = engineView.width();
    final int height = engineView.height();
    if (width == 0 || height == 0) {
      setEngineView(engineView);
      return;
    }
    camera.setViewport(width, height);
    setOffscreenBitmap(width, height);
    if (engineState.equalsIgnoreCase(IntentFilterEngine.COMPLETE) || engineState.equalsIgnoreCase(IntentFilterEngine.RESUME)) {
      camera.zoomTo(defaultFramings[currentMapIndex]);
    }
  }
//</editor-fold>

  //<editor-fold desc="<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CALLBACK UPDATE">
  private Handler.Callback callbackUpdate = new Handler.Callback() {
    @Override
    public boolean handleMessage(Message msg) {

      switch (msg.what) {
        case ON_START:
          _start((String) msg.obj, msg.arg1);
          break;
        case ON_PAUSE:
          _onPause();
          break;
        case ON_RESUME:
          _onResume();
          break;
        case ON_STOP:
          _onStop();
          break;
        case ON_DESTROY:
          _onDestroy();
          break;
        case SET_ENGINE_VIEW:
          _setEngineView((EngineView) msg.obj);
          break;
        case UPDATE:
          _update();
          break;
        case RENDER:
//        _renderLoopMap(msg);
          break;
        case RENDER_TO_CANVAS:
          _renderToCanvas(msg);
          break;
        case HIT_TESTS:
          _hitTests(msg);
          break;
        case SET_ENGINE_STATE:
          _setEngineState((String) msg.obj, msg.arg1);
          break;
        case ADD_TO_MAP:
          _addToMap((Element) msg.obj);
          break;
        case REMOVE_FROM__MAP:
          _removeFromMap((Element) msg.obj);
          break;
        case SET_CURRENT_MAP:
          MapFull mapFull = (MapFull) msg.obj;
          _setCurrentMap(mapFull);
          break;
        case SET_CURRENT_MAP_INDEX:
          _setCurrentMapIndex(msg.arg1);
          break;
        case SET_ACTIVENESS_ON_TYPE:
          _setActivnessOnType(msg);
          break;
        case SET_AMENITIES_VISIBILITY:
          _setAmenityVisibility(msg.arg1, (msg.arg2 > 0));
          break;
        // Waypoints
        case GET_WAYPOINT:
          getWaypointWithID(msg.arg1, (CallbackWaypoint) msg.obj);
          break;
        case GET_WAYPOINTS_OF_DESTINATION:
          getWaypointsOfDestination(msg);
          break;
        case GET_WAYPOINTS_OF_AMENITY:
          getWaypointsOfAmenity(msg);
          break;
        case FIND_CLOSEST_WAYPOINT_XY:
          findClosestWaypoint(msg);
          break;
        case GET_CLOSEST_WAYPOINT_OF_AMENITY_TYPE_ID:
          getClosestWaypointOfAmenityTypeID(msg);
          break;
        case WAYFIND_TO_CLOSEST_AMENITY:
          wayfindToClosestAmenity(msg);
          break;
        case GET_WAYPOINTS_WITH_ZONE:
          getWaypointsWithZone(msg);
          break;
        //Destinations
        case GET_DESTINATION_BY_ID:
          getDestinationByID(msg);
          break;
        case GET_DESTINATIONS_OF_PROXIMITYS:
          getDestinationsOfProximities(msg);
          break;
        case GET_DESTINATIONS_BY_QUERY:
          getDestinationsByQuery(msg);
          break;
        case GET_DESTINATIONS_OF_WAYPOINT:
          getDestinationsOfWaypoint(msg);
          break;
        case GET_DESTINATIONS_BY_CLIENT_ID:
          getDestinationsByClientId(msg);
          break;
        case GET_DESTINATIONS_BY_CATEGORY_ID:
          getDestinationsByCategoryId(msg);
          break;
        case GET_DESTINATIONS_BY_ZONE:
          getDestinationsByZone(msg);
          break;
        //AMENITIES
        case GET_AMENITIES_BY_ID:
          getAmenityByID(msg);
          break;
        case GET_AMENITIES_OF_WAYPOINT:
          getAmenitiesOfWaypoint(msg);
          break;
        //ZONE
        case GET_ZONE_BY_ID:
          getZoneByID(msg);
          break;
        //ELEMENT
        case GET_ELEMENT_BY_ID:
          getElementByID(msg);
          break;
        case SET_SELECTION_STATE_BY_TYPE:
          setSelectionStateByType(msg);
          break;
        case GET_ELEMENTS_BY_TYPE:
          getElementsByType(msg);
          break;
        case GET_ELEMENTS_OF_DESTINATION:
          getElementsOfDestination(msg);
          break;
        case GET_ELEMENTS_BY_KEY_VALUE:
          getElementsByKeyValue(msg);
          break;
        default:
          return false;
      }
      return true;
    }
  };
//</editor-fold>

  //<editor-fold desc="<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CALLBACKS RENDERING">
  private Handler.Callback callbackRender = new Handler.Callback() {
    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case RENDER:
          _render(msg);
          break;
      }
      return false;
    }
  };

//</editor-fold>

//<editor-fold desc="--------------------------------------          Updates Renders">

  private void vsynchAdd() {
    Choreographer.getInstance().postFrameCallback(M.this);
  }

  private void vsynchRem() {
    Choreographer.getInstance().removeFrameCallback(M.this);
  }

  private int updateAccumulator;

  @Override
  public void doFrame(long frameTimeNanos) {
//  final String name = Thread.currentThread().getName();
//  Log.i(TAG,name);

    //<editor-fold desc="checks">
    if (!(engineState.equalsIgnoreCase(IntentFilterEngine.COMPLETE) ||
            engineState.equalsIgnoreCase(IntentFilterEngine.RESUME))) {
      vsynchAdd();
      return;
    }
    if (engineView == null || engineView.getHolder().isCreating()) {
      vsynchAdd();
      return;
    }
    if (camera.getViewport().isEmpty()) {
      vsynchAdd();
      return;
    }
    if (System.nanoTime() - frameTimeNanos > 2000000) {
      vsynchAdd();
      return;
    }
    //</editor-fold>
    updateAccumulator++;
    renderOffset();
    if (isRendering) {
    } else {
//    if (updateAccumulator % 5 == 0) {
      handlerRender.removeMessages(RENDER);
      render();
//    }
//    _update();
    }
    vsynchAdd();
  }

  private void renderOffset() {
    if (engineView == null) return;
    final SurfaceHolder surfaceHolder = engineView.getHolder();
    if (surfaceHolder == null) return;
    if (surfaceHolder.isCreating()) return;
    if (!surfaceHolder.getSurface().isValid()) return;
    //
    if (bitmapCache == null) return;
    Canvas canvas = null;
    try {
      canvas = surfaceHolder.lockCanvas();
      if (canvas == null) return;
      canvas.drawColor(cssStyles.getBackground().paintFill.getColor());
      synchronized (lockBitmapCache) {
        Matrix delta = new Matrix();
        delta.postTranslate(-OVERFLOW_PIXELS_AMOUNT, -OVERFLOW_PIXELS_AMOUNT);
        rendCameraMatrix.invert(delta);
        delta.postConcat(camera.getMatrix());
        canvas.concat(delta);
        canvas.drawBitmap(bitmapCache, 0, 0, paintDebug);
      }
      int size = elementsForCurrentLevelRenderViewSpace.length;
      Element element;
      for (int i = 0; i < size; i++) {
        element = elementsForCurrentLevelRenderViewSpace[i];
        synchronized (element) {
//          if (!element.willRender()) continue;
          if (!element.isActive()) continue;
          if (!element.isVisible()) continue;
          canvas.setMatrix(element.getTransform().getGlobalMatrix());
          element.onRender(canvas, null);
          //
          element.setDirtyShape(false);
          element.setDirtyStyle(false);
          element.setDirtyTransform(false);
        }
      }
    } finally {
      if (canvas != null) {
        surfaceHolder.unlockCanvasAndPost(canvas);
      }
    }
  }

// TODO: 2016-05-31 do i need this to be public

  /**
   * Triggers the following callbacks on each element in the display list.
   * {@link Element#onUpdate(M, long, long, int, Camera)} and
   * {@link Element#onPreRender(M, long, long, int, Camera)}
   * Implementors no need to call this
   */
  public void update() {
    Message message = handlerUpdate.obtainMessage(UPDATE);
    handlerUpdate.sendMessage(message);
  }

  private void _update() {
    if (!(engineState.equalsIgnoreCase(IntentFilterEngine.COMPLETE) || engineState.equalsIgnoreCase(IntentFilterEngine.RESUME))) {
      update();
      return;
    }

    if (Element.flag_LevelChange.get()) {
      Element.flag_LevelChange.set(false);
      _setElementsOfCurrentLevel();
    }

    //<editor-fold desc="Collisions Tests  //////////////////////////////////">
    boolean updateColl = COLLISION_UPDATES_INTERVAL != 0 && framesTotal != 0 && framesTotal % COLLISION_UPDATES_INTERVAL == 0;
    if (updateColl) {
      synchronized (lockElementsForCurrentLevelUpdate) {
        int size = elementsForCurrentLevelUpdate.length;
        for (int i = 0; i < size; i++) {
          Element a = elementsForCurrentLevelUpdate[i];
          synchronized (a) {
            if (!a.isCollidable()) continue;
            RectF rectA = a.getBBox();
            if (rectA == null) continue;
            ArrayList<Element> colidesWith = null;
//    for (int j = i + 1; j < size; j++) {
            for (int j = 0; j < size; j++) {
              if (i == j) continue;
              Element b = elementsForCurrentLevelUpdate[j];
              if (!b.isCollidable()) continue;
              RectF rectB = b.getBBox();
              if (rectB == null) continue;
              if (RectF.intersects(rectA, rectB)) {
                if (colidesWith == null) colidesWith = new ArrayList<>();
                colidesWith.add(b);
              }
            }
            if (colidesWith != null && colidesWith.size() > 0) {
              a.onCollision(this, colidesWith, timeElapsed, timeTotal, fps, camera);
            }
          }
        }
      }
    }
    //</editor-fold>

    //<editor-fold desc="onUpdate //////////////////////////////////////">
    synchronized (lockElementsForCurrentLevelUpdate) {
      int size = elementsForCurrentLevelUpdate.length;
      Element element;
      for (int i = 0; i < size; i++) {
        element = elementsForCurrentLevelUpdate[i];
        synchronized (element) {
          final boolean active = element.isActive();
          final boolean visible = element.isVisible();
          final boolean willUpdate = element.willUpdate(framesTotal);
          if (willUpdate) {
            element.onUpdate(this, timeElapsed, timeTotal, fps, camera);
            element.onPreRender(this, timeElapsed, timeTotal, fps, camera);
            if (!active || !visible) {
              element.setWillNotRender();
              continue;
            }
          }
          if (!active || !visible) {
            element.setWillNotRender();
            continue;
          }
//        if (element.isInViewSpace()) {
          element.setWillRender();
//        } else {
//          RectF elementsBBox = element.getBBox();
//          if (isBBoxwithinViewport(elementsBBox)) {
//            element.setWillRender();
//          } else {
//            element.setWillNotRender();
//          }
//        }
        }
      }
    }
    //</editor-fold>
  }

  private void render() {
    Message message = handlerRender.obtainMessage(RENDER);
    handlerRender.sendMessage(message);
  }

  private volatile boolean flip = true;

  private void _render(final Message message) {
    if (engineView == null) return;
    if (isRendering) return;
    Bitmap bm;
    flip = !flip;
    if (flip) {
      bm = bitmapCacheA;
    } else {
      bm = bitmapCacheB;
    }
    if (bm == null) return;
    isRendering = true;
    //<editor-fold desc="stamp timing head">
    timeStampInMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
    timeElapsed = timeStampInMillis - prevTime;
    timeTotal += timeElapsed;
    milliAccum += timeElapsed;
    if (milliAccum > 1000) {
      fps = (int) (framesTotalInSecond * milliAccum / 1000);
      milliAccum = 0;
      framesTotalInSecond = 0;
    }
    //</editor-fold>
    _update();
    canvasCache.setBitmap(bm);
    currentCameraMatrix.set(camera.getMatrix());
    Matrix delta = new Matrix();
    delta.postConcat(currentCameraMatrix);
    prevCameraMatrix.set(currentCameraMatrix);
    delta.postTranslate(OVERFLOW_PIXELS_AMOUNT, OVERFLOW_PIXELS_AMOUNT);
    canvasCache.setMatrix(delta);
    canvasCache.drawColor(Color.BLACK);
//canvas.scale(0.5f, 0.5f, camera.getX(), camera.getY());
    synchronized (lockElementsForCurrentLevelRender) {
      for (int i = 0; i < elementsForCurrentLevelRenderMapSpace.length; i++) {
        Element element = elementsForCurrentLevelRenderMapSpace[i];
        synchronized (element) {
          if (!element.willRender()) continue;
          canvasCache.save();
          canvasCache.concat(element.getTransformation());
          element.onRender(canvasCache, null);
          canvasCache.restore();
          //
          element.setDirtyShape(false);
          element.setDirtyStyle(false);
          element.setDirtyTransform(false);
        }
      }
    }
//    canvasCache.concat(camera.getMatrixDelta());
//      canvas.drawBitmap(bitmapCache, 0, 0, paintDebug);
    synchronized (lockBitmapCache) {
      currentCameraMatrix.postTranslate(-OVERFLOW_PIXELS_AMOUNT, -OVERFLOW_PIXELS_AMOUNT);
      rendCameraMatrix.set(delta);
//    rendCameraMatrix.postTranslate(xx, yy);
      bitmapCache = bm;
    }
//final Rect viewport = camera.getViewport();
//canvas.drawRect(viewport.width()*0.25f,viewport.height()*0.25f,viewport.width()*0.75f,viewport.height()*0.75f,paintDebug);
    camera.setIsTransformationDirty(false);
    //
    //<editor-fold desc="stamp timing tail">
    prevTime = timeStampInMillis;
    framesTotal++;
    framesTotalInSecond++;
    //</editor-fold>
    isRendering = false;
  }

  private void setOffscreenBitmap(int width, int height) {
    final int padd = OVERFLOW_PIXELS_AMOUNT * 2;
    synchronized (lockBitmapCache) {
      bitmapCacheA = Bitmap.createBitmap(width + padd, height + padd, Bitmap.Config.RGB_565);
      bitmapCacheB = Bitmap.createBitmap(width + padd, height + padd, Bitmap.Config.RGB_565);
      bitmapCache = bitmapCacheA;
    }
  }

  private void destroyLoop() {
    synchronized (lockElementList) {
      Element element;
      int size = elementList.size();
      for (int i = 0; i < size; i++) {
        element = elementList.get(i);
        synchronized (element) {
          element.onDestroy(context);
        }
      }
    }
  }

  /**
   * Render the current content to an image using the provided a canvas object
   *
   * @param canvas         the canvas with the desired bitmap to be rendered.
   * @param renderCallback callback to be invoked when the rendering to bitmap is complete, can be null
   */
  public void renderToCanvas(@NonNull final Canvas canvas, final RenderCallback renderCallback) {
    final Object[] objects = new Object[2];
    objects[0] = canvas;
    objects[1] = renderCallback;
    Message message = handlerUpdate.obtainMessage(RENDER_TO_CANVAS, objects);
    handlerUpdate.sendMessage(message);
  }

  private void _renderToCanvas(Message message) {
    final Object[] objects = (Object[]) message.obj;
    final Canvas canvas = (Canvas) objects[0];
    final RenderCallback renderCallback = (RenderCallback) objects[1];
    //
    _update();
    //
    synchronized (lockElementsForCurrentLevelUpdate) {
      int size;
      size = elementsForCurrentLevelUpdate.length;
      int i;
      Element element;
      canvas.save();
      canvas.drawColor(Color.BLACK);
      //
      canvas.setMatrix(camera.getMatrix());
      for (i = 0; i < size; i++) {
        element = elementsForCurrentLevelUpdate[i];
        synchronized (element) {
          if (element.isInViewSpace()) continue;
          if (!element.isActive()) continue;
          if (!element.isVisible()) continue;
//        if (!RectF.intersects(camera.getFieldOfViewBBox(), element.getBBox())) continue;
          canvas.save();
          canvas.concat(element.getTransformation());
          element.onRender(canvas, null);
          canvas.restore();
        }
      }
      canvas.restore();
    }
    //
    if (renderCallback != null) {
      runOnUiThread(
              new Runnable() {
                @Override
                public void run() {
                  renderCallback.onRender();
                }
              }
      );
    }
  }

  private long accum;

  private Rect getRenderRegionTile() {
    long size = 5;
    final Rect viewport = camera.getViewport();
    final int w = (int) (viewport.width() / size);
    final int h = (int) (viewport.height() / size);
    final Rect region = new Rect(0, 0, w, h);
    final float rX = accum % size;
    final int x = (int) (w * rX);
    final float rY = accum % (size * size) / size;
    final int y = (int) (h * rY);
//  Log.i(TAG, "rX> " + rX + " rY> " + rY);
    region.offset(x, y);
    accum++;
    return region;
  }

  private void hitTests(final String touchEventType, final MotionEvent motionEvent) {
    Message message = handlerUpdate.obtainMessage(HIT_TESTS);
    final Bundle bundle = new Bundle();
    bundle.putString("touchEventType", touchEventType);
    bundle.putParcelable("motionEvent", motionEvent);
    message.setData(bundle);
    handlerUpdate.sendMessage(message);
  }

  private void _hitTests(Message message) {
    final Bundle bundle = message.getData();
    MotionEvent motionEvent = bundle.getParcelable("motionEvent");
    String touchEventType = (String) bundle.get("touchEventType");
    _hitTests(touchEventType, motionEvent);
  }

  private void _hitTests(final String touchEventType, final MotionEvent motionEvent) {
    // TODO: 2016-03-13 optimize with very small btmp
    if (motionEvent == null) return;
    if (camera.getViewport().isEmpty()) return;
    Bitmap bitmapTmp = Bitmap.createBitmap((int) camera.getViewport().width(), (int) camera.getViewport().height(), Bitmap.Config.ARGB_8888);
    Canvas canvasTmp = new Canvas(bitmapTmp);
    Element elementUnderHit = null;

    synchronized (lockElementsForCurrentLevelUpdate) {
      int size = elementsForCurrentLevelUpdate.length;
      float stride = 256 * 256 * 256 / size; //  24bit 888 rgb mode
      final ArrayList<Integer> colors = new ArrayList<>();
      for (int i = 1; i <= size; i++) {
        int hex = (int) (stride * i) + 0xff000000;
        colors.add(hex);
      }
      Collections.shuffle(colors);


      canvasTmp.save();
      canvasTmp.concat(camera.getMatrix());
      canvasTmp.drawColor(Color.BLACK);
      for (int i = 0; i < size; i++) {
        Element element = elementsForCurrentLevelUpdate[i];
        synchronized (element) {
          if (element.isInViewSpace()) continue;
          if (!element.isSelectable()) continue;
          if (!element.isActive()) continue;
          if (!element.isVisible()) continue;
          int objectsUniqueColor = colors.get(i);
          paintHit.setColor(objectsUniqueColor);
          canvasTmp.save();
          canvasTmp.concat(element.getTransformation());
          element.onRender(canvasTmp, paintHit);
          canvasTmp.restore();
        }
      }
      canvasTmp.restore();
      for (int i = 0; i < size; i++) {
        Element element = elementsForCurrentLevelUpdate[i];
        synchronized (element) {
          if (!element.isInViewSpace()) continue;
          if (!element.isSelectable()) continue;
          if (!element.isActive()) continue;
          if (!element.isVisible()) continue;
          int objectsUniqueColor = colors.get(i);
          paintHit.setColor(objectsUniqueColor);
          canvasTmp.save();
          canvasTmp.concat(element.getTransformation());
          element.onRender(canvasTmp, paintHit);
          canvasTmp.restore();
        }
      }

      int x = Math.round(motionEvent.getX());
      int y = Math.round(motionEvent.getY());
      try {
        int colorUnder = bitmapTmp.getPixel(x, y);
//  Log.i(TAG, "Color under is " + colorUnder);
        if (colorUnder == Color.BLACK) {
          colorUnder = pseudoFlood(bitmapTmp, x, y);
          if (colorUnder == Color.BLACK) return;
        }
        int index = colors.indexOf(colorUnder);
        if (index > -1) {
//      Log.i(TAG, "HIT!!!!!!. ");
          elementUnderHit = elementsForCurrentLevelUpdate[index];
        }
      } catch (IllegalArgumentException e) {
      }
    }

    if (elementUnderHit == null) return;
    LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
    IntentTouch intent = null;
    switch (touchEventType) {
      case EngineView.ON_SINGLE_TAP_UP:
        intent = new IntentTouch(mID, IntentFilterTouch.TYPE_UP, elementUnderHit.id, elementUnderHit);
        break;
      case EngineView.ON_DOWN:
        intent = new IntentTouch(mID, IntentFilterTouch.TYPE_DOWN, elementUnderHit.id, elementUnderHit);
        break;
      case EngineView.ON_SINGLE_TAP_CONFIRMED:
        intent = new IntentTouch(mID, IntentFilterTouch.TYPE_SINGLE, elementUnderHit.id, elementUnderHit);
        break;
      case EngineView.ON_DOUBLE_TAP:
        intent = new IntentTouch(mID, IntentFilterTouch.TYPE_DOUBLE, elementUnderHit.id, elementUnderHit);
        break;
      case EngineView.ON_LONGPRESS:
        intent = new IntentTouch(mID, IntentFilterTouch.TYPE_LONG_PRESS, elementUnderHit.id, elementUnderHit);
        break;
    }
    if (intent == null) return;
    localBroadcastManager.sendBroadcast(intent);
    elementUnderHit.onTouchEvent(intent);
  }

  private int pseudoFlood(Bitmap bitmapTmp, int x, int y) {
//todo better flood algo, expose constant values
    int colorUnder = Color.BLACK;
    int newY = 0;
    int newX = 0;
    for (int i = 1; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        switch (j) {
          case 0:
            newX = 0;
            newY = -1;
            break;
          case 1:
            newX = 1;
            newY = 0;
            break;
          case 2:
            newX = 0;
            newY = 1;
            break;
          case 3:
            newX = -1;
            newY = 0;
            break;
        }
        newX = newX * i + x;
        newY = newY * i + y;
        if (newX < 0 || newY < 0 || newX > bitmapTmp.getWidth() - 1 || newY > bitmapTmp.getHeight() - 1)
          return Color.BLACK;
        colorUnder = bitmapTmp.getPixel(newX, newY);
        if (colorUnder != Color.BLACK) {
//              Log.e(TAG, "pixel under x:" + j + " y: " + iy + " color: " + colorUnder + " hex " + Integer.toHexString(colorUnder));
          return colorUnder;
        }
      }
    }
    return colorUnder;
  }

  boolean isBBoxWithin(float[] normals, double[] projectedMin, double[] projectedMax, RectF bbox) {
//  float[] bboxArray = {
//      bbox.left, bbox.top,
//      bbox.right, bbox.top,
//      bbox.right, bbox.bottom,
//      bbox.left, bbox.bottom
//  };

    for (int i = 0; i < 4; i += 2) {
      float nrmX = normals[i];
      float nrmY = normals[i + 1];

      double minB = Double.POSITIVE_INFINITY;
      double maxB = Double.NEGATIVE_INFINITY;
//    for (int j = 0; j < 8; j += 2) {
//      float pX = bboxArray[j];
//      float pY = bboxArray[j + 1];
//      double projected = nrmX * pX + nrmY * pY;
//      if (projected < minB) minB = projected;
//      if (projected > maxB) maxB = projected;
//    }
      float pX, pY;
      double projected;
      pX = bbox.left;
      pY = bbox.top;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      pX = bbox.right;
      pY = bbox.top;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      pX = bbox.right;
      pY = bbox.bottom;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      pX = bbox.left;
      pY = bbox.bottom;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      if (projectedMax[i] < minB || maxB < projectedMin[i]) return false;
    }
    return true;
  }

  boolean isBBoxwithinViewport(RectF bbox) {
//  float[] bboxArray = {
//      bbox.left, bbox.top,
//      bbox.right, bbox.top,
//      bbox.right, bbox.bottom,
//      bbox.left, bbox.bottom
//  };

    for (int i = 0; i < 4; i += 2) {
      float nrmX = camera.normals[i];
      float nrmY = camera.normals[i + 1];

      double minB = Double.POSITIVE_INFINITY;
      double maxB = Double.NEGATIVE_INFINITY;
//    for (int j = 0; j < 8; j += 2) {
//      float pX = bboxArray[j];
//      float pY = bboxArray[j + 1];
//      double projected = nrmX * pX + nrmY * pY;
//      if (projected < minB) minB = projected;
//      if (projected > maxB) maxB = projected;
//    }
      float pX, pY;
      double projected;
      pX = bbox.left;
      pY = bbox.top;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      pX = bbox.right;
      pY = bbox.top;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      pX = bbox.right;
      pY = bbox.bottom;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      pX = bbox.left;
      pY = bbox.bottom;
      projected = nrmX * pX + nrmY * pY;
      if (projected < minB) minB = projected;
      if (projected > maxB) maxB = projected;
      if (camera.projectedMax[i] < minB || maxB < camera.projectedMin[i]) return false;
    }
    return true;
  }
//</editor-fold>

//<editor-fold desc="-------------------------------------          main">

  private void runOnUiThread(final Runnable runnable) {
    if (Looper.myLooper() != Looper.getMainLooper()) {
      new Handler(Looper.getMainLooper()).post(runnable);
    } else {
      runnable.run();
    }
  }

  /**
   * Add an element to the Element List
   * elements added to this list will be in Global space
   *
   * @param element the element to be added.
   */
  public void addToMap(Element element) {
    removeFromMap(element);
    Message message = handlerUpdate.obtainMessage(ADD_TO_MAP, element);
    handlerUpdate.sendMessage(message);
  }

  private void _addToMap(Element element) {
    synchronized (lockElementList) {
      if (elementList.indexOf(element) != -1) _removeFromMap(element);
      elementList.add(element);
    }
    if (!element.isInitialized()) {
      element.onCreate(context, this, timeElapsed, timeTotal, camera);
    }
    ArrayList<Element> children = element.getChildren();
    final int size = children.size();
    for (int i = 0; i < size; i++) {
      Element child = children.get(i);
      _addToMap(child);
    }
    _setElementsOfCurrentLevel();
  }

  /**
   * Removes the passed element from the Element List
   *
   * @param element the element to be removed
   */
  public void removeFromMap(Element element) {
    Message message = handlerUpdate.obtainMessage(REMOVE_FROM__MAP, element);
    handlerUpdate.sendMessage(message);
  }

  private void _removeFromMap(Element element) {
    synchronized (lockElementList) {
      if (elementList.indexOf(element) == -1) return;
      elementList.remove(element);
    }
    ArrayList<Element> children = element.getChildren();
    final int size = children.size();
    for (int i = 0; i < size; i++) {
      Element child = children.get(i);
      _removeFromMap(child);
    }
    _setElementsOfCurrentLevel();
  }

  /**
   * Returns the state the engine is currently in.
   * can be one of the following.
   * {@link IntentFilterEngine#NONE}
   * {@link IntentFilterEngine#START}
   * {@link IntentFilterEngine#COMPLETE}
   * {@link IntentFilterEngine#RESUME}
   * {@link IntentFilterEngine#PAUSE}
   * {@link IntentFilterEngine#STOP}
   * {@link IntentFilterEngine#ERROR}
   * {@link IntentFilterEngine#DESTROY}
   *
   * @return a string value reflecting the engine`s state
   */
  public String getEngineState() {
    return engineState;
  }

  private void setEngineState(String intentEngineState) {
    setEngineState(intentEngineState, false);
  }

  private void setEngineState(String intentEngineState, boolean dispatchAgain) {
    int dispatchAgainInt = 0;
    if (dispatchAgain) dispatchAgainInt = 1;
    Message message = handlerUpdate.obtainMessage(SET_ENGINE_STATE, dispatchAgainInt, dispatchAgainInt, intentEngineState);
    handlerUpdate.sendMessage(message);
  }

  private void _setEngineState(String intentEngineState, int dispatcgAgain) {
    if (dispatcgAgain == 0 && engineState.equalsIgnoreCase(intentEngineState)) return;
    engineState = intentEngineState;
    Log.d(TAG, "Engine State: " + intentEngineState);
    LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentEngine(mID, intentEngineState));
  }

  private void _setElementsOfCurrentLevel() {
    final ArrayList<Element> elements = new ArrayList<>();
    final ArrayList<Element> elementsMap = new ArrayList<>();
    final ArrayList<Element> elementsView = new ArrayList<>();
    synchronized (lockElementList) {
      int size = elementList.size();
      Element element;
      for (int i = 0; i < size; i++) {
        element = elementList.get(i);
        if (element.getLevel() != currentMapIndex && element.getLevel() != -1) continue;
        elements.add(element);
        if (element.isInViewSpace()) {
          elementsView.add(element);
        } else {
          elementsMap.add(element);
        }
      }
    }
    synchronized (lockElementsForCurrentLevelUpdate) {
      elementsForCurrentLevelUpdate = elements.toArray(new Element[elements.size()]);
    }
    synchronized (lockElementsForCurrentLevelRender) {
      elementsForCurrentLevelRenderMapSpace = elementsMap.toArray(new Element[elementsMap.size()]);
      elementsForCurrentLevelRenderViewSpace = elementsView.toArray(new Element[elementsView.size()]);
    }
  }

  /**
   * Returns an array with all the {@link Element}s on the current level/floor.
   *
   * @return the array with all the {@link Element}s
   */
  public Element[] getElementsOfCurrentLevel() {
    final Element[] elements;
    synchronized (lockElementsForCurrentLevelUpdate) {
      elements = elementsForCurrentLevelUpdate.clone();
    }
    return elements;
  }

  /**
   * Returns an array with all the {@link Element}s created for the venue.
   *
   * @return the array with all the {@link Element}s
   */
  public Element[] getElementList() {
    synchronized (lockElementList) {
      final Element[] elements = new Element[elementList.size()];
      elementList.toArray(elements);
      return elements;
    }
  }

/**
 * Returns the current SDK version.
 *
 * @return
 */
public String getSdkVersion() {
  return SDK_VERSION;
}
//</editor-fold>

//<editor-fold desc="-------------------------------------          WAYFIND">

/**
 * Snap the blue dot to a wayfinding path
 */


  /**
   * Resets the wayfinding variables, all wayfind views will be not visible
   */
  public void resetWayfind() {
    wayfind(null, null, 100);
  }

  public PathPerFloor[] getPathPerFloors() {
    synchronized (lockPathPerFloor) {
      return pathPerFloors;
    }
  }

  public PathPerFloor getPathForCurrentFloor() {
    synchronized (lockPathPerFloor) {
      return pathForCurrentFloor;
    }
  }

  public int getAccessLevel() {
    return accessLevel;
  }

  public void setAccessLevel(int accessLevel) {
    if (this.accessLevel == accessLevel) return;
    this.accessLevel = accessLevel;
    LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentWaypoint(mID, fromWaypoint, toWaypoint, accessLevel));
  }

  public Waypoint getFromWaypoint() {
    return fromWaypoint;
  }

  /**
   * Sets the waypointFrom variables
   *
   * @param fromWaypoint
   */
  public void setFromWaypoint(Waypoint fromWaypoint) {
    if (this.fromWaypoint == fromWaypoint) return;
    this.fromWaypoint = fromWaypoint;
    LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentWaypoint(mID, fromWaypoint, toWaypoint, accessLevel));
    doWayfind();
  }

  public Waypoint getToWaypoint() {
    return toWaypoint;
  }

  /**
   * Sets the waypointTo variable
   */
  public void setToWaypoint(Waypoint toWaypoint) {
    if (this.toWaypoint == toWaypoint) return;
    this.toWaypoint = toWaypoint;
    LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentWaypoint(mID, fromWaypoint, toWaypoint, accessLevel));
    doWayfind();
  }

  private ASSearch getAStarSearch() {
    if (asGrid == null || asSearch == null) {
      asGrid = new ASGrid(venueData.waypoints, venueData.paths, venueData.pathTypes, venueData.maps);
      asSearch = new ASSearch(asGrid);
    }
    return asSearch;
  }

  public PathPerFloor[] wayfind(Waypoint from, Waypoint to, int access) {
    if (fromWaypoint == from && toWaypoint == to && accessLevel == access) {
      synchronized (lockPathPerFloor) {
        return pathPerFloors;
      }
    }
    setFromWaypoint(from);
    setToWaypoint(to);
    setAccessLevel(accessLevel);
    return doWayfind();
  }

  /**
   * Wayfind to desired waypoints accesability will be set to false
   * returns the paths per floor
   *
   * @param from The starting waypoint.
   * @param to   The end waypoint.
   * @return PathPerFloor[]
   */
  public PathPerFloor[] wayfind(Waypoint from, Waypoint to) {
    return wayfind(from, to, false);
  }

  /**
   * Wayfind to desired waypoints
   * returns the paths per floor
   *
   * @param from          The starting waypoint.
   * @param to            The end waypoint.
   * @param accessibility
   * @return PathPerFloor[]
   */
  public PathPerFloor[] wayfind(Waypoint from, Waypoint to, boolean accessibility) {
    int acces;
    if (accessibility) {/**/
      acces = 50;
    } else {
      acces = 100;
    }
    return wayfind(from, to, acces);
  }

  /**
   * @param from
   * @param to
   * @param accessibility
   * @param pathPerFloors
   */
  public void wayfind(Waypoint from, Waypoint to, boolean accessibility, CallbackPathPerFloors pathPerFloors) {
    PathPerFloor[] p = wayfind(from, to, accessibility);
    pathPerFloors.callback(p);
  }

  /**/
  public void wayfind(Waypoint from, Waypoint to, int accessibility, CallbackPathPerFloors pathPerFloors) {
    PathPerFloor[] p = wayfind(from, to, accessibility);
    pathPerFloors.callback(p);
  }

  private PathPerFloor[] doWayfind() {
    if (toWaypoint != fromWaypoint && fromWaypoint != null &&
            toWaypoint != null && accessLevel > 0
            ) {
      synchronized (lockPathPerFloor) {
        pathPerFloors = getAStarSearch().search(fromWaypoint.id, toWaypoint.id, accessLevel);
        setPathForCurrentFloor();
      }
    } else {
      synchronized (lockPathPerFloor) {
        pathPerFloors = null;
        pathForCurrentFloor = null;
      }
    }


    showHideWayfindingElements();
    synchronized (lockPathPerFloor) {
      LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentWayfind(mID, pathPerFloors));
      return pathPerFloors;
    }
  }

  public ArrayList<ArrayList<TDInstruction>> getTextDirectionInstruction(boolean filterEnabled, int uTurnMeters, int joinForwardInstructionWithinMeters) {
    synchronized (lockPathPerFloor) {
      if (pathPerFloors == null) return null;
      TextDirectionOptions textDirectionOptions = new TextDirectionOptions();
      textDirectionOptions.filter = filterEnabled;
      textDirectionOptions.uTurnMeters = uTurnMeters;
      textDirectionOptions.joinForwardInstructionWithinMeters = joinForwardInstructionWithinMeters;
      textDirectionOptions.pointArray = pathPerFloors;
      return getTextDirectionInstruction(textDirectionOptions);
    }
  }

  public ArrayList<ArrayList<TDInstruction>> getTextDirectionInstruction(TextDirectionOptions textDirectionOptions) {
    // checking x and y scale if No X/Y scale on this map. No Text directions to be shown
    if (!((venueData.maps[0].map.xScale > 0) && (venueData.maps[0].map.yScale > 0))) return null;
    MakeTextDirections makeTextDirections = new MakeTextDirections(this);
    return makeTextDirections.makeProcessedTextDirections(textDirectionOptions);
  }

  /**
   * sets the pathForCurrentFloor value
   */
  private void setPathForCurrentFloor() {
    synchronized (lockPathPerFloor) {
      if (pathPerFloors == null) return;
      pathForCurrentFloor = null;
      final int lengthPaths = pathPerFloors.length;
      if (lengthPaths == 0) return;
      PathPerFloor pathPerFloor = null;
      for (int i = 0; i < lengthPaths; i++) {
        final PathPerFloor perFloor = pathPerFloors[i];
        if (perFloor.mapId == currentMap.map.mapId) {
          pathPerFloor = perFloor;
          break;
        }
      }
      if (pathPerFloor != null) {
        pathForCurrentFloor = pathPerFloor;
        Path tmp = new Path();
        final ASNode[] points = pathPerFloor.points;
        final int lengthPnts = points.length;
        for (int j = 0; j < lengthPnts; j++) {
          ASNode asNode = points[j];
          if (j == 0) {
            tmp.moveTo((float) asNode.x, (float) asNode.y);
          } else {
            tmp.lineTo((float) asNode.x, (float) asNode.y);
          }
          androidPathForCurrentFloor = tmp;
        }
      }
    }
  }

  private void showHideWayfindingElements() {
//  PathPerFloor pathForCurrentFloor = getPathForCurrentFloor();

    synchronized (lockPathPerFloor) {
      youAreHere.setVisible(false);
      pin.setVisible(false);
      moverA.setVisible(false);
      moverB.setVisible(false);
      route.setVisible(false);
      if (pathPerFloors == null) return;
      if (pathPerFloors.length == 0) return;
      if (pathForCurrentFloor == null) return;
      if (pathForCurrentFloor.points.length <= 1) return;
      final int index = Arrays.asList(pathPerFloors).indexOf(pathForCurrentFloor);
      final int totalPaths = pathPerFloors.length;
      int levelsIndexWithMapID = getLevelsIndexWithMapID(pathForCurrentFloor.mapId);
      /// YAH--------------------------------------
      if (index == 0) {
        PathPerFloor firstPathPerFloor = pathPerFloors[0];
        youAreHere.getTransform().setTranslationX((float) firstPathPerFloor.points[0].x);
        youAreHere.getTransform().setTranslationY((float) firstPathPerFloor.points[0].y);
//    youAreHere.setLevel(getLevelsIndexWithMapID(firstPathPerFloor.mapId));
        youAreHere.setVisible(true);
      }

      /// PIN--------------------------------------
      if (index == totalPaths - 1) {
        PathPerFloor lastPathPerFloor = pathPerFloors[pathPerFloors.length - 1];
        int lastPointIndex = lastPathPerFloor.points.length - 1;
        pin.getTransform().setTranslationX((float) lastPathPerFloor.points[lastPointIndex].x);
        pin.getTransform().setTranslationY((float) lastPathPerFloor.points[lastPointIndex].y);
//    pin.setLevel(getLevelsIndexWithMapID(lastPathPerFloor.mapId));
        pin.setVisible(true);
      }

      /// ROUTE--------------------------------------
      if (levelsIndexWithMapID == currentMapIndex) {
        ((JPath) route.getShape()).setPath(androidPathForCurrentFloor);
        route.setVisible(true);
      }

      /// MOVERS--------------------------------------
      String shapeID;
      IconShape icon;
      if (totalPaths > 1) {// on multiple floors
        if (index == 0) {// First seq
          shapeID = pathForCurrentFloor.pathType.description;
          icon = iconShapeLib.getIcon(shapeID);
          moverB.setShape(icon);
          moverB.setVisible(true);
        } else if (index == totalPaths - 1) { // Last seq

          shapeID = pathPerFloors[index - 1].pathType.description;
          icon = iconShapeLib.getIcon(shapeID);
          moverA.setShape(icon);
          moverA.setVisible(true);
        } else if (0 < index && index < totalPaths) { // between
          moverA.setVisible(true);
          moverB.setVisible(true);

          shapeID = pathPerFloors[index - 1].pathType.description;
          icon = iconShapeLib.getIcon(shapeID);
          moverA.setShape(icon);
          shapeID = pathForCurrentFloor.pathType.description;
          icon = iconShapeLib.getIcon(shapeID);
          moverB.setShape(icon);
        }
      } else { // one floor
      }
      moverA.getTransform().setTranslationX((float) pathForCurrentFloor.points[0].x);
      moverA.getTransform().setTranslationY((float) pathForCurrentFloor.points[0].y);
      int lastInt = pathForCurrentFloor.points.length - 1;
      moverB.getTransform().setTranslationX((float) pathForCurrentFloor.points[lastInt].x);
      moverB.getTransform().setTranslationY((float) pathForCurrentFloor.points[lastInt].y);
    }
  }
//</editor-fold>

//<editor-fold desc="-------------------------------------          MAPS">

  /**
   * Retrieve the {@link MapFull} from its id
   *
   * @param id
   * @return
   */
  public MapFull getMapWithID(int id) {
    MapFull[] maps = venueData.maps;
    final int length = maps.length;
    for (int i = 0; i < length; i++) {
      MapFull mapFull = maps[i];
      if (id == mapFull.map.mapId) {
        return mapFull;
      }
    }
    return null;
  }

  /**
   * Retrieve the {@link MapFull} from its id
   *
   * @param id
   * @param callbackMapFull
   */
  public void getMapWithID(int id, CallbackMapFull callbackMapFull) {
    callbackMapFull.callback(getMapWithID(id));
  }

  public MapFull getCurrentMap() {
    return currentMap;
  }

  public int getCurrentMapIndex() {
    return currentMapIndex;
  }

  public void setCurrentMap(MapFull mapFull) {
    Message message = handlerUpdate.obtainMessage(SET_CURRENT_MAP, mapFull);
    handlerUpdate.sendMessage(message);
  }

  private void _setCurrentMap(MapFull mapFull) {
    if (this.currentMap == mapFull) return;
    int newIndex = Arrays.asList(venueData.maps).indexOf(mapFull);
    _setCurrentMapIndex(newIndex);
  }

  public void setCurrentMapIndex(int mapIndex) {
    Message message = handlerUpdate.obtainMessage(SET_CURRENT_MAP_INDEX, mapIndex, mapIndex);
    handlerUpdate.sendMessage(message);
  }

  private void _setCurrentMapIndex(int mapIndex) {
    if (mapIndex < 0) return;
    if (this.currentMapIndex == mapIndex) return;
    int prevIndex = this.currentMapIndex;
    this.currentMapIndex = mapIndex;
    currentMap = venueData.maps[mapIndex];
    setPathForCurrentFloor();
    showHideWayfindingElements();
    _setElementsOfCurrentLevel();
    camera.setContentSize(floorViewboxes[currentMapIndex]);
    LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentMap(mID, mapIndex, prevIndex));
  }

  public synchronized MapFull getDefaultMap() {
    return defaultMap;
  }

  /**
   * Get floor by Id
   */
  public MapFull getMapFullById(Integer mapId) {
    MapFull[] maps = venueData.maps;
    final int length = maps.length;
    for (int i = 0; i < length; i++) {
      MapFull mapFull = maps[i];
      if (mapFull.map.mapId == mapId) {
        return mapFull;
      }
    }
    return null;
  }

  /**
   * Get floor given destination Id
   */
  public MapFull getMapFullByDestinationId(int destinationId) {
    MapFull[] maps = venueData.maps;
    final int lengthMaps = maps.length;
    for (int i = 0; i < lengthMaps; i++) {
      MapFull mapFull = maps[i];
      if (mapFull.waypoints == null) continue;
      Waypoint[] waypoints = mapFull.waypoints;
      final int lengthWPs = waypoints.length;
      for (int j = 0; j < lengthWPs; j++) {
        Waypoint wp = waypoints[j];
        if (wp.associations == null) continue;
        WaypointEntityLink[] associations = wp.associations;
        final int lengthAss = associations.length;
        for (int k = 0; k < lengthAss; k++) {
          WaypointEntityLink link = associations[k];
          if (link.entityId == destinationId) {
            return mapFull;
          }
        }
      }
    }
    return null;
  }

  /**
   * Get floor given sequence
   */
  public MapFull getMapFullDataBySequence(Integer floorSequence) {
    MapFull[] maps = venueData.maps;
    final int length = maps.length;
    for (int i = 0; i < length; i++) {
      MapFull mapFull = maps[i];
      if (mapFull.map.floorSequence == floorSequence) {
        return mapFull;
      }
    }
    return null;
  }

//</editor-fold>

//<editor-fold desc="-------------------------------------         Level">

  /**
   * Sets the Models currentMap to the value preceding the current one,
   * according to the sequence field set on the cms.
   * If loop is set to false and current index value is zero it will cap else,
   * if true it will cycle through the members in a descending order.
   */
  public void prevLevel(boolean loop) {
    int index = currentMapIndex - 1;
    if (index < 0) {
      if (loop) {
        index = venueData.maps.length - 1;
      } else {
        index = 0;
      }
    }
    setCurrentMap(venueData.maps[index]);
  }

  /**
   * Sets the Models currentMap to the value preceding the current one,
   * according to the sequence field set on the cms.
   */
  public void prevLevel() {
    prevLevel(false);
  }

  /**
   * Sets the Models currentMap to the value following the current one,
   * according to the returned array of maps obtained from the backend which
   * dictates the order.
   * If loop is set to false and current index value is the maximum it will cap else,
   * if true it will cycle through the members in a ascending order.
   */
  public void nextLevel(boolean loop) {
    int totalMaps = venueData.maps.length - 1;
    int index = currentMapIndex + 1;
    if (index > totalMaps) {
      if (loop) {
        index = 0;
      } else {
        index = totalMaps;
      }
    }
    setCurrentMap(venueData.maps[index]);
  }

  /**
   * Sets the Models currentMap to the value following the current one,
   * according to the returned array of maps obtained from the backend which
   * dictates the order.
   */
  public void nextLevel() {
    nextLevel(false);
  }

  /**
   * Sets the current level to the passed {MapFull} object
   *
   * @param mapFull
   * @see MapFull
   * @see MapFull
   */
  public void setLevel(@NonNull MapFull mapFull) {
    if (mapFull == null) return;
    setCurrentMap(mapFull);
  }

  /**
   * Sets the setCurrentMap value to the first waypoint`s mapID
   * that is associated with the requested destination
   *
   * @param id
   */
  public boolean setLevelByDestinationID(int id) {
    Destination destination = getDestinationByID(id);
    Waypoint[] waypoints = getWaypointsOfDestination(destination);
    if (waypoints != null && waypoints.length > 0) {
      final int mapId = waypoints[0].mapId;
      final MapFull mapFull = getMapWithID(mapId);
      setLevel(mapFull);
      return true;
    }
    return false;
  }

  /**
   * Get the level the requested {@link Waypoint} is on as an index
   *
   * @param id the waypoint`s ID
   */
  public int getLevelIndexOfWaypointWithID(int id) {
    Waypoint waypoint = getWaypointWithID(id);
    return getLevelsIndexWithMapID(waypoint.mapId);
  }

  public int getLevelsIndexWithMapID(int mapID) {
    final MapFull mapFull = getMapWithID(mapID);
    final int indexOf = Arrays.asList(venueData.maps).indexOf(mapFull);
    return indexOf;
  }
//</editor-fold>

//<editor-fold desc="-------------------------------------          Activness">

  /**
   * Utility fn that sets the Activeness of all instances
   * in the system
   *
   * @param cls
   * @param bool
   */
  public void setActivnessOnType(Class<?> cls, boolean bool) {
    Message message = handlerUpdate.obtainMessage(SET_ACTIVENESS_ON_TYPE, bool ? 1 : 0, 0, cls);
    handlerUpdate.sendMessage(message);
  }

  private void _setActivnessOnType(Message message) {
    final Class<?> aClass = (Class<?>) message.obj;
    boolean bool = message.arg1 > 0;
    _setActivnessOnType(aClass, bool);
  }

  private void _setActivnessOnType(Class<?> cls, boolean bool) {

    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element == null) continue;
        if (cls.isInstance(element)) {
          element.setActive(bool);
        }
      }
    }

    String intentFilterActivenessString = null;
    if (cls == ElementHUD.class) {
      activeHUD = bool;
      intentFilterActivenessString = IntentFilterActiveness.HEADS_UP_DISPLAY_CHANGE;
    } else if (cls == UnitLabel.class) {
      activeLabels = bool;
      intentFilterActivenessString = IntentFilterActiveness.UNIT_LABELS_CHANGE;
    } else if (cls == com.jibestream.jibestreamandroidlibrary.elements.MapLabel.class) {
      activeMapLabels = bool;
      intentFilterActivenessString = IntentFilterActiveness.MAPLABELS_CHANGE;
    } else if (cls == com.jibestream.jibestreamandroidlibrary.elements.Amenity.class) {
      activeAmenities = bool;
      intentFilterActivenessString = IntentFilterActiveness.AMENITIES_CHANGE;
    } else if (cls == com.jibestream.jibestreamandroidlibrary.elements.DestinationLabel.class) {
      activeDestinationLabels = bool;
      intentFilterActivenessString = IntentFilterActiveness.DESTINATIONLABELS_CHANGE;
    } else if (cls == WayfindKiosk.class) {
      activeWayfindKiosks = bool;
      intentFilterActivenessString = IntentFilterActiveness.WAYFIND_KIOSKS_CHANGE;
    } else if (cls == Obstacle.class) {
      activeObstacles = bool;
      intentFilterActivenessString = IntentFilterActiveness.OBSTACLES_CHANGE;
    } else if (cls == Escalator.class) {
      activeEscalators = bool;
      intentFilterActivenessString = IntentFilterActiveness.ESCALATORS_CHANGE;
    } else if (cls == Elevator.class) {
      activeElevators = bool;
      intentFilterActivenessString = IntentFilterActiveness.ELEVATORS_CHANGE;
    } else if (cls == Stair.class) {
      activeStairs = bool;
      intentFilterActivenessString = IntentFilterActiveness.STAIRS_CHANGE;
    } else if (cls == Unit.class) {
      activeUnits = bool;
      intentFilterActivenessString = IntentFilterActiveness.UNITS_CHANGE;
    } else if (cls == ParkingLot.class) {
      activeParkingLots = bool;
      intentFilterActivenessString = IntentFilterActiveness.PARKING_LOTS_CHANGE;
    } else if (cls == StreetMajor.class) {
      activeStreetsMajor = bool;
      intentFilterActivenessString = IntentFilterActiveness.STREETS_MAJOR_CHANGE;
    } else if (cls == StreetMinor.class) {
      activeStreetsMinor = bool;
      intentFilterActivenessString = IntentFilterActiveness.STREETS_MINOR_CHANGE;
    } else if (cls == StreetSmallAlley.class) {
      activeStreetsSmallAlleys = bool;
      intentFilterActivenessString = IntentFilterActiveness.STREETS_SMALLALLEYS_CHANGE;
    } else if (cls == MallBoundary.class) {
      activeMallBoundary = bool;
      intentFilterActivenessString = IntentFilterActiveness.MALL_BOUNDARY_CHANGE;
    } else if (cls == Background.class) {
      activeBackground = bool;
      intentFilterActivenessString = IntentFilterActiveness.BACKGROUND_CHANGE;
    } else if (cls == Restroom.class) {
      activeRestrooms = bool;
      intentFilterActivenessString = IntentFilterActiveness.RESTROOMS_CHANGE;
    } else if (cls == Corridor.class) {
      activeCorridor = bool;
      intentFilterActivenessString = IntentFilterActiveness.CORRIDORS_CHANGE;
    } else if (cls == Kiosk.class) {
      activeKiosk = bool;
      intentFilterActivenessString = IntentFilterActiveness.KIOSKS_CHANGE;
    } else if (cls == CustomArtLayer1.class) {
      activeArtLayer1 = bool;
      intentFilterActivenessString = IntentFilterActiveness.CUSTOM_LAYER_1_CHANGE;
    } else if (cls == CustomArtLayer2.class) {
      activeArtLayer2 = bool;
      intentFilterActivenessString = IntentFilterActiveness.CUSTOM_LAYER_2_CHANGE;
    } else if (cls == CustomArtLayer3.class) {
      activeArtLayer3 = bool;
      intentFilterActivenessString = IntentFilterActiveness.CUSTOM_LAYER_3_CHANGE;
    } else if (cls == CustomArtLayer4.class) {
      activeArtLayer4 = bool;
      intentFilterActivenessString = IntentFilterActiveness.CUSTOM_LAYER_4_CHANGE;
    } else if (cls == CustomArtLayer5.class) {
      activeArtLayer5 = bool;
      intentFilterActivenessString = IntentFilterActiveness.CUSTOM_LAYER_5_CHANGE;
    } else if (cls == CustomArtLayer6.class) {
      activeArtLayer6 = bool;
      intentFilterActivenessString = IntentFilterActiveness.CUSTOM_LAYER_6_CHANGE;
    } else if (cls == ElementCustom.class) {
      activeCustomElement = bool;
      intentFilterActivenessString = IntentFilterActiveness.ELEMENT_CUSTOM_CHANGE;
    }
    //
    if (intentFilterActivenessString != null) {
      LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentActiveness(mID, intentFilterActivenessString));
    }
  }

  /**
   * returns visability for HUDs
   *
   * @return
   */

  public boolean isActiveHUD() {
    return activeHUD;
  }

  /**
   * Globaly sets visability for Unit Labels
   *
   * @param activeHUD
   */
  public void setActiveHUDs(boolean activeHUD) {
    if (this.activeHUD == activeHUD) return;
    setActivnessOnType(ElementHUD.class, activeHUD);
  }

  /**
   * returns visability for Unit`s Labels
   *
   * @return
   */
  public boolean isActiveLabels() {
    return activeLabels;
  }

  /**
   * Globaly sets visability for Unit Labels
   *
   * @param activeLabels
   */
  public void setActiveLabels(boolean activeLabels) {
    if (this.activeLabels == activeLabels) return;
    setActivnessOnType(UnitLabel.class, activeLabels);
  }

  /**
   * gets global visibility of MapLabels
   *
   * @return
   */
  public boolean isActiveMapLabels() {
    return activeMapLabels;
  }

  /**
   * Sets the global visibility of MapLabels
   *
   * @param activeMapLabels
   */
  public void setActiveMapLabels(boolean activeMapLabels) {
    if (this.activeMapLabels == activeMapLabels) return;
    setActivnessOnType(com.jibestream.jibestreamandroidlibrary.elements.MapLabel.class, activeMapLabels);
  }

  /**
   * returns visability for All Amenities
   *
   * @return
   */
  public boolean isActiveAmenities() {
    return activeAmenities;
  }

  /**
   * Globaly sets visability for Amenities
   *
   * @param activeAmenities
   */
  public void setActiveAmenities(boolean activeAmenities) {
    if (this.activeAmenities == activeAmenities) return;
    setActivnessOnType(com.jibestream.jibestreamandroidlibrary.elements.Amenity.class, activeAmenities);
  }

  /**
   * returns visability for All DestinationLabels
   *
   * @return
   */
  public boolean isActiveDestinationLabels() {
    return activeDestinationLabels;
  }

  /**
   * Globaly sets visability for DestinationLabels
   *
   * @param activeDestinationLabels
   */
  public void setActiveDestinationLabels(boolean activeDestinationLabels) {
    if (this.activeDestinationLabels == activeDestinationLabels) return;
    setActivnessOnType(com.jibestream.jibestreamandroidlibrary.elements.DestinationLabel.class, activeDestinationLabels);
  }

  public boolean isActiveWayfindKiosks() {
    return activeWayfindKiosks;
  }

  public void setActiveWayfindKiosks(boolean activeWayfindKiosks) {
    if (this.activeWayfindKiosks == activeWayfindKiosks) return;
    setActivnessOnType(WayfindKiosk.class, activeWayfindKiosks);
  }

  public boolean isActiveObstacles() {
    return activeObstacles;
  }

  public void setActiveObstacles(boolean activeObstacles) {
    if (this.activeObstacles == activeObstacles) return;
    setActivnessOnType(Obstacle.class, activeObstacles);
  }

  public boolean isActiveEscalators() {
    return activeEscalators;
  }

  public void setActiveEscalators(boolean activeEscalators) {
    if (this.activeEscalators == activeEscalators) return;
    setActivnessOnType(Escalator.class, activeEscalators);
  }

  public boolean isActiveElevators() {
    return activeElevators;
  }

  public void setActiveElevators(boolean activeElevators) {
    if (this.activeElevators == activeElevators) return;
    setActivnessOnType(Elevator.class, activeElevators);
  }

  public boolean isActiveStairs() {
    return activeStairs;
  }

  public void setActiveStairs(boolean activeStairs) {
    if (this.activeStairs == activeStairs) return;
    setActivnessOnType(Stair.class, activeStairs);
  }

  public boolean isActiveUnits() {
    return activeUnits;
  }

  public void setActiveUnits(boolean activeUnits) {
    if (this.activeUnits == activeUnits) return;
    setActivnessOnType(Unit.class, activeUnits);
  }

  public boolean isActiveParkingLots() {
    return activeParkingLots;
  }

  public void setActiveParkingLots(boolean activeParkingLots) {
    if (this.activeParkingLots == activeParkingLots) return;
    setActivnessOnType(ParkingLot.class, activeParkingLots);
  }

  public boolean isActiveStreetsMajor() {
    return activeStreetsMajor;
  }

  public void setActiveStreetsMajor(boolean activeStreetsMajor) {
    if (this.activeStreetsMajor == activeStreetsMajor) return;
    setActivnessOnType(StreetMajor.class, activeStreetsMajor);
  }

  public boolean isActiveStreetsMinor() {
    return activeStreetsMinor;
  }

  public void setActiveStreetsMinor(boolean activeStreetsMinor) {
    if (this.activeStreetsMinor == activeStreetsMinor) return;
    setActivnessOnType(StreetMinor.class, activeStreetsMinor);
  }

  public boolean isActiveStreetsSmallAlleys() {
    return activeStreetsSmallAlleys;
  }

  public void setActiveStreetsSmallAlleys(boolean activeStreetsSmallAlleys) {
    if (this.activeStreetsSmallAlleys == activeStreetsSmallAlleys) return;
    setActivnessOnType(StreetSmallAlley.class, activeStreetsSmallAlleys);
  }

  public boolean isActiveMallBoundary() {
    return activeMallBoundary;
  }

  public void setActiveMallBoundary(boolean activeMallBoundary) {
    if (this.activeMallBoundary == activeMallBoundary) return;
    setActivnessOnType(MallBoundary.class, activeMallBoundary);
  }

  public boolean isActiveBackground() {
    return activeBackground;
  }

  public void setActiveBackground(boolean activeBackground) {
    if (this.activeBackground == activeBackground) return;
    setActivnessOnType(Background.class, activeBackground);
  }

  public boolean isActiveRestrooms() {
    return activeRestrooms;
  }

  public void setActiveRestrooms(boolean activeRestrooms) {
    if (this.activeRestrooms == activeRestrooms) return;
    setActivnessOnType(Restroom.class, activeRestrooms);
  }

  public boolean isActiveCorridor() {
    return activeCorridor;
  }

  public void setActiveCorridor(boolean activeCorridor) {
    if (this.activeCorridor == activeCorridor) return;
    setActivnessOnType(Corridor.class, activeCorridor);
  }

  public boolean isActiveKiosk() {
    return activeKiosk;
  }

  public void setActiveKiosk(boolean activeKiosk) {
    if (this.activeKiosk == activeKiosk) return;
    setActivnessOnType(Kiosk.class, activeKiosk);
  }

  public void setActiveCustomLayer(boolean activeCustomLayer, int layer_number) {
    switch (layer_number) {
      case 1:
        activeArtLayer1 = activeCustomLayer;
        setActivnessOnType(CustomArtLayer1.class, activeArtLayer1);
        break;
      case 2:
        activeArtLayer2 = activeCustomLayer;
        setActivnessOnType(CustomArtLayer2.class, activeArtLayer2);
        break;
      case 3:
        activeArtLayer3 = activeCustomLayer;
        setActivnessOnType(CustomArtLayer3.class, activeArtLayer3);
        break;
      case 4:
        activeArtLayer4 = activeCustomLayer;
        setActivnessOnType(CustomArtLayer4.class, activeArtLayer4);
        break;
      case 5:
        activeArtLayer5 = activeCustomLayer;
        setActivnessOnType(CustomArtLayer5.class, activeArtLayer5);
        break;
      case 6:
        activeArtLayer6 = activeCustomLayer;
        setActivnessOnType(CustomArtLayer6.class, activeArtLayer6);
        break;
    }
  }

  public boolean isActiveCustomLayer(int layer_number) {
    switch (layer_number) {
      case 1:
        return activeArtLayer1;
      case 2:
        return activeArtLayer2;
      case 3:
        return activeArtLayer3;
      case 4:
        return activeArtLayer4;
      case 5:
        return activeArtLayer5;
      case 6:
        return activeArtLayer6;
      default:
        return false;
    }
  }

  /**
   * @return whether or not the custom element is currently visible or not
   */
  public boolean isActiveCustomElement() {
    return activeCustomElement;
  }

  /**
   * Set if custom element should be visible or not
   *
   * @param activeCustomElement
   */
  public void setActiveCustomElement(boolean activeCustomElement) {
    if (this.activeCustomElement == activeCustomElement) {
      return;
    }
    setActivnessOnType(ElementCustom.class, activeCustomElement);
  }


  /**
   * Set if custom element should return an onTouch event back or not
   *
   * @param isSelectableCustomElement
   */
  public void setSelectableCustomElement(boolean isSelectableCustomElement) {
    Element[] elementsByType = getElementsByType(ElementCustom.class);
    for (int i = 0; i < elementsByType.length; i++) {
      Element element = elementsByType[i];
      element.setSelectable(isSelectableCustomElement);
    }
  }

//

  /**
   * returns an array of the element`s type Activness state
   * in the following order
   * "Labels", "Amenities", "Map Labels", "Destination Labels", "Kiosks", "Obstacles", "Escalators", "Elevators", "Stairs", "Units", "ParkingLots", "StreetsMajor", "StreetsMinor", "StreetsSmallAlleys", "MallBoundary", "Background", "Restrooms","Corridor","Kiosks","HUD" ,"ArtLayer1","ArtLayer2","ArtLayer3","ArtLayer4","ArtLayer5","ArtLayer6","ElementsCustom"
   *
   * @return a boolean array
   */
  public final boolean[] getElementsActivness() {
    return new boolean[]{
            activeLabels,
            activeAmenities,
            activeMapLabels,
            activeDestinationLabels,
            activeWayfindKiosks,
            activeObstacles,
            activeEscalators,
            activeElevators,
            activeStairs,
            activeUnits,
            activeParkingLots,
            activeStreetsMajor,
            activeStreetsMinor,
            activeStreetsSmallAlleys,
            activeMallBoundary,
            activeBackground,
            activeRestrooms,
            activeCorridor,
            activeKiosk,
            activeHUD,
            activeArtLayer1,
            activeArtLayer2,
            activeArtLayer3,
            activeArtLayer4,
            activeArtLayer5,
            activeArtLayer6,
            activeCustomElement
    };
  }

  /**
   * Sets the visibilty of the Element`s type state
   *
   * @param state a boolean array with a length of 27.
   */
  public void setElementsActivness(boolean[] state) {
    setActiveLabels(state[0]);
    setActiveAmenities(state[1]);
    setActiveMapLabels(state[2]);
    setActiveDestinationLabels(state[3]);
    setActiveWayfindKiosks(state[4]);
    setActiveObstacles(state[5]);
    setActiveEscalators(state[6]);
    setActiveElevators(state[7]);
    setActiveStairs(state[8]);
    setActiveUnits(state[9]);
    setActiveParkingLots(state[10]);
    setActiveStreetsMajor(state[11]);
    setActiveStreetsMinor(state[12]);
    setActiveStreetsSmallAlleys(state[13]);
    setActiveMallBoundary(state[14]);
    setActiveBackground(state[15]);
    setActiveRestrooms(state[16]);
    setActiveCorridor(state[17]);
    setActiveKiosk(state[18]);
    setActiveHUDs(state[19]);
    setActiveCustomLayer(state[20], 1);
    setActiveCustomLayer(state[21], 2);
    setActiveCustomLayer(state[22], 3);
    setActiveCustomLayer(state[23], 4);
    setActiveCustomLayer(state[24], 5);
    setActiveCustomLayer(state[25], 6);
    setActiveCustomElement(state[26]);
  }
//</editor-fold>

//<editor-fold desc="-------------------------------------          Visibility">

  /**
   * Utility fn that sets the visibility of all instances
   * in the system of the particular class
   *
   * @param cls
   * @param bool
   */
  public void setVisibilityOnType(Class<?> cls, boolean bool) {
    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element == null) continue;
        if (cls.isInstance(element)) {
          element.setVisible(bool);
        }
      }
    }
  }

  /**
   * Fn to set Ameneties1 visibility values
   *
   * @param states
   */

  public void setAmenitiesVisibility(boolean[] states) {
    //null on boot, call determines size
    if (amenitiesVisibility == null) {
      amenitiesVisibility = states;
    }
    //update by
    final int length = states.length;
    for (int i = 0; i < length; i++) {
      setAmenityVisibility(i, states[i]);
    }
  }

  /**
   * returns a copy of the amenitiesVisibility array
   * States the visibility of each amenity
   *
   * @return
   */
  public boolean[] getAmenitiesVisibility() {
    if (amenitiesVisibility != null) {
      return amenitiesVisibility.clone();
    } else {
      return null;
    }
  }

  /**
   * Sets the visibilty of the type
   *
   * @param amenity
   * @param value
   */
  public void setAmenityVisibility(com.jibestream.jibestreamandroidlibrary.elements.Amenity
                                           amenity, boolean value) {
    int index = Arrays.asList(venueData.amenities).indexOf(amenity);
    setAmenityVisibility(index, value);
  }

  /**
   * Sets the visibilty of the type
   *
   * @param index
   * @param newValue
   */
  public void setAmenityVisibility(int index, boolean newValue) {
    Message message = handlerUpdate.obtainMessage(SET_AMENITIES_VISIBILITY, index, newValue ? 1 : 0);
    handlerUpdate.sendMessage(message);
  }

  private void _setAmenityVisibility(int index, boolean newValue) {
    if (0 <= index && index < amenitiesVisibility.length) {
      boolean oldValue = amenitiesVisibility[index];
      if (newValue == oldValue) return;
      amenitiesVisibility[index] = newValue;

      synchronized (lockElementList) {
        final int size = elementList.size();
        for (int i = 0; i < size; i++) {
          Element element = elementList.get(i);
          if (element instanceof Amenity) {
            Amenity amenity = (Amenity) element;
            if (amenity.amenityComponent == venueData.amenities[index]) {
              element.setVisible(newValue);
            }
          }
        }
      }
      LocalBroadcastManager.getInstance(context).sendBroadcast(new IntentAmenities(mID, venueData.amenities[index], index, oldValue, newValue));
    }
  }
//</editor-fold>

//<editor-fold desc="-------------------------------------          Camera">

  /**
   * Frames the map to the screen respecting the orientation that
   * already exists
   */
  public void cameraToMap() {
    RectF viewBox = floorViewboxes[currentMapIndex];
    camera.zoomTo(viewBox);
  }

  /**
   * Frames the path on the current level and returns true if a path exist on the current level.
   * if no path exist it just returns false.
   *
   * @return boolean
   */
  public boolean cameraToPath() {
    synchronized (lockPathPerFloor) {
      if (pathForCurrentFloor == null || pathForCurrentFloor.mapId != currentMap.map.mapId)
        return false;
    }
    RectF rect = route.getBBox();
    if (rect == null) return false;
// Converting rect to square
    int mm = (int) (Math.max(rect.width(), rect.height()) / 2f);
    RectF r = new RectF();
    r.left = rect.centerX() - mm;
    r.top = rect.centerY() - mm;
    r.right = rect.centerX() + mm;
    r.bottom = rect.centerY() + mm;
    camera.zoomTo(r, mm);
    return true;
  }

  /**
   * Frames a Unit and returns true if the operation succeeds.
   *
   * @param destinationID
   * @return if the operation was successful
   */
  public boolean cameraToUnit(int destinationID) {
    synchronized (lockElementList) {
      Unit unit;
      final int sizeEl = elementList.size();
      for (int i = 0; i < sizeEl; i++) {
        Element element = elementList.get(i);
        if (!(element instanceof Unit)) continue;
        unit = ((Unit) element);
        final Destination[] destinations = unit.getDestinations();
        if (destinations != null && destinations.length > 0) {
          for (int j = 0; j < destinations.length; j++) {
            Destination aDestination = destinations[j];
            if (aDestination == null) continue;
            if (aDestination.id == destinationID) {
              RectF rect = unit.getBBox();
              if (rect == null) return false;
              if (rect.width() == 0 || rect.height() == 0) return false;
// Converting rect to square
              int mm = (int) (Math.max(rect.width(), rect.height()) / 2f);
              RectF r = new RectF();
              r.left = rect.centerX() - mm;
              r.top = rect.centerY() - mm;
              r.right = rect.centerX() + mm;
              r.bottom = rect.centerY() + mm;
              camera.zoomTo(r, mm);
              return true;
            }
          }
        }
      }
    }
    return false;
  }

//</editor-fold>

//<editor-fold desc="-------------------------------------          Waypoint">

//<editor-fold desc="getWaypointWithID">

  /**
   * Get a {@link Waypoint} from its id
   *
   * @param id
   * @return
   */

  public Waypoint getWaypointWithID(int id) {
    Waypoint[] waypoints = venueData.waypoints;
    final int length = waypoints.length;
    for (int i = 0; i < length; i++) {
      Waypoint waypoint = waypoints[i];
//    Log.d("test", "id = " + waypoint.id);
//    Log.d("test", "localId = " + waypoint.localId);
//    Log.d("test", "mapId = " + waypoint.mapId);
//    Log.d("test", "unitNumber = " + waypoint.unitNumber);
      if (id == waypoint.id) {
        return waypoint;
      }
    }
    return null;
  }

  public void getWaypointWithID(int id, CallbackWaypoint callbackDWaypoint) {
    final Message message = handlerUpdate.obtainMessage(GET_WAYPOINT, id, -1, callbackDWaypoint);
    handlerUpdate.sendMessage(message);
  }

  private void getWaypointWithID(Message message) {
    int id = message.arg1;
    CallbackWaypoint callbackDWaypoint = (CallbackWaypoint) message.obj;
    callbackDWaypoint.callback(getWaypointWithID(id));
  }
//</editor-fold>

//<editor-fold desc="getWaypointsOfDestination">

  /**
   * Get array of {@link Waypoint} for a destination
   *
   * @param destination
   * @return array of all waypoints associated to the destination
   */
  public Waypoint[] getWaypointsOfDestination(Destination destination) {
    if (destination == null) return null;
    return getWaypointsOfDestination(destination.id);
  }

  /**
   * Get array of {@link Waypoint} for a destination
   *
   * @param destinationID
   * @return array of all waypoints associated to the destination
   */
  public Waypoint[] getWaypointsOfDestination(int destinationID) {
    if (destinationID < 0) return null;
    ArrayList<Waypoint> WaypointArrayList = new ArrayList<>();
    Waypoint[] waypoints = venueData.waypoints;
    final int lengthWPs = waypoints.length;
    for (int i = 0; i < lengthWPs; i++) {
      Waypoint waypoint = waypoints[i];
      if (waypoint.associations == null) continue;
      WaypointEntityLink[] associations = waypoint.associations;
      final int lengthAss = associations.length;
      for (int j = 0; j < lengthAss; j++) {
        WaypointEntityLink waypointEntityLink = associations[j];
        if (waypointEntityLink.entityTypeId == WaypointEntityLink.EntityTypeID_Destination) {
          if (waypointEntityLink.entityId == destinationID) {
            WaypointArrayList.add(waypoint);
          }
        }
      }
    }
    Waypoint[] array = WaypointArrayList.toArray(new Waypoint[WaypointArrayList.size()]);
    return array;
  }

  public void getWaypointsOfDestination(int destinationID, CallbackWaypoints
          callbackWaypoints) {
    final Message message = handlerUpdate.obtainMessage(GET_WAYPOINTS_OF_DESTINATION, destinationID, -1, callbackWaypoints);
    handlerUpdate.sendMessage(message);
  }

  private void getWaypointsOfDestination(Message message) {
    int destinationID = message.arg1;
    CallbackWaypoints callbackWaypoints = (CallbackWaypoints) message.obj;
    callbackWaypoints.callback(getWaypointsOfDestination(destinationID));
  }
//</editor-fold>

//<editor-fold desc="getWaypointsOfAmenity">

  /**
   * Get array of {@link Waypoint} for a given amenity
   *
   * @param amenity
   * @return array of all waypoints associated to the amenity
   */
  public Waypoint[] getWaypointsOfAmenity
  (com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity amenity) {
    return getWaypointsOfAmenity(amenity.bean.componentId);
  }

  public Waypoint[] getWaypointsOfAmenity(int amenityBeanComponentID) {
    if (amenityBeanComponentID < 0) return null;
    ArrayList<Waypoint> WaypointArrayList = new ArrayList<>();
    Waypoint[] waypoints = venueData.waypoints;
    final int length = waypoints.length;
    for (int i = 0; i < length; i++) {
      Waypoint waypoint = waypoints[i];
      if (waypoint.associations == null) continue;
      for (WaypointEntityLink waypointEntityLink : waypoint.associations) {
        if (waypointEntityLink.entityTypeId == WaypointEntityLink.EntityTypeID_Amenity) {
          if (waypointEntityLink.entityId == amenityBeanComponentID) {
            WaypointArrayList.add(waypoint);
          }
        }
      }
    }
    Waypoint[] array = WaypointArrayList.toArray(new Waypoint[WaypointArrayList.size()]);
    return array;
  }

  public void getWaypointsOfAmenity
          (com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity
                   amenity, CallbackWaypoints callbackWaypoints) {
    getWaypointsOfAmenity(amenity.bean.componentId, callbackWaypoints);
  }

  public void getWaypointsOfAmenity(int amenityBeanComponentID, CallbackWaypoints
          callbackWaypoints) {
    final Message message = handlerUpdate.obtainMessage(GET_WAYPOINTS_OF_AMENITY, amenityBeanComponentID, -1, callbackWaypoints);
    handlerUpdate.sendMessage(message);
  }

  private void getWaypointsOfAmenity(Message message) {
    int amenityBeanComponentID = message.arg1;
    final CallbackWaypoints callbackWaypoints = (CallbackWaypoints) message.obj;
    callbackWaypoints.callback(getWaypointsOfAmenity(amenityBeanComponentID));
  }

//</editor-fold>

//<editor-fold desc="findClosestWaypoint">

  /**
   * Finds the closest waypoint to the
   * provided x and y values.
   * Domain value`s accordingly to initial svg map
   * coordinates. If level is not specified engines
   * last level will be used.
   *
   * @param x
   * @param y
   * @param atLevel Floor level to look for waypoint.
   * @return
   */
  public Waypoint findClosestWaypoint(float x, float y, MapFull atLevel) {
    atLevel = atLevel == null ? getCurrentMap() : atLevel;
    float closestWaypointDistance = Float.MAX_VALUE;
    Waypoint closestWaypoint = null;
    Waypoint[] waypoints = atLevel.waypoints;
    final int length = waypoints.length;
    for (int i = 0; i < length; i++) {
      Waypoint aWaypoint = waypoints[i];
      float xx = (float) (aWaypoint.x - x);
      float yy = (float) (aWaypoint.y - y);
      float d = (float) Math.sqrt(xx * xx + yy * yy);
      if (d < closestWaypointDistance) {
        closestWaypoint = aWaypoint;
        closestWaypointDistance = d;
      }
    }
    if (closestWaypoint != null) {
      return closestWaypoint;
    }
    return null;
  }

  public void findClosestWaypoint(float x, float y, MapFull atLevel, CallbackWaypoint
          callbackWaypoint) {
    final Message message = handlerUpdate.obtainMessage(FIND_CLOSEST_WAYPOINT_XY);
    final Bundle data = new Bundle();
    data.putFloat("x", x);
    data.putFloat("y", y);
    data.putParcelable("mapFull", atLevel);
    message.setData(data);
    message.obj = callbackWaypoint;
    handlerUpdate.sendMessage(message);
  }

  private void findClosestWaypoint(Message message) {
    final Bundle data = message.getData();
    final float x = data.getFloat("x");
    final float y = data.getFloat("y");
    final MapFull mapFull = data.getParcelable("mapFull");
    final CallbackWaypoint callbackWaypoint = (CallbackWaypoint) message.obj;
    callbackWaypoint.callback(findClosestWaypoint(x, y, mapFull));
  }
//</editor-fold>

//<editor-fold desc="getClosestWaypointOfAmenityTypeID">

  public void getClosestWaypointOfAmenityTypeID(Waypoint from, int typeID, CallbackWaypoint
          callbackWaypoint) {
    final Message message = handlerUpdate.obtainMessage(GET_CLOSEST_WAYPOINT_OF_AMENITY_TYPE_ID);
    final Bundle bundle = new Bundle();
    bundle.putParcelable("from", from);
    message.setData(bundle);
    message.arg1 = typeID;
    message.obj = callbackWaypoint;
  }

  private void getClosestWaypointOfAmenityTypeID(Message message) {
    final Waypoint from = message.getData().getParcelable("from");
    CallbackWaypoint callbackWaypoint = (CallbackWaypoint) message.obj;
    int typeID = message.arg1;
    callbackWaypoint.callback(getClosestWaypointOfAmenityTypeID(from, typeID));
  }

  /**
   * finds the closest Amenity Type relative to the from Waypoint
   *
   * @param from   Waypoint
   * @param typeID
   * @return Returns waypoint or null
   */
  public Waypoint getClosestWaypointOfAmenityTypeID(Waypoint from, int typeID) {
    if (from == null) return null;

    com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity amenityWithID = getAmenityByID(typeID);
    Waypoint[] waypointsOfAmenity = getWaypointsOfAmenity(amenityWithID);
    float closest = Float.MAX_VALUE;
    Waypoint closestWaypoint = null;
    final int length = waypointsOfAmenity.length;
    synchronized (lockPathPerFloor) {
      for (int i = 0; i < length; i++) {
        Waypoint wp = waypointsOfAmenity[i];
        PathPerFloor[] pathPerFloors = wayfind(from, wp);
        if (pathPerFloors == null) continue;
        if (pathPerFloors.length == 0) continue;
        float cost = pathPerFloors[pathPerFloors.length - 1].cost;
        if (cost < closest) {
          closest = cost;
          closestWaypoint = wp;
        }
      }
      return closestWaypoint;
    }
  }

//</editor-fold>

//<editor-fold desc="wayfindToClosestAmenity">

  public void wayfindToClosestAmenity(int typeID, CallbackWaypoint callbackWaypoint) {
    final Message message = handlerUpdate.obtainMessage(WAYFIND_TO_CLOSEST_AMENITY, typeID, -1, callbackWaypoint);
    handlerUpdate.sendMessage(message);
  }

  private void wayfindToClosestAmenity(Message message) {
    final CallbackWaypoint callbackWaypoint = (CallbackWaypoint) message.obj;
    callbackWaypoint.callback(wayfindToClosestAmenity(message.arg1));
  }

  /**
   * Sets the setToWaypoint to the closest amenity
   * of the specified type.
   *
   * @param typeID
   * @return closest waypoint or null
   */
  private Waypoint wayfindToClosestAmenity(int typeID) {
    Waypoint closestWaypoint = getClosestWaypointOfAmenityTypeID(fromWaypoint, typeID);
    if (closestWaypoint != null) {
      setToWaypoint(closestWaypoint);
    }
    return closestWaypoint;
  }
//</editor-fold>

//<editor-fold desc="getWaypointsWithZone">

  public void getWaypointsWithZone(Zone zone, CallbackWaypoints callbackWaypoints) {
    Message message = handlerUpdate.obtainMessage(GET_WAYPOINTS_WITH_ZONE);
    final Bundle bundle = new Bundle();
    bundle.putParcelable("zone", zone);
    message.setData(bundle);
    message.obj = callbackWaypoints;
    handlerUpdate.sendMessage(message);
  }

  private void getWaypointsWithZone(Message message) {
    final Bundle bundle = message.getData();
    final Zone zone = bundle.getParcelable("zone");
    CallbackWaypoints callbackWaypoints = (CallbackWaypoints) message.obj;
    final ArrayList<Waypoint> waypointsWithZone = getWaypointsWithZone(zone);
    Waypoint[] waypoints = new Waypoint[waypointsWithZone.size()];
    waypointsWithZone.toArray(waypoints);
    callbackWaypoints.callback(waypoints);
  }

  /**
   * Get the waypoint associated with the provided zone.
   *
   * @param zone
   * @return
   */
  public ArrayList<Waypoint> getWaypointsWithZone(Zone zone) {
    return getWaypointsWithZone(zone.zoneId);
  }

  /**
   * Get the waypoint associated with the provided zone ID.
   *
   * @param zoneID
   * @return
   */
  public ArrayList<Waypoint> getWaypointsWithZone(int zoneID) {
    ArrayList<Waypoint> wps = new ArrayList<>();
    Waypoint[] waypoints = venueData.waypoints;
    final int length = waypoints.length;
    for (int i = 0; i < length; i++) {
      Waypoint waypoint = waypoints[i];
      if (waypoint == null) continue;
      if (waypoint.zoneId == zoneID) {
        wps.add(waypoint);
      }
    }
    return wps;
  }
//</editor-fold>

//</editor-fold>

//<editor-fold desc="-------------------------------------          DESTINATIONS">

//<editor-fold desc="getDestinationByID">

  /**
   * Retrieve the {@link Destination} from its id
   *
   * @param id
   * @return
   */
  public Destination getDestinationByID(int id) {
    Destination[] destinations = venueData.destinations;
    final int length = destinations.length;
    for (int i = 0; i < length; i++) {
      Destination destination = destinations[i];
      if (destination == null) continue;
      if (id == destination.id) {
        return destination;
      }
    }
    return null;
  }

  public void getDestinationByID(int id, CallbackDestination callbackDestination) {
    final Message message = handlerUpdate.obtainMessage(GET_DESTINATION_BY_ID, id, -1, callbackDestination);
    handlerUpdate.sendMessage(message);
  }

  private void getDestinationByID(Message message) {
    final int id = message.arg1;
    final CallbackDestination callbackDestination = (CallbackDestination) message.obj;
    callbackDestination.callback(getDestinationByID(id));
  }
//</editor-fold>

//<editor-fold desc="getDestinationsOfProximities">

  /**
   * Get the destination objects found on the {@link DestinationProximity} field from a given destination
   *
   * @param destination
   * @return array of all Destination associated with the DestinationProximity
   */
  public Destination[] getDestinationsOfProximities(Destination destination) {
    if (destination == null) return null;
    final DestinationProximity[] destinationProximities = destination.destinationProximities;
    if (destinationProximities == null) return null;
    final int length = destinationProximities.length;
    if (length == 0) return null;
    ArrayList<Destination> destinationArrayList = new ArrayList<>();
    for (int i = 0; i < length; i++) {
      DestinationProximity destinationProximity = destinationProximities[i];
      if (destinationProximity.clientDestinationId == null) continue;
      final Destination destinationWithID = getDestinationByID(destinationProximity.destinationId);
      if (destinationWithID != null) {
        destinationArrayList.add(destinationWithID);
      }
    }
    Destination[] array = destinationArrayList.toArray(new Destination[destinationArrayList.size()]);
    return array;
  }

  public void getDestinationsOfProximities(Destination destination, CallbackDestinations
          callbackDestinations) {
    final Message message = handlerUpdate.obtainMessage(GET_DESTINATIONS_OF_PROXIMITYS);
    final Bundle bundle = new Bundle();
    message.setData(bundle);
    bundle.putParcelable("destination", destination);
    message.obj = callbackDestinations;
    handlerUpdate.sendMessage(message);
  }

  private void getDestinationsOfProximities(Message message) {
    final Bundle bundle = message.getData();
    Destination destination = bundle.getParcelable("destination");
    CallbackDestinations callbackDestinations = (CallbackDestinations) message.obj;
    callbackDestinations.callback(getDestinationsOfProximities(destination));
  }
//</editor-fold>

//<editor-fold desc="getDestinationsByQuery">

  /**
   * searches all destination`s names,keywords and categories
   * Using a query string this method will search through all the destinations those destination's keywords to find the appropriate results.
   *
   * @param query
   * @param maxResults
   * @return An array of destination objects.
   */
  public ArrayList<Destination> getDestinationsByQuery(String query, int maxResults) {
    if (maxResults <= 0) maxResults = Integer.MAX_VALUE;

    ArrayList<Destination> results;
    String[] querySplitBySpaces = query.split(" ");
    ArrayList<Pattern> loosePatters = new ArrayList<>();
    HashMap<Integer, ArrayList<Destination>> patternMatchResults = new HashMap<>();
    ArrayList<Destination> matchHigh = new ArrayList<>();
    ArrayList<Destination> keyMatchHigh = new ArrayList<>();
    ArrayList<Destination> matchLow = new ArrayList<>();
    ArrayList<Destination> keyMatchLow = new ArrayList<>();
    Pattern searchPattern = Pattern.compile(query.toUpperCase());

    for (int i = 0; i < querySplitBySpaces.length; i++) {
      loosePatters.add(Pattern.compile(querySplitBySpaces[i].toUpperCase()));
    }

    //Destination matching code

    //First query test matches full destination name with spaces
    for (int i = 0; i < venueData.destinations.length; i++) {
      Destination destination = venueData.destinations[i];
      int searchIndex = -1;

      Matcher matcher = searchPattern.matcher(destination.name.toUpperCase());
      if (matcher.find()) {
        searchIndex = matcher.regionStart();
      }
      int bestKeywordIndex = 5000;
      int perfectMatchScore = 0;

      final String[] keywordsArray = destination.keywords.split(",");
      for (int j = 0; j < loosePatters.size(); j++) {
        for (int k = 0; k < keywordsArray.length; k++) {
          int keyIndex = -1;
          Matcher matcher1 = loosePatters.get(j).matcher(keywordsArray[k].toUpperCase());
          if (matcher1.find()) {
            keyIndex = matcher.regionStart();
          }
          if (keyIndex > -1) {
            if (bestKeywordIndex > keyIndex) {
              bestKeywordIndex = keyIndex;
            }
            if (keyIndex == 0) {
              perfectMatchScore++;
            }
          }
        }
      }

      if (searchIndex == 0) {
        matchHigh.add(destination);
      } else if (bestKeywordIndex == 0) {
        if (patternMatchResults.get(perfectMatchScore) == null) {
          patternMatchResults.put(perfectMatchScore, new ArrayList<Destination>());
        }
        patternMatchResults.get(perfectMatchScore).add(destination);
        keyMatchHigh.add(destination);
      } else if (searchIndex >= 0) {
        matchLow.add(destination);
      } else if (bestKeywordIndex != 5000) {
        keyMatchLow.add(destination);
      }
    }

    results = matchHigh;

    SortedSet<Integer> keys = new TreeSet<>(patternMatchResults.keySet());
    for (int key : keys) {
      ArrayList<Destination> aDestination = patternMatchResults.get(key);
      if (results.size() < maxResults) {
        results.addAll(aDestination);
      }
    }

    results = new ArrayList<>(results.subList(0, Math.min(results.size(), maxResults)));

    //Tests if the minimum length requirement has been met. If not, continues with a search against lower levels
    if (results.size() < maxResults) {
      results.addAll(matchLow);
      results = new ArrayList<>(results.subList(0, Math.min(results.size(), maxResults)));
      if (results.size() < maxResults) {
        results.addAll(keyMatchLow);
        results = new ArrayList<>(results.subList(0, Math.min(results.size(), maxResults)));
      }
    }
    return results;
  }

  public void getDestinationsByQuery(String query, int maxResults, CallbackDestinations
          callbackDestinations) {
    final Message message = handlerUpdate.obtainMessage(GET_DESTINATIONS_BY_QUERY);
    message.obj = callbackDestinations;
    final Bundle bundle = new Bundle();
    bundle.putString("query", query);
    bundle.putInt("maxResults", maxResults);
    message.setData(bundle);
    handlerUpdate.sendMessage(message);
  }

  private void getDestinationsByQuery(Message message) {
    final Bundle bundle = message.getData();
    String query = bundle.getString("query");
    int maxResults = bundle.getInt("maxResults");
    CallbackDestinations callbackDestinations = (CallbackDestinations) message.obj;
    final ArrayList<Destination> destinationsByQuery = getDestinationsByQuery(query, maxResults);
    Destination[] destinations = destinationsByQuery.toArray(new Destination[destinationsByQuery.size()]);
    callbackDestinations.callback(destinations);
  }
//</editor-fold>

//<editor-fold desc="getDestinationsOfWaypoint">

  /**
   * Get destinations given waypointId
   */
  public Destination[] getDestinationsByWpId(Integer wpId) {
    Waypoint wp = getWaypointWithID(wpId);
    return getDestinationsOfWaypoint(wp);
  }

  /**
   * Get destination given waypointId
   */
  public void getDestinationsByWpId(Integer wpId, CallbackDestinations callbackDestinations) {
    Waypoint wp = getWaypointWithID(wpId);
    getDestinationsOfWaypoint(wp, callbackDestinations);
  }

  /**
   * Get array of {@link Destination} for a given waypoint
   *
   * @param waypoint
   * @return array of destinations associated to the waypoint
   */
  public Destination[] getDestinationsOfWaypoint(Waypoint waypoint) {
    if (waypoint == null) return null;
    ArrayList<Destination> destinationsArrayList = new ArrayList<>();
    if (waypoint.associations == null) return null;
    WaypointEntityLink[] associations = waypoint.associations;
    final int length = associations.length;
    for (int i = 0; i < length; i++) {
      WaypointEntityLink waypointEntityLink = associations[i];
      if (waypointEntityLink.entityTypeId == WaypointEntityLink.EntityTypeID_Destination) {
        if (waypointEntityLink.waypointId == waypoint.id) {
          Destination destination = getDestinationByID(waypointEntityLink.entityId);
          destinationsArrayList.add(destination);
        }
      }
    }
    Destination[] array = destinationsArrayList.toArray(new Destination[destinationsArrayList.size()]);
    return array;
  }

  public void getDestinationsOfWaypoint(Waypoint waypoint, CallbackDestinations
          callbackDestinations) {
    Message message = handlerUpdate.obtainMessage(GET_DESTINATIONS_OF_WAYPOINT);
    message.obj = callbackDestinations;
    final Bundle bundle = new Bundle();
    bundle.putParcelable("waypoint", waypoint);
    message.setData(bundle);
    handlerUpdate.sendMessage(message);
  }

  private void getDestinationsOfWaypoint(Message message) {
    Waypoint waypoint = message.getData().getParcelable("waypoint");
    CallbackDestinations callbackDestinations = (CallbackDestinations) message.obj;
    callbackDestinations.callback(getDestinationsOfWaypoint(waypoint));
  }
//</editor-fold>

//<editor-fold desc="getDestinationsByClientId">

  /**
   * Get destination by client id
   */
  public Destination[] getDestinationsByClientId(String clientId) {
    ArrayList<Destination> foundDestinations = new ArrayList<>();
    final Destination[] destinationsDO = venueData.destinations;
    final int length = destinationsDO.length;
    for (int i = 0; i < length; i++) {
      final Destination destination = destinationsDO[i];
      if (destination == null) continue;
      if (destinationsDO[i].clientId == clientId) {
        foundDestinations.add(destination);
      }
    }
    final Destination[] destinations = new Destination[foundDestinations.size()];
    foundDestinations.toArray(destinations);
    return destinations;
  }

  public void getDestinationsByClientId(String clientId, CallbackDestinations
          callbackDestinations) {
    final Message message = handlerUpdate.obtainMessage(GET_DESTINATIONS_BY_CLIENT_ID);
    final Bundle bundle = new Bundle();
    bundle.putString("clientId", clientId);
    message.setData(bundle);
    message.obj = callbackDestinations;
    handlerUpdate.sendMessage(message);
  }

  private void getDestinationsByClientId(Message message) {
    final Bundle bundle = message.getData();
    CallbackDestinations callbackDestinations = (CallbackDestinations) message.obj;
    final String clientId = bundle.getString("clientId");
    callbackDestinations.callback(getDestinationsByClientId(clientId));
  }
//</editor-fold>

//<editor-fold desc="getDestinationsByCategoryId">

  /**
   * Get destinations given category id
   */
  public Destination[] getDestinationsByCategoryId(Integer catId) {
    ArrayList<Destination> foundDestinations = new ArrayList<>();
    Destination[] destinations = venueData.destinations;
    final int lengthD = destinations.length;
    for (int i = 0; i < lengthD; i++) {
      Destination d = destinations[i];
      int[] categoryId = d.categoryId;
      final int length = categoryId.length;
      for (int j = 0; j < length; j++) {
        Integer category = categoryId[j];
        if (category == catId) {
          foundDestinations.add(d);
        }
      }
    }
    final Destination[] destinationsArr = new Destination[foundDestinations.size()];
    foundDestinations.toArray(destinationsArr);
    return destinationsArr;
  }

  public void getDestinationsByCategoryId(Integer catId, CallbackDestinations
          callbackDestinations) {
    final Message message = handlerUpdate.obtainMessage(GET_DESTINATIONS_BY_CATEGORY_ID);
    message.obj = callbackDestinations;
    message.arg1 = catId;
    handlerUpdate.sendMessage(message);
  }

  public void getDestinationsByCategoryId(Message message) {
    CallbackDestinations callbackDestinations = (CallbackDestinations) message.obj;
    Integer catId = message.arg1;
    callbackDestinations.callback(getDestinationsByCategoryId(catId));
  }
//</editor-fold>

  //<editor-fold desc="getDestinationsByZone">
  public Destination[] getDestinationsByZone(Zone zone) {
    ArrayList<Destination> destinations = new ArrayList<>();
    ArrayList<Waypoint> waypointsWithZone = getWaypointsWithZone(zone);
    for (int i = 0; i < waypointsWithZone.size(); i++) {
      Waypoint waypoint = waypointsWithZone.get(i);
      Destination[] destinationsOfWaypoint = getDestinationsOfWaypoint(waypoint);
      final int length = destinationsOfWaypoint.length;
      for (int j = 0; j < length; j++) {
        Destination destination = destinationsOfWaypoint[j];
        destinations.add(destination);
      }
    }
    final Destination[] destinationsArray = new Destination[destinations.size()];
    destinations.toArray(destinationsArray);
    return destinationsArray;
  }

  public void getDestinationsByZone(Zone zone, CallbackDestinations callbackDestinations) {
    final Message message = handlerUpdate.obtainMessage(GET_DESTINATIONS_BY_ZONE);
    final Bundle bundle = new Bundle();
    bundle.putParcelable("zone", zone);
    message.setData(bundle);
    message.obj = callbackDestinations;
    handlerUpdate.sendMessage(message);
  }

  private void getDestinationsByZone(Message message) {
    final CallbackDestinations callbackDestinations = (CallbackDestinations) message.obj;
    final Bundle data = message.getData();
    final Zone zone = data.getParcelable("zone");
    callbackDestinations.callback(getDestinationsByZone(zone));
  }
//</editor-fold>

//</editor-fold>

//<editor-fold desc="-------------------------------------          AMENITIES">

//<editor-fold desc="getAmenityByID">

  /**
   * Get a {@link com.jibestream.jibestreamandroidlibrary.elements.Amenity} from its id
   *
   * @param id
   * @return
   */
  public com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity getAmenityByID
  (int id) {
    com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[] amenities = venueData.amenities;
    final int length = amenities.length;
    for (int i = 0; i < length; i++) {
      com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity amenity = amenities[i];
      if (null == amenity.bean) continue;
      if (id == amenity.bean.componentId) {
        return amenity;
      }
    }
    return null;
  }

  public void getAmenityByID(int id, CallbackAmenity callbackAmenity) {
    final Message message = handlerUpdate.obtainMessage(GET_AMENITIES_OF_WAYPOINT, id, -1, callbackAmenity);
    handlerUpdate.sendMessage(message);
  }

  public void getAmenityByID(Message message) {
    int id = message.arg1;
    CallbackAmenity callbackAmenity = (CallbackAmenity) message.obj;
    callbackAmenity.callback(getAmenityByID(id));
  }
//</editor-fold>

//<editor-fold desc="getAmenitiesOfWaypoint">

  /**
   * Get array of {@link com.jibestream.jibestreamandroidlibrary.elements.Amenity} for a given waypoint
   *
   * @param waypoint
   * @return array of amenities associated to the waypoint
   */
  public com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[] getAmenitiesOfWaypoint
  (Waypoint waypoint) {
    if (waypoint == null) return null;
    ArrayList<com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity> amenitiesArrayList = new ArrayList<>();
    if (waypoint.associations == null) return null;
    WaypointEntityLink[] associations = waypoint.associations;
    final int length = associations.length;
    for (int i = 0; i < length; i++) {
      WaypointEntityLink waypointEntityLink = associations[i];
      if (waypointEntityLink.entityTypeId == WaypointEntityLink.EntityTypeID_Amenity) {
        if (waypointEntityLink.waypointId == waypoint.id) {
          com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity amenity = getAmenityByID(waypointEntityLink.entityId);
          amenitiesArrayList.add(amenity);
        }
      }
    }
    final com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[] amenities = new com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[amenitiesArrayList.size()];
    com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[] amenitiesArray = amenitiesArrayList.toArray(amenities);
    return amenitiesArray;
  }

  public void getAmenitiesOfWaypoint(Waypoint waypoint, CallbackAmenities callbackAmenities) {
    final Message message = handlerUpdate.obtainMessage();
    message.obj = callbackAmenities;
    final Bundle bundle = new Bundle();
    bundle.putParcelable("waypoint", waypoint);
    message.setData(bundle);
    handlerUpdate.sendMessage(message);
  }

  private void getAmenitiesOfWaypoint(Message message) {
    Waypoint waypoint = message.getData().getParcelable("waypoint");
    CallbackAmenities callbackAmenities = (CallbackAmenities) message.obj;
    callbackAmenities.callback(getAmenitiesOfWaypoint(waypoint));
  }
//</editor-fold>

//</editor-fold>

//<editor-fold desc="-------------------------------------          Zone">

//<editor-fold desc="getZoneByID">

  public Zone getZoneByID(int id) {
    Zone[] zones = venueData.zones;
    final int length = zones.length;
    for (int i = 0; i < length; i++) {
      Zone zone = zones[i];
      if (id == zone.zoneId) {
        return zone;
      }
    }
    return null;
  }

  public void getZoneByID(int id, CallbackZone callbackZone) {
    final Message message = handlerUpdate.obtainMessage(GET_ZONE_BY_ID, id, -1, callbackZone);
    handlerUpdate.sendMessage(message);
  }

  public void getZoneByID(Message message) {
    CallbackZone callbackZone = (CallbackZone) message.obj;
    final int id = message.arg1;
    final Zone zoneWithID = getZoneByID(id);
    callbackZone.callback(zoneWithID);
  }

//</editor-fold>

//</editor-fold>

//<editor-fold desc="-------------------------------------          Elements">

//<editor-fold desc="getElementByID">

  public Element getElementByID(int id) {
    Element element;
    int size;
    synchronized (lockElementsForCurrentLevelUpdate) {
      size = elementsForCurrentLevelUpdate.length;
      for (int l = 0; l < size; l++) {
        element = elementsForCurrentLevelUpdate[l];
        if (element.id == id) {
          return element;
        }
      }
    }
    //
    synchronized (lockElementList) {
      size = elementList.size();
      for (int k = 0; k < size; k++) {
        element = elementList.get(k);
        if (element.id == id) {
          return element;
        }
      }
    }
    return null;

  }

  public void getElementByID(int id, CallbackElement callbackElement) {
    final Message message = handlerUpdate.obtainMessage(GET_ELEMENT_BY_ID);
    message.obj = callbackElement;
    message.arg1 = id;
    handlerUpdate.sendMessage(message);
  }

  private void getElementByID(Message message) {
    final int id = message.arg1;
    final CallbackElement callbackElement = (CallbackElement) message.obj;
    callbackElement.callback(getElementByID(id));
  }

//</editor-fold>

//<editor-fold desc="setSelectionStateByType">

  /**
   * Sets the selection state of all the elements of class type
   *
   * @param aClass
   * @param state
   * @return an Array of Elements
   */
  public Element[] setSelectionStateByType(Class aClass, boolean state) {
    ArrayList<Element> elements = new ArrayList<>();
    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (!aClass.isInstance(element)) continue;
        if (!element.isSelectable()) continue;
        elements.add(element);
        element.setSelectState(state);
      }
      final Element[] elementsArray = new Element[elements.size()];
      elements.toArray(elementsArray);
      return elementsArray;
    }
  }

  public void setSelectionStateByType(Class aClass, boolean state, CallbackElements
          callbackElements) {
    final Message message = handlerUpdate.obtainMessage(SET_SELECTION_STATE_BY_TYPE);
    message.obj = new Object[]{aClass, state, callbackElements};
    handlerUpdate.sendMessage(message);
  }

  private void setSelectionStateByType(Message message) {
    final Object[] array = (Object[]) message.obj;
    final Class aClass = (Class) array[0];
    final boolean state = (boolean) array[1];
    final CallbackElements callbackElements = (CallbackElements) array[2];
    final Element[] elements = setSelectionStateByType(aClass, state);
    if (callbackElements != null) callbackElements.callback(elements);
  }
//</editor-fold>

//<editor-fold desc="getElementsByType">

  /**
   * Gets all elements of type
   *
   * @param aClass
   * @return
   */
  public Element[] getElementsByType(Class aClass) {
    ArrayList<Element> elements = new ArrayList<>();
    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element == null) continue;
        if (!aClass.isInstance(element)) continue;
        elements.add(element);
      }
    }
    final Element[] elementsArray = new Element[elements.size()];
    elements.toArray(elementsArray);
    return elementsArray;
  }

  public void getElementsByType(Class aClass, CallbackElements callbackElements) {
    final Message message = handlerUpdate.obtainMessage(GET_ELEMENTS_BY_TYPE);
    final Object[] objects = {aClass, callbackElements};
    message.obj = objects;
    handlerUpdate.sendMessage(message);
  }

  private void getElementsByType(Message message) {
    final Object[] objs = (Object[]) message.obj;
    Class aClass = (Class) objs[0];
    CallbackElements callbackElements = (CallbackElements) objs[1];
    final Element[] elementsByType = getElementsByType(aClass);
    callbackElements.callback(elementsByType);
  }
//</editor-fold>

  //<editor-fold desc="getElementsOfDestination">
  public Element[] getElementsOfDestination(int destinationID) {
    Unit unit;
    com.jibestream.jibestreamandroidlibrary.elements.Amenity amenity;
    ArrayList<Element> elements = new ArrayList<>();

    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element instanceof Unit) {
          unit = ((Unit) element);
          final Destination[] destinations = unit.getDestinations();
          if (destinations != null && destinations.length > 0) {
            for (int j = 0; j < destinations.length; j++) {
              Destination aDestination = destinations[j];
              if (aDestination == null) continue;
              if (aDestination.id == destinationID) {
                elements.add(element);
              }
            }
          }
        } else if (element instanceof Amenity) {
          amenity = ((Amenity) element);
          final Waypoint waypoint = amenity.waypoint;
          final Destination[] destinationsOfWaypoint = getDestinationsOfWaypoint(waypoint);
          for (int k = 0; k < destinationsOfWaypoint.length; k++) {
            final Destination destination = destinationsOfWaypoint[k];
            if (destination == null) continue;
            if (destinationID == destination.id) {
              elements.add(element);
            }
          }
        }
      }
    }
    final Element[] elementsArray = new Element[elements.size()];
    elements.toArray(elementsArray);
    return elementsArray;
  }

  public void getElementsOfDestination(int destinationID, CallbackElements
          callbackElements) {
    final Message message = handlerUpdate.obtainMessage(GET_ELEMENTS_OF_DESTINATION);
    message.arg1 = destinationID;
    message.obj = callbackElements;
    handlerUpdate.sendMessage(message);
  }

  private void getElementsOfDestination(Message message) {
    int destinationID = message.arg1;
    final Element[] elements = getElementsOfDestination(destinationID);
    CallbackElements callbackElements = (CallbackElements) message.obj;
    callbackElements.callback(elements);
  }
//</editor-fold>

//<editor-fold desc="getElementsByKeyValue">

  /**
   * Returns an array with all Elements that match an attributes key-value name.
   * Synchronous function.
   *
   * @param key   the key to search for.
   * @param value the value to match, if null all elements that match key will be returned.
   * @return Element[] with matching key value.
   */
  public Element[] getElementsByKeyValue(String key, @Nullable String value) {
    ArrayList<Element> elements = new ArrayList<>();
    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element.attributes.containsKey(key)) {
          if (value == null) {
            elements.add(element);
            continue;
          } else {
            String aValue = element.attributes.get(key);
            if (aValue.equalsIgnoreCase(value)) {
              elements.add(element);
            }
          }
        }
      }
    }
    final Element[] elementsArray = new Element[elements.size()];
    elements.toArray(elementsArray);
    return elementsArray;
  }

  /**
   * Asynchronous method of {@link M#getElementsByKeyValue(String, String, CallbackElements)}
   *
   * @param key
   * @param value
   * @param callbackElements
   */
  public void getElementsByKeyValue(String key, String value, @Nullable CallbackElements callbackElements) {
    final Message message = handlerUpdate.obtainMessage(GET_ELEMENTS_BY_KEY_VALUE);
    message.obj = new ElementsByKeyValue(key, value, callbackElements);
    handlerUpdate.sendMessage(message);
  }

  private void getElementsByKeyValue(Message message) {
    ElementsByKeyValue elementsByKeyValue = (ElementsByKeyValue) message.obj;
    String key = elementsByKeyValue.key;
    String value = elementsByKeyValue.value;
    final Element[] elements = getElementsByKeyValue(key, value);
    CallbackElements callbackElements = elementsByKeyValue.callbackElements;
    if (callbackElements != null) callbackElements.callback(elements);
  }

  private static class ElementsByKeyValue {
    public String key;
    public String value;
    public CallbackElements callbackElements;

    public ElementsByKeyValue(String key, String value, CallbackElements callbackElements) {
      this.key = key;
      this.value = value;
      this.callbackElements = callbackElements;
    }
  }
//</editor-fold>

//</editor-fold>

//<editor-fold desc="-------------------------------------          Unit">

  public Unit[] getUnitsWithZone(Zone zone) {
    ArrayList<Unit> units = new ArrayList<>();

    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element instanceof Unit) {
          Unit unit = ((Unit) element);
          Waypoint[] waypoints = unit.getWaypoints();
          if (waypoints == null) continue;
          if (waypoints.length == 0) continue;
          for (Waypoint waypoint : waypoints) {
            if (waypoint == null) continue;
            if (waypoint.zoneId == zone.zoneId) {
              units.add(unit);
            }
          }
        }
      }
    }
    final Unit[] unitsArray = new Unit[units.size()];
    units.toArray(unitsArray);
    return unitsArray;
  }

  /**
   * Set highlight state on all units with passed Destination ID
   *
   * @param id
   * @param state
   * @return an ArrayList of Unit class
   */
  public Unit[] setHighlightOnUnitsByDestinationID(int id, boolean state) {

    ArrayList<Unit> units = new ArrayList<>();
    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (!element.isHighlightable()) continue;
        if (element instanceof Unit) {
          Unit unit = ((Unit) element);
          final Destination[] destinations = unit.getDestinations();
          if (destinations == null) continue;
          for (Destination aDestination : destinations) {
            if (aDestination == null) continue;
            if (aDestination.id == id) {
              units.add(unit);
              unit.setHighlightState(state);
            }
          }
        }
      }
    }
    final Unit[] unitsArray = new Unit[units.size()];
    units.toArray(unitsArray);
    return unitsArray;
  }

  /**
   * highlight all units with passed Category
   *
   * @param categoryToHighlight
   * @return all highlighted units
   */
  public Unit[] highlightUnitsByCategory(Category categoryToHighlight) {
    ArrayList<Unit> units = new ArrayList<>();
    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element instanceof Unit) {
          Unit unit = ((Unit) element);
          if (unit.getDestinations() == null) continue;
          if (unit.getDestinations().length == 0) continue;
          if (!unit.isHighlightable()) continue;
          for (Destination destination : unit.getDestinations()) {
            if (destination == null) continue;
            if (destination.categoryId == null) continue;
            for (int categoryId : destination.categoryId) {
              if (categoryId == categoryToHighlight.id) {
                units.add(unit);
                unit.setHighlightState(true);
              }
            }
          }
        }
      }
    }
    final Unit[] unitsArray = new Unit[units.size()];
    units.toArray(unitsArray);
    return unitsArray;
  }

  public Unit[] highlightUnitsByZone(Zone zone) {
    Unit[] unitsWithZone = getUnitsWithZone(zone);
    final int length = unitsWithZone.length;
    for (int i = 0; i < length; i++) {
      Unit unit = unitsWithZone[i];
      unit.setHighlightState(true);
    }
    return unitsWithZone;
  }

  public Unit[] getUnitsByDestination(Destination destination) {
    ArrayList<Unit> units = new ArrayList<>();
    synchronized (lockElementList) {
      final int size = elementList.size();
      for (int i = 0; i < size; i++) {
        Element element = elementList.get(i);
        if (element == null) continue;
        if (!(element instanceof Unit)) continue;
        Unit unit = ((Unit) element);
        final Destination[] destinations = unit.getDestinations();
        if (destinations == null || destinations.length == 0) continue;
        for (Destination aDest : destinations) {
          if (aDest.id == destination.id) {
            units.add(unit);
          }
        }
      }
      final Unit[] unitsArray = new Unit[units.size()];
      units.toArray(unitsArray);
      return unitsArray;
    }
  }

//</editor-fold>

//<editor-fold desc="-------------------------------------          DestinationLabel">

  /**
   * Get destination labels given floor Id
   */
  public DestinationLabel[] getDestinationLabelsByFloor(Integer mapId) {
    for (MapFull map : venueData.maps) {
      if (map.map.mapId == mapId) {
        return map.destinationLabels;
      }
    }
    return null;
  }

//</editor-fold>

//<editor-fold desc="-------------------------------------          Category">

  /**
   * Get all categories by Id
   */
  public ArrayList<Category> getCategoriesById(String categoryId) {
    ArrayList<Category> foundCategories = new ArrayList<>();
    for (Category c : venueData.categories) {
      if (c.clientCategoryId == categoryId) {
        foundCategories.add(c);
      }
    }
    return foundCategories;
  }


//</editor-fold>

//<editor-fold desc="-------------------------------------          MapLabel">

  /**
   * Get map labels given floor Id
   */
  public MapLabel[] getMapLabelsByFloorId(Integer mapId) {
    for (MapFull map : venueData.maps) {
      if (map.map.mapId == mapId) {
        return map.mapLabels;
      }
    }
    return null;
  }
//</editor-fold>

//<editor-fold desc="-------------------------------------          HELPERS">

  private RectF getRectOfClassesInstances(CallbackRectF callbackRectF, Class[] classes,
                                          int mapIndex) {
    RectF region = new RectF();
    synchronized (lockElementList) {
      for (Element element : elementList) {
        if (element == null) continue;
        if (element.getLevel() != mapIndex) continue;
        final RectF bBox = new RectF(element.getBBox());
        if (bBox == null) continue;
        for (int i = 0; i < classes.length; i++) {
          final Class aClass = classes[i];
          if (aClass.isInstance(element)) {
            region.union(bBox);
          }
        }
      }
    }
    if (callbackRectF != null) callbackRectF.callback(region);
    return region;
  }

  /**
   * find the bounds of all instances on the specified level
   * associated from the passed classes names and
   * returns the union operation of them
   *
   * @param classes
   * @param mapIndex
   * @return
   */
  public RectF getRectOfClassesInstances(Class[] classes, int mapIndex) {
    RectF region = new RectF();
    synchronized (lockElementList) {
      for (Element element : elementList) {
        if (element == null) continue;
        if (element.getLevel() != mapIndex) continue;
        final RectF bBox = new RectF(element.getBBox());
        if (bBox == null) continue;
        for (int i = 0; i < classes.length; i++) {
          final Class aClass = classes[i];
          if (element.getClass() == aClass) {
            region.union(bBox);
          }
        }
      }
    }
    return region;
  }

  /**
   * Sets the highlighted state of all elements of class type
   *
   * @param aClass
   * @param state
   */
  public void setHighlightStateByType(Class aClass, boolean state) {
    synchronized (lockElementList) {
      for (int i = 0; i < elementList.size(); i++) {
        Element element = elementList.get(i);
        if (aClass.isInstance(element)) {
          element.setHighlightState(state);
        }
      }
    }
  }

  /**
   * Sets selection state of all units to false
   */
  public void deselectUnits() {
    setSelectionStateByType(Unit.class, false);
  }

  /**
   * Sets highlight state of units to false
   */
  public void unHighlightUnits() {
    setHighlightStateByType(Unit.class, false);
  }

  /**
   * Sets selection state of all amenities to false
   */
  public void deselectAmenities() {
    setSelectionStateByType(com.jibestream.jibestreamandroidlibrary.elements.Amenity.class, false);
  }

  /**
   * Sets highlight state of all elements to false
   */
  public void deslectAll() {
    setSelectionStateByType(Element.class, false);
  }

  /**
   * Utility fn to transform a matrix from map space to view space.
   *
   * @param matrix the matrix transformation in window space
   *               <pre>
   *                                                                                                                                                                                                                                                                                                       {@code
   *                                                                                                                                                                                                                                                                                                       Matrix transformation = new Matrix();
   *                                                                                                                                                                                                                                                                                                       transformation.preTranslate(1000,1000);
   *                                                                                                                                                                                                                                                                                                       transformation.preRotate(90);
   *                                                                                                                                                                                                                                                                                                       transformation.preScale(0.25f,0.25f);
   *                                                                                                                                                                                                                                                                                                       Matrix matrix = m.fromMapSpaceToWindowSpace(transformation);
   *                                                                                                                                                                                                                                                                                                       float transX = MatrixUtils.getTransX(matrix);
   *                                                                                                                                                                                                                                                                                                       float transY = MatrixUtils.getTransY(matrix);
   *                                                                                                                                                                                                                                                                                                       float scl = MatrixUtils.getScaleX(matrix);
   *                                                                                                                                                                                                                                                                                                       float rotDgrs = MatrixUtils.getRotDgrs(matrix);
   *                                                                                                                                                                                                                                                                                                       aView.setX(transX);
   *                                                                                                                                                                                                                                                                                                       aView.setY(transY);
   *                                                                                                                                                                                                                                                                                                       aView.setScaleX(scl);
   *                                                                                                                                                                                                                                                                                                       aView.setScaleY(scl);
   *                                                                                                                                                                                                                                                                                                       aView.setRotation(rotDgrs);
   *                                                                                                                                                                                                                                                                                                       }
   *                                                                                                                                                                                                                                                                                                       </pre>
   */
  public Matrix fromMapSpaceToWindowSpace(@NonNull Matrix matrix) {
    if (matrix == null) return null;
    Matrix mtx = new Matrix(camera.getMatrix());
    mtx.preConcat(matrix);
    float r = 1f / engineView.getScaleFactor();
    mtx.postScale(r, r);
    return mtx;
  }

//</editor-fold>

  //<editor-fold desc="-------------------------------------          BOOTSTRAP">
  private void boostrap(Runnable runnable) {
    initiateAmenetiesVisibilityArray();
    parseMapsAndPopulate();
    massageLabels();
    massageUnits();
    parseDestinationLabels();
    populateDestinationLabel();
    populateMapLabels();
    parseMovers();
    addRouteElement();
    populateKiosksInstances();
//  populateMoverInstances();
    populateAmenitiesInstances();
    addWayfindElements();
    parseConfig();
    setInitialLevel();
    doZones();
    doOnCreates();
    _setElementsOfCurrentLevel();
    setMapsDefaultFraming(runnable);
    camera.setContentSize(floorViewboxes[currentMapIndex]);
    _update();
  }

  //<editor-fold desc="-------------------------------------   Boostrap fns">
  private void initiateAmenetiesVisibilityArray() {
    boolean[] inital = new boolean[venueData.amenities.length];
    Arrays.fill(inital, true);
    setAmenitiesVisibility(inital);
  }

  /**
   * Parse svgs from all levels
   * Populate display list
   * add all maps.elements to the display list while populating the level it belongs to.
   * set each object`s parent as the mapParent object.
   */
  private void parseMapsAndPopulate() {
    // init arrays
    int totalMaps = venueData.maps.length;
    floorViewboxes = new RectF[totalMaps];
//  ArrayList<Element> bake = null;
    for (int i = 0; i < totalMaps; i++) {
      MapFull mapFull = venueData.maps[i];
      String svgDOM = mapFull.svg;
      if (svgDOM == null || svgDOM.isEmpty()) {
        continue;
      }
      svgDOM = svgDOM.replaceAll("_x002D_", "-");// replace _x002D_ with  dashes to keep consistency with config
      SVGParser.ParsedSVG parsedSVG = null;
      parsedSVG = SVGParser.parseMaps(svgDOM, this);
      for (int j = 0; j < parsedSVG.elements.size(); j++) {
        Element element = parsedSVG.elements.get(j);
        element.setLevel(i);
        elementList.add(element);
      }
      floorViewboxes[i] = parsedSVG.viewBox;
      //Store the styles without overriding
      for (RenderStyle renderStyle : parsedSVG.renderStyles) {
        cssStyles.setRenderStyle(renderStyle.name, renderStyle, false);
      }
      // assign styles accordingly to the elements class name
      for (Element element : parsedSVG.elements) {
        String cssClass = element.classNameCSS;
        // Check if css class exists and if, apply.
        if (cssClass != null) {
          RenderStyle renderStyle = cssStyles.getRenderStyle(cssClass);
          if (renderStyle != null && element instanceof ElementMap) {
            ((ElementMap) element).setStyleIdle(renderStyle);
          }
        }
      }
//      mapFull.map.elements = new ArrayList<>();
//      bake = new ArrayList<>();
//      for (int i = 0; i < parsedSVG.elements.size(); i++) {
//        Element element = parsedSVG.elements.start(i);
//        if (
//            element instanceof Background ||
//            element instanceof StreetMajor ||
//                element instanceof StreetMinor ||
//                element instanceof StreetSmallAlley
//            ) {
//          bake.add(element);
//        } else {
//          mapFull.map.elements.add(element);
//        }
//      }
    }
  }

  /**
   * Populate LabelBoxes with its destination objs
   * or delete them if no destination  exists
   */
  private void massageLabels() {
    synchronized (lockElementList) {
      for (int i = 0; i < elementList.size(); i++) {
        Element element = elementList.get(i);
        if (element != null && element instanceof UnitLabel) {
          UnitLabel unitLabel = (UnitLabel) element;
          int[] destinationIDs = unitLabel.getDestinationIDs();
          if (destinationIDs == null || destinationIDs.length == 0) {
            element.setShape(null);
          } else {
            final ArrayList<Destination> destinationsList = new ArrayList<>();
            for (int destinationId : destinationIDs) {
              for (Destination destination : venueData.destinations) {
                if (destination.id == destinationId) {
                  destinationsList.add(destination);
                  break;
                }
              }
            }
            final int size = destinationsList.size();
            if (size == 0) {
              element.setShape(null);
            } else {
              Collections.sort(destinationsList, new Comparator<Destination>() {
                @Override
                public int compare(Destination lhs, Destination rhs) {
                  if (lhs.sponsoredRating == rhs.sponsoredRating)
                    return 0;
                  return (rhs.sponsoredRating - lhs.sponsoredRating);
                }
              });
              Destination[] destinationsArray = new Destination[size];
              destinationsList.toArray(destinationsArray);
              unitLabel.setDestinations(destinationsArray);
              unitLabel.setText(destinationsList.get(0).name);
//        unitLabel.setText(destinationsList.get(0).name + " " + destinationsList.get(0).sponsoredRating);
            }
          }
        }
      }
    }
  }

  /**
   * start waypoints[] and destinations[] on all
   * Elements that are selectable and of type "Unit"
   */
  private void massageUnits() {
    synchronized (lockElementList) {
      for (Element element : elementList) {
        if (!element.isSelectable()) continue;
        if (!(element instanceof Unit)) continue;
        Unit unit = (Unit) element;
        //  destinations[]
        if (unit.getDestinationIDs() != null) {
          int lengthOfdestinationIDs = unit.getDestinationIDs().length;
          if (lengthOfdestinationIDs != 0) {
            Destination[] unitsDestinations = new Destination[lengthOfdestinationIDs];
            int j = 0;
            for (int destinationID : unit.getDestinationIDs()) {
              unitsDestinations[j] = getDestinationByID(destinationID);
              j++;
            }
            unit.setDestinations(unitsDestinations);
          }
        }
        //  waypoints[]
        if (unit.getWaypointIDs() != null) {
          int lengthOfWaypointIDs = unit.getWaypointIDs().length;
          if (lengthOfWaypointIDs != 0) {
            Waypoint[] objects2DDOWaypoints = new Waypoint[lengthOfWaypointIDs];
            int j = 0;
            for (int waypointID : unit.getWaypointIDs()) {
              objects2DDOWaypoints[j] = getWaypointWithID(waypointID);
              j++;
            }
            unit.setWaypoints(objects2DDOWaypoints);
          }
        }
      }
    }
  }

  private void parseDestinationLabels() {
    for (MapFull mapFull : venueData.maps) {
      if (mapFull.mapLabels == null) continue;
      for (DestinationLabel destinationLabel : mapFull.destinationLabels) {

        final String filePathSVG = destinationLabel.iconSVGDOM;
        if (filePathSVG == null) continue;
        try {
          final SVGParser.ParsedSVG parsedSVG = SVGParser.parseIcon(filePathSVG);
          final List<Element> elements = parsedSVG.elements;
          if (elements == null || elements.size() == 0) continue;
          final IconShape iconShape = (IconShape) elements.get(0).getShape();
          iconShape.width = parsedSVG.viewBox.width();
          iconShape.height = parsedSVG.viewBox.height();
          String key = Integer.toString(GUID.get());
          iconShapeLib.setIcon(key, iconShape);
          destinationLabel.iconShapeLibKey = key;
        } catch (XmlPullParserException e) {
          e.printStackTrace();
        } catch (IOException e) {
          e.printStackTrace();
        }

      }
    }
  }

  /**
   * Populate MapLabels
   */
  private void populateDestinationLabel() {
    int level = 0;
    for (MapFull mapFull : venueData.maps) {
      if (mapFull.mapLabels == null) continue;
      for (DestinationLabel destinationLabel : mapFull.destinationLabels) {
        com.jibestream.jibestreamandroidlibrary.elements.DestinationLabel destinationLabelElement = new com.jibestream.jibestreamandroidlibrary.elements.DestinationLabel();
        destinationLabelElement.setLabelName(destinationLabel.localizedText);
//      destinationLabelElement.setBitmap(destinationLabel.iconBitmap);
        destinationLabelElement.setIconShape(iconShapeLib.getIcon(destinationLabel.iconShapeLibKey));
        destinationLabelElement.setVisible(true);
        destinationLabelElement.setLevel(level);
        destinationLabelElement.getTransform().setTranslationX(destinationLabel.locationX);
        destinationLabelElement.getTransform().setTranslationY(destinationLabel.locationY);
        destinationLabelElement.getTransform().setRotation(destinationLabel.rotation);
        elementList.add(destinationLabelElement);
      }
      level++;
    }

  }

  /**
   * Populate MapLabels
   */
  private void populateMapLabels() {
    // TODO: 15-07-15 Bellow is proper behaviour uncomment after cms update
//  int level = 0;
//  for (MapFull mapFull : maps) {
//    if (mapFull.mapLabels == null) continue;
//    for (MapLabel mapLabelComponent : mapFull.mapLabels) {
//      com.jibestream.jibestreamandroidlibrary.elements.MapLabel mapLabel = new com.jibestream.jibestreamandroidlibrary.elements.MapLabel();
//      mapLabel.setLabelName(mapLabelComponent.localizedText);
//      mapLabel.setVisible(true);
//      mapLabel.level = level;
//      mapLabel.getTransform().setTranslationX(mapLabelComponent.locationX);
//      mapLabel.getTransform().setTranslationY(mapLabelComponent.locationY);
//      mapLabel.getTransform().setRotation(mapLabelComponent.rotation);
//      mapsParent.addChild(mapLabel.getTransform());
//      getElements().add(mapLabel);
//    }
//    level++;
//  }

    int level = 0;
    ArrayList<MapLabel> map_labels = new ArrayList<>();

    for (MapFull mapFull : venueData.maps) {
      Collections.addAll(map_labels, mapFull.mapLabels);
    }

    for (MapFull mapFull : venueData.maps) {
      for (MapLabel mapLabelComponent : map_labels) {
        com.jibestream.jibestreamandroidlibrary.elements.MapLabel mapLabel = new com.jibestream.jibestreamandroidlibrary.elements.MapLabel();
        mapLabel.setLabelName(mapLabelComponent.localizedText);
        mapLabel.setVisible(true);
        mapLabel.setLevel(level);
        mapLabel.getTransform().setTranslationX(mapLabelComponent.locationX);
        mapLabel.getTransform().setTranslationY(mapLabelComponent.locationY);
        mapLabel.getTransform().setRotation(mapLabelComponent.rotation);
        elementList.add(mapLabel);
      }
      level++;
    }
  }

  private void parseMovers() {

    final PathType[] pathTypes = venueData.pathTypes;
    int length = pathTypes.length;
    for (int i = 0; i < length; i++) {
      PathType pathType = pathTypes[i];
      final String filePathSVG = pathType.svgDOM;
      if (filePathSVG == null) continue;
      try {
        final SVGParser.ParsedSVG parsedSVG = SVGParser.parseIcon(filePathSVG);
        final List<Element> elements = parsedSVG.elements;
        if (elements == null || elements.size() == 0) continue;
        final IconShape iconShape = (IconShape) elements.get(0).getShape();
        iconShape.width = parsedSVG.viewBox.width();
        iconShape.height = parsedSVG.viewBox.height();
        iconShapeLib.setIcon(pathType.description, iconShape);
      } catch (XmlPullParserException e) {
        e.printStackTrace();
      } catch (IOException e) {
        e.printStackTrace();
      }

    }
  }

  /**
   * Adds a route to the element list
   */
  private void addRouteElement() {
    try {
      final Route route = (Route) classLib.routeClass.newInstance();
      this.route = route;
      elementList.add(route);
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
  }

  /**
   * Populate kiosks
   */
  private void populateKiosksInstances() {
    for (Waypoint waypoint : venueData.waypoints) {
      final WaypointEntityLink[] associations = waypoint.associations;
      if (associations == null) continue;
      for (int i = 0; i < associations.length; i++) {
        final WaypointEntityLink association = associations[i];
        if (association.entityTypeId == WaypointEntityLink.EntityTypeID_Device) {
          final int level = getLevelIndexOfWaypointWithID(waypoint.id);
          final WayfindKiosk wayfindKiosk;
          try {
            wayfindKiosk = (WayfindKiosk) classLib.wayfindKioskClass.newInstance();
            wayfindKiosk.setLevel(level);
            wayfindKiosk.getTransform().setTranslationX((float) waypoint.x);
            wayfindKiosk.getTransform().setTranslationY((float) waypoint.y);
            elementList.add(wayfindKiosk);
          } catch (InstantiationException e) {
            e.printStackTrace();
          } catch (IllegalAccessException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }

  private void populateMoverInstances() {
    for (com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Path path : venueData.paths) {
      final int type = path.type;
      if (type == PathType.PATH_TYPE_NORMAL_PATH) continue;
      for (int wpID : path.waypoints) {
        final Waypoint waypoint = getWaypointWithID(wpID);
        final int level = getLevelIndexOfWaypointWithID(waypoint.id);
        final ElementIcon elementIcon;
        elementIcon = new ElementIcon();
        elementIcon.setLevel(level);
        elementIcon.getTransform().setTranslationX((float) waypoint.x);
        elementIcon.getTransform().setTranslationY((float) waypoint.y);
        elementIcon.setShape(new Star());
        elementList.add(elementIcon);
        int size = venueData.pathTypes.length;
        for (int i = 0; i < size; i++) {
          final PathType pathType = venueData.pathTypes[i];
          if (pathType.pathTypeId == path.type) {
            IconShape iconShape = iconShapeLib.getIcon(pathType.typeName);
            elementIcon.setShape(iconShape);
            break;
          }
        }
      }
    }
  }

  /**
   * Populate display list with Amenties
   */
  private void populateAmenitiesInstances() {
    final com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity[] amenities = venueData.amenities;
    if (amenities == null) return;
    for (com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity amenityDO : amenities) {
      int level = 0;

      IShape shape = null;
      final String filePathSVG = amenityDO.bean.filePathSVG;
      if (filePathSVG == null) continue;
      try {
        final SVGParser.ParsedSVG parsedSVG = SVGParser.parseIcon(filePathSVG);
        final List<Element> elements = parsedSVG.elements;
        if (elements == null || elements.size() == 0) continue;
        shape = elements.get(0).getShape();
      } catch (XmlPullParserException e) {
        e.printStackTrace();
      } catch (IOException e) {
        e.printStackTrace();
      }

      for (MapFull mapFull : venueData.maps) {
        for (Waypoint waypoint : amenityDO.waypoints) {
          if (waypoint.mapId == mapFull.map.mapId) {
//          Amenity amenity = null;
//          try {
//            final SVGParser svgParser = new SVGParser(amenityDO.bean.filePathSVG);
//            final Element element = svgParser.elements.start(0);
//            final IShape shape = element.getShape();
//            final Element am = new Element();
//            asetHeadsUp(true);
//            asetConstantScale(true);
//            asetSelectable(true);
//            agetTransform().setScaleOffset(3);
//            asetStyleIdle(CssStyles.getDefaultSelecation());
//            asetShape(shape);
//            asetLevel(level);
//            agetTransform().setTranslationX(waypoint.x);
//            agetTransform().setTranslationY(waypoint.y);
//            mapsParent.addChild(agetTransform());
//            elementList.add(am);
//          } catch (XmlPullParserException e) {
//            e.printStackTrace();
//          } catch (IOException e) {
//            e.printStackTrace();
//          }
            if (shape == null) continue;
            try {
              Amenity amenity = (Amenity) classLib.amenityClass.newInstance();
              amenity.setShape(shape);
              amenity.amenityComponent = amenityDO;
              amenity.waypoint = waypoint;
              amenity.setLevel(level);
              amenity.getTransform().setTranslationX((float) waypoint.x);
              amenity.getTransform().setTranslationY((float) waypoint.y);
              elementList.add(amenity);

            } catch (InstantiationException e) {
              e.printStackTrace();
            } catch (IllegalAccessException e) {
              e.printStackTrace();
            }
          }
        }
        level++;
      }
    }
  }

  /**
   * Add elements needed wayfinding
   */
  private void addWayfindElements() {
    try {
      final UserLocation userLocation = (UserLocation) classLib.userLocationClass.newInstance();
      this.userLocation = userLocation;
      userLocation.setVisible(false);
      elementList.add(userLocation);
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
    try {
      final YouAreHere youAreHere = (YouAreHere) classLib.youAreHereClass.newInstance();
      this.youAreHere = youAreHere;
      elementList.add(youAreHere);
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
    try {
      final Mover moverA = (Mover) classLib.moverHeadClass.newInstance();
      this.moverA = moverA;
      elementList.add(moverA);
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
    try {
      final Mover moverB = (Mover) classLib.moverTailClass.newInstance();
      this.moverB = moverB;
      elementList.add(moverB);
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
    try {
      final Pin pin = (Pin) classLib.pinClass.newInstance();
      this.pin = pin;
      elementList.add(pin);
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
  }

  /**
   * Configuration for SvgParsing
   */
  private void parseConfig() {
    if (configJsonInputString == null || configJsonInputString.isEmpty()) return;
    // delete redundant "-Layer" on name
    configJsonInputString = configJsonInputString.replaceAll("-Layer", "");
    ConfigDO configDO;
    Gson gson = new Gson();
    try {
      configDO = gson.fromJson(configJsonInputString, ConfigDO.class);
    } catch (JsonSyntaxException e) {
      e.printStackTrace();
      return;
    }
    // hide types according to field exportStyles
    ExportStyles.setVisibility(configDO.mapStyles.exportStyles, this);
    // Create styles
    final ConfigStyleDO[] mapLayers = configDO.mapStyles.mapLayers;
    for (ConfigStyleDO configStyleDO : mapLayers) {
      if (configStyleDO == null) continue;
      final RenderStyle renderStyle = ConfigStyleDO.getRenderStyle(configStyleDO, this);
      if (renderStyle != null) {
        cssStyles.setRenderStyle(configStyleDO.name, renderStyle, true);
      }
    }
  }

  /**
   * The level the user is currently or
   * the default one
   */
  private void setInitialLevel() {
    Device[] devices = venueData.devices;
    if (devices != null) {
      for (Device device : devices) {
        if (device.deviceTypeId == 4) {
          final int componentId = device.id;
          for (Waypoint waypoint : venueData.waypoints) {
            if (waypoint.associations != null) {
              for (WaypointEntityLink associationConverted : waypoint.associations) {
                if (componentId == associationConverted.entityId) {
                  final int index = getLevelsIndexWithMapID(waypoint.mapId);
                  final MapFull map = venueData.maps[index];
                  defaultMap = map;
                  currentMap = map;
                  currentMapIndex = index;
                  return;
                }
              }
            }
          }
        }
      }
    }
    MapFull mapAtWhichUserIsLocated = getDefaultMap();
    if (mapAtWhichUserIsLocated == null) {
      mapAtWhichUserIsLocated = venueData.maps[0];
    }
    defaultMap = mapAtWhichUserIsLocated;
    currentMap = mapAtWhichUserIsLocated;
    currentMapIndex = 0;
  }

  private void doZones() {
    if (venueData.zones == null) return;
    if (venueData.zones.length == 0) return;
    for (Waypoint waypoint : venueData.waypoints) {
      for (Zone zone : venueData.zones) {
        if (zone.zoneId == waypoint.zoneId) {
          waypoint.zone = zone;
          continue;
        }
      }
    }
  }

  private void doOnCreates() {
    Element element;
    int size;
    synchronized (lockElementList) {
      size = elementList.size();
      for (int i = 0; i < size; i++) {
        element = elementList.get(i);
        element.onCreate(context, this, 0, 0, camera);
        element.onUpdate(this, 0, 0, 0, camera);
        element.onPreRender(this, 0, 0, 0, camera);
      }
    }
  }

  private void setMapsDefaultFraming(final Runnable runnable) {
    final int length = venueData.maps.length;
    defaultFramings = new RectF[length];
    final int[] totalRectsWatting = {0};
    for (int i = 0; i < length; i++) {
      final int finalI = i;
      getRectOfClassesInstances(new CallbackRectF() {
        @Override
        public void callback(RectF rectF) {
          totalRectsWatting[0]++;
          rectF.inset(-100, -100);
          defaultFramings[finalI] = rectF;
          if (totalRectsWatting[0] == length) {
            runnable.run();
          }
        }
      }, new Class[]{Unit.class, ParkingLot.class}, i);
    }
  }

//</editor-fold>

//</editor-fold>
}


