package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar;

import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapFull;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Path;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.PathType;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;

import java.util.ArrayList;
import java.util.List;

public class ASGrid {
public final float verticalScale = 100;
public Waypoint[] waypoints;
public Path[] paths;
public PathType[] pathTypes;
public MapFull[] mapFulls;
public List<ASNode> nodes;
public List<ASEdge> edges;

public ASGrid(Waypoint[] waypoints, Path[] paths, PathType[] pathTypes, MapFull[] mapFulls) {
  this.waypoints = waypoints;
  this.paths = paths;
  this.pathTypes = pathTypes;
  this.mapFulls = mapFulls;
  init();
}

private void init() {
  nodes = new ArrayList<>();
  edges = new ArrayList<>();
  for (int i = 0; i < waypoints.length; i++) {
//    if(waypoints[i].decisionPoint != 0) console.log(waypoints[i]);
    ASEdge[] edges = generateEdges(waypoints[i].id);
    Neighbor[] neighbors = generateNeighbors(waypoints[i].id, edges);
    ASNode node = new ASNode(waypoints[i].id, waypoints[i].x, waypoints[i].y, getMapZValue(waypoints[i].mapId), waypoints[i].decisionPoint, waypoints[i].mapId, edges, neighbors);
    nodes.add(node);
  }
}

private Path[] getPathsWithWaypoint(int wpid) {
  List<Path> pathsReturn = new ArrayList<>();
  for (int i = 0; i < paths.length; i++) {
    for (int j = 0; j < paths[i].waypoints.length; j++) {
      if (paths[i].waypoints[j] == wpid) {
        pathsReturn.add(paths[i]);
      }
    }
  }
  Path[] array = pathsReturn.toArray(new Path[pathsReturn.size()]);
  return array;
}

private Waypoint getWPById(int wpid) {
  for (int i = 0; i < waypoints.length; i++) {
    if (waypoints[i].id == wpid) return waypoints[i];
  }
  return null;
}

private ASEdge[] generateEdges(int wpid) {
  Path[] paths = getPathsWithWaypoint(wpid);
  ArrayList<ASEdge> returnArray = new ArrayList<>();
  for (int i = 0; i < paths.length; i++) {
    if(paths[i].status != 0) {
      PathType pathType = getPathTypeById(paths[i].type);
      ASEdge edge = new ASEdge(paths[i].id, paths[i].waypoints, paths[i].type, pathType.weight, pathType.accessibility, pathType.speed, paths[i].direction);
      returnArray.add(edge);
    }
  }
  ASEdge[] array = returnArray.toArray(new ASEdge[returnArray.size()]);
  return array;
}

private Neighbor[] generateNeighbors(int wpid, ASEdge[] edges) {
  List<Neighbor> neighbors = new ArrayList<>();
  Waypoint srcWP = getWPById(wpid);
  Point srcWPPos = new Point(srcWP.x, srcWP.y, getMapZValue(srcWP.mapId));
  for (int i = 0; i < edges.length; i++) {
    ASEdge currentEdge = edges[i];


    for (int j = 0; j < currentEdge.nodes.length; j++) {
      if (currentEdge.nodes[j] == wpid) continue;
      Waypoint currentWP = getWPById(currentEdge.nodes[j]);
      Point wpStart = new Point(currentWP.x, currentWP.y, getMapZValue(currentWP.mapId));

      double distance = heuristic(wpStart, srcWPPos);

      int floorPref = 1;
      if (srcWPPos.z == wpStart.z) {
        floorPref = getFloorPreferenceMultiplier(currentWP.mapId);
      } else {
        if(currentEdge.direction != 0) {
          if(currentEdge.direction == 1) {
            if(srcWPPos.z > wpStart.z) continue;
          } else if (currentEdge.direction == 2) {
            if(srcWPPos.z < wpStart.z) continue;
          }
        }
      }
      float totalCost = (float) (((distance * currentEdge.cost) * floorPref) * ((Math.abs(wpStart.z - srcWPPos.z) / currentEdge.speed)+1f));

      Neighbor neighbor = new Neighbor(currentWP, currentEdge, totalCost, (float) distance, (float) wpStart.z);

      neighbors.add(neighbor);
    }
  }


  Neighbor[] array = neighbors.toArray(new Neighbor[neighbors.size()]);
  return array;
}

private int getFloorPreferenceMultiplier(int mapid) {
  int currentMultiplier = 1;
  if (mapFulls != null) {
    int currentPref = 0;
    for (int i = 0; i < mapFulls.length; i++) {
      if (mapFulls[i].map.mapId == mapid) {
//        if (mapFulls[i].map.preference == null) break;
        if (mapFulls[i].map.preference == 0) {
          currentMultiplier = 1;
        } else if (mapFulls[i].map.preference > 0) {
          currentMultiplier = currentMultiplier / (mapFulls[i].map.preference + 1);
        } else if (mapFulls[i].map.preference < 0) {
          currentMultiplier = currentMultiplier * (Math.abs(mapFulls[i].map.preference) + 1);
        }
        break;
      }
    }
  }

  return currentMultiplier;
}

private float getMapZValue(int mapId) {
  float v = 0;
  for (int i = 0; i < mapFulls.length; i++) {
    if (mapFulls[i].map.mapId == mapId) {
      v = (mapFulls[i].map.floorSequence * verticalScale);
      return v;
    }
  }

  return v;
}

private double heuristic(Point start, Point end) {
  return Math.sqrt(Math.pow((start.x - end.x), 2) + Math.pow((start.y - end.y), 2) + Math.pow((start.z - end.z), 2));
}

/**
 * Resets grid nodes
 * old cleanGrid fn
 */
public void reset(){
  for(int i = 0; i < nodes.size(); i++) {
    nodes.get(i).reset();
  }
}


public ASNode getNodeById(int id) {
  for(int i = 0; i < nodes.size(); i++) {
    if(id == nodes.get(i).id) return nodes.get(i);
  }
  return null;
}


public ASNode getNeighborNodeObject(int id) {
  for (int i = 0; i < nodes.size(); i++) {
    if (id == nodes.get(i).id) return nodes.get(i);
  }
  return null;
}

public PathType getPathTypeById(int pathTypeId) {
  for (int i = 0; i < pathTypes.length; i++) {
    if (pathTypes[i].pathTypeId == pathTypeId) {
      return pathTypes[i];
    }
  }
  return null;
}
}
