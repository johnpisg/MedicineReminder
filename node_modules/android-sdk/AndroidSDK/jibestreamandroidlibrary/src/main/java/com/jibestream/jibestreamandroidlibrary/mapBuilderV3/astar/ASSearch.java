package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar;

import android.os.AsyncTask;
import android.util.Log;

import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;

import org.apache.commons.collections.buffer.PriorityBuffer;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ASSearch {
public interface IASSearchResponse {
  void aStarSearchResponse(PathPerFloor[] pathPerFloors);
}

public static class ASSearchAsynch extends AsyncTask<Void, Void, PathPerFloor[]> {
  private final Waypoint fromWaypoint;
  private final Waypoint toWaypoint;
  private final int accessLevel;
  private final WeakReference<ASSearch> asSearch;
  private final IASSearchResponse response;

  public ASSearchAsynch(Waypoint fromWaypoint, Waypoint toWaypoint, int accessLevel, ASSearch asSearch, ASSearch.IASSearchResponse response) {
    this.fromWaypoint = fromWaypoint;
    this.toWaypoint = toWaypoint;
    this.accessLevel = accessLevel;
    this.asSearch = new WeakReference<>(asSearch);
    this.response = response;
  }

  @Override
  protected PathPerFloor[] doInBackground(Void... voids) {
    while (!isCancelled()) {
      return asSearch.get().search(fromWaypoint.id, toWaypoint.id, accessLevel);
    }
    return null;
  }

  @Override
  protected void onPostExecute(PathPerFloor[] result) {
    response.aStarSearchResponse(result);
  }
}

private static final String TAG = "ASSearch";
private ASGrid grid;

public ASSearch(ASGrid grid) {
  this.grid = grid;
}

/**
 * Main Search synchronous fn call this for wayfinding.
 *
 * @param from        WaypointID
 * @param to          WaypointID
 * @param accessLevel 0-99   pass in 50 | 100 :
 * @return PathPerFloor[]
 */
public PathPerFloor[] search(int from, int to, int accessLevel) {
  grid.reset();
  ASNode start = grid.getNodeById(from);
  ASNode end = grid.getNodeById(to);
  PriorityBuffer openStartHeap = new PriorityBuffer(new Comparator() {
    @Override
    public int compare(Object lhs, Object rhs) {
      float change1 = ((ASNode) lhs).f;
      float change2 = ((ASNode) rhs).f;
      return Float.compare(change1,change2);
    }
  });

  start.h = 0;
  openStartHeap.add(start);

  while (openStartHeap.size() > 0) {
    ASNode currentNode = (ASNode) openStartHeap.remove();

    if (currentNode.id == end.id) {
      return pathTo(currentNode, start);
    }

    currentNode.closed = true;

    for (int i = 0, il = currentNode.neighbors.length; i < il; ++i) {
      Neighbor neighbor = currentNode.neighbors[i];
      ASNode neighborNode = grid.getNeighborNodeObject(neighbor.id);

      if (neighbor.acc > accessLevel) {
        // console.log("BAD NEIGHBOR", neighbor.acc, accessLevel);
        continue;
      }

      if (neighborNode.closed) {
        continue;
      }

      float gScore = (currentNode.g + neighbor.cost);
      boolean beenVisited = neighborNode.visited;


      if (!beenVisited || gScore < neighborNode.g) {
        neighborNode.visited = true;
        neighborNode.parent = currentNode;
        neighborNode.h = 0;
        neighborNode.g = gScore;
        neighborNode.f = neighborNode.g;
        neighborNode.usedEdgeTypeId = neighbor.edgeTypeId;


        if (!beenVisited) {
          openStartHeap.add(neighborNode);
        } else {
          openStartHeap.remove(neighborNode);
          openStartHeap.add(neighborNode);
        }

      }

    }
  }

  return null;
}

private PathPerFloor[] pathTo(ASNode node, ASNode start) {
  ASNode curr = node;
  List<ASNode> path = new ArrayList<>();
  while (curr.parent != null) {
    path.add(curr);
    curr = curr.parent;
  }
  path.add(start);
  Collections.reverse(path);

  ArrayList<ASNode> currentFloor = new ArrayList<>();
  ArrayList<PathPerFloor> floorArray = new ArrayList<>();
  int currentFloorId = -1;
  for (int i = 0; i < path.size(); i++) {
    if (i == 0) {
      currentFloorId = path.get(i).mapId;
    }

    if (path.get(i).mapId != currentFloorId) {
      PathPerFloor pathPerFloor = new PathPerFloor();
      pathPerFloor.seq = (int) (path.get(i - 1).z / grid.verticalScale);
      pathPerFloor.mapId = currentFloorId;
      pathPerFloor.pathType = grid.getPathTypeById(path.get(i).usedEdgeTypeId);
//      pathPerFloor.points = (ASNode[]) currentFloor.clone();
      pathPerFloor.points = new ASNode[currentFloor.size()];
      pathPerFloor.cost = path.get(i).f;
      for (int j = 0; j < currentFloor.size(); j++) {
        ASNode asNode = currentFloor.get(j);
        pathPerFloor.points[j] = asNode.clone();
      }
      floorArray.add(pathPerFloor);
      currentFloor.clear();
    }
    currentFloorId = path.get(i).mapId;

    currentFloor.add(path.get(i));


    if (i == path.size() - 1 && i != 0) {
      PathPerFloor pathPerFloor = new PathPerFloor();
      pathPerFloor.seq = (int) (path.get(i - 1).z / grid.verticalScale);
      pathPerFloor.mapId = currentFloorId;
      pathPerFloor.pathType = grid.getPathTypeById(path.get(i).usedEdgeTypeId);
      pathPerFloor.points = new ASNode[currentFloor.size()];
      pathPerFloor.cost = path.get(i).f;
      for (int j = 0; j < currentFloor.size(); j++) {
        ASNode asNode = currentFloor.get(j);
        pathPerFloor.points[j] = asNode.clone();
      }
      floorArray.add(pathPerFloor);
    }
  }

  if (floorArray.size() > 0) {
    Log.d(TAG, "GOT PATH !");
  } else {
    Log.w(TAG, "NO PATH !");
    return null;
  }
  // cast to array
  PathPerFloor[] array = floorArray.toArray(new PathPerFloor[floorArray.size()]);
  // start android.graphics.Path field
//  for (PathPerFloor pathPerFloor : array) {
//    Path androidPath = new Path();
//    for (int i = 0; i < pathPerFloor.points.length; i++) {
//      ASNode asNode = pathPerFloor.points[i];
//      if (i == 0) {
//        androidPath.moveTo(asNode.x, asNode.y);
//      } else {
//        androidPath.lineTo(asNode.x, asNode.y);
//      }
//    }
//    pathPerFloor.setPath(androidPath);
//  }
  return array;
}


}
