package com.jibestream.jibestreamandroidlibrary.elements;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;

import com.jibestream.jibestreamandroidlibrary.main.Camera;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.math.Transform;
import com.jibestream.jibestreamandroidlibrary.shapes.Image;
import com.jibestream.jibestreamandroidlibrary.utils.Ninegrid;

/**
 * Created by gopal on 16-04-19.
 */
public class UserLocation extends ElementMap {
    // INPUTS
    private volatile float mConfidence = 100f;
    private volatile String outerPulseColor = "#3F87C7";
    private volatile String innerPulseColor = "#3F87C7";
    private volatile float confidenceAlpha = 0.6f;
    private volatile float startAlpha = 1f;
    private volatile float endAlpha = 1f;
    private volatile float imageAlpha = 1f;
    private volatile long pulseAnimationDuration = 1500;
    private volatile Bitmap imageIcon;
    private volatile long delayBetweenPulseCycles = 0;
    private volatile float image_scale = 1f;
    private volatile float mSpeed = 100f;
    // internal parameters
    private double multiplier = 0f;
    private long accumalator = 0;
    private Paint paintOC;
    private Paint paintIC;
    private Paint paintIm;
    private float max_radius;
    private float draw_radius = 0f;
    private boolean wait_flag = false;
    private float moveToX;
    private float moveToY;
    private volatile boolean isMoving = false;
    private Camera camera_last;
    private com.jibestream.jibestreamandroidlibrary.shapes.Image image;

    public UserLocation() {
        super();
        paintOC = new Paint();
        paintOC.setStyle(Paint.Style.FILL);
        paintOC.setColor(Color.parseColor(outerPulseColor));
        paintOC.setAlpha((int) (255 * confidenceAlpha));

        paintIC = new Paint();
        paintIC.setStyle(Paint.Style.FILL);
        paintIC.setColor(Color.parseColor(innerPulseColor));
        paintIC.setAlpha((int) (255 * startAlpha));

        paintIm = new Paint();
        paintIm.setDither(true);
        paintIm.setAntiAlias(true);
        paintIm.setAlpha((int) (255 * imageAlpha));
        max_radius = mConfidence;
    }

    private void calc() {
        max_radius = getConfidence();
    }

    public void setConfidence(float confidence) {
        mConfidence = confidence;
        calc();
    }

    public float getConfidence() {
        return mConfidence;
    }

    public void setOuterPulseColor(String color) {
        outerPulseColor = color;
        paintOC.setColor(Color.parseColor(color));
    }

    public String getOuterPulseColor() {
        return outerPulseColor;
    }

    public void setInnerPulseColor(String color) {
        innerPulseColor = color;
        paintIC.setColor(Color.parseColor(color));
    }

    public String getInnerPulseColor() {
        return innerPulseColor;
    }

    public void setConfidenceAlpha(float alpha) {
        confidenceAlpha = alpha;
        paintOC.setAlpha((int) (255 * alpha));
    }

    public float getConfidenceAlpha() {
        return confidenceAlpha;
    }

    public void setStartAlpha(float alpha) {
        startAlpha = alpha;
        endAlpha = alpha;
    }

    public float getStartAlpha() {
        return startAlpha;
    }

    public void setImageAlpha(float alpha) {
        imageAlpha = alpha;
    }

    public float getImageAlpha() {
        return imageAlpha;
    }

    public void setImageIcon(Bitmap userLocationIcon) {
        imageIcon = userLocationIcon;
        image.setBitmap(imageIcon);
    }

    public Bitmap getImageIcon() {
        return imageIcon;
    }

    public void setPulseAnimationDuration(float duration) {
        pulseAnimationDuration = (long) duration * 1000;
    }

    public float getPulseAnimationDuration() {
        return (float) pulseAnimationDuration / 1000;
    }

    public void setDelayBetweenPulseCycles(float wait) {
        delayBetweenPulseCycles = (long) wait * 1000;
    }

    public float getDelayBetweenPulseCycles() {
        return (float) delayBetweenPulseCycles / 1000;
    }

    public void setMoveTo(float x, float y) {
        moveToX = x;
        moveToY = y;
        isMoving = true;
    }

    public float getMoveToX() {
        return moveToX;
    }

    public float getMoveToY() {
        return moveToY;
    }

    public float getSpeed() {
        return mSpeed;
    }

    public void setSpeed(float speed) {
        this.mSpeed = speed / 1000f;
    }

    public float getImageScale(){
        return image_scale;
    }

    public void setImageScale(float userLocationScale){
        this.image_scale = userLocationScale;
    }

    @Override
    public void onCreate(Context context, M m, long timeElapsed, long timeTotal, Camera camera) {
        super.onCreate(context, m, timeElapsed, timeTotal, camera);

        camera_last = camera;

        imageIcon = m.bitmapLib.userLocationIcon;

        image = new Image(
                imageIcon,
                imageIcon.getWidth(), imageIcon.getHeight(),
                new Ninegrid(Ninegrid.MiddleMiddle)
        );
    }

    @Override
    public void onUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera) {
        super.onUpdate(m, timeElapsed, timeTotal, fps, camera);

        camera_last = camera;

        // move to
        if (isMoving) {
            final Transform transform = getTransform();
            final float translationX = transform.getTranslationX();
            final float translationY = transform.getTranslationY();
            final float deltaX = moveToX - translationX;
            final float deltaY = moveToY - translationY;
//    Log.d(TAG, "onUpdate: dX " + deltaX + " dy: " + deltaY);
//            if (Math.abs(deltaX) < 0.001f && Math.abs(deltaY) < 0.001f) {
//                isMoving = false;
//            }
            final float mag = (float) Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            final float unitX = deltaX / mag;
            final float unitY = deltaY / mag;
            float displace = mSpeed * timeElapsed;
            if (displace > mag) displace = mag;
            if (displace > 0) {
                final float vX = unitX * displace;
                final float vY = unitY * displace;
                transform.setTranslationX(translationX + vX);
                transform.setTranslationY(translationY + vY);
            }else{
                isMoving = false;
            }
        }
        //

        accumalator += timeElapsed;

        // the animation duration has passed and there is no wait
        if (accumalator > pulseAnimationDuration && !wait_flag) {
            wait_flag = true;
            accumalator = 0;
            paintIC.setAlpha((int) (255 * endAlpha));
        } else {
            // wait for the time to pass then send the next pulse
            if (accumalator >= delayBetweenPulseCycles && wait_flag) {
                accumalator = 0;
                wait_flag = false;
                paintIC.setAlpha((int) (255 * startAlpha));
                // no need to wait, just go
            } else if (!wait_flag) {
                paintIC.setAlpha((int) (255 * startAlpha));
            }
        }
        multiplier = (double) accumalator / (double) pulseAnimationDuration;
        draw_radius = (float) (max_radius * multiplier);
    }

    @Override
    public synchronized void onRender(Canvas canvas, Paint touchPaint) {
        canvas.drawCircle(0, 0, max_radius, paintOC);
        canvas.drawCircle(0, 0, draw_radius, paintIC);
        canvas.scale(camera_last.getScale(),camera_last.getScale());
        canvas.scale(image_scale,image_scale);
        image.onDraw(canvas, paintIm);

    }
}