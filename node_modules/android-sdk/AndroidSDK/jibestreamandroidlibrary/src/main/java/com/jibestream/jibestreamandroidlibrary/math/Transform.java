package com.jibestream.jibestreamandroidlibrary.math;

import android.graphics.Matrix;

import com.jibestream.jibestreamandroidlibrary.main.IElementProxyDirty;
import com.jibestream.jibestreamandroidlibrary.utils.MatrixUtils;

import java.util.ArrayList;

public class Transform {
public static final Transform ORIGIN = new Transform();
private final ArrayList<Transform> transformsChildren = new ArrayList<>();
private final Vec translationOffset = new Vec(0, 0);
private volatile float rotationOffset = 0;
private final Vec scaleOffset = new Vec(1f, 1f);
private final Vec translation = new Vec(0, 0);
private volatile float rotation = 0;
private final Vec scale = new Vec(1f, 1f);
private final Matrix localMatrix = new Matrix();
private final Matrix matrixGlobal = new Matrix();
private float[] matrixArray = new float[9];
private Transform transformParent = ORIGIN;
private float glbTX;
private float glbTY;
private float glbRads;
private float glbDgrs;
private float glbSX;
private float glbSY;
private final Object transformParentLock = new Object();
private IElementProxyDirty elementProxy;

public Transform() {
}

public void setElementProxy(IElementProxyDirty elementProxy) {
  this.elementProxy = elementProxy;
}

/**
 * Copies the transformation
 *
 * @return A copy of the transformation
 */
public synchronized Transform clone() {
  Transform t = new Transform();
  t.setTranslation(translation.cln());
  t.setTranslationOffset(translationOffset.cln());
  t.setScale(scale.cln());
  t.setScaleOffset(scale.cln());
  t.setRotation(rotation);
  t.setRotationOffset(rotationOffset);
  synchronized (transformParentLock) {
    transformParent.addChild(t);
  }
  return t;
}

/**
 * Sets the parameters of the transforation
 *
 * @param src
 */
public void set(Transform src) {
  src.setTranslation(translation.cln());
  src.setTranslationOffset(translationOffset.cln());
  src.setScale(scale.cln());
  src.setScaleOffset(scale.cln());
  src.setRotation(rotation);
  src.setRotationOffset(rotationOffset);
  if (transformParent != null) {
    synchronized (transformParentLock) {
      transformParent.addChild(src);
    }
  }
}


/**
 * Resets the transformation
 */
public void reset() {
  scale.setXY(1f, 1f);
  rotation = 0;
  translation.setXY(0, 0);
  translationOffset.setXY(0, 0);
  rotationOffset = 0;
  scaleOffset.setXY(1f, 1f);
  validate();
}

/**
 * Updates and returns the global matrix
 *
 * @return the glbal matrix
 */
public Matrix getGlobalMatrix() {
  synchronized (matrixGlobal) {
    return matrixGlobal;
  }
}

/**
 * Update local SRTs and return local transform
 *
 * @return its Local Matrix
 */
public Matrix getLocalMatrix() {
  synchronized (localMatrix) {
    return localMatrix;
  }
}

/**
 * Validates the transformation
 */
private void validate() {

  synchronized (transformsChildren) {
    int total = transformsChildren.size();
    for (int i = 0; i < total; i++) {
      transformsChildren.get(i).validate();
    }
  }
  synchronized (localMatrix) {
    // post as u natural flow
    localMatrix.reset();
    localMatrix.postScale(scale.getX(), scale.getY());
    localMatrix.postRotate(rotation);
    localMatrix.postTranslate(translation.getX(), translation.getY());

    localMatrix.postScale(scaleOffset.getX(), scaleOffset.getY());
    localMatrix.postRotate(rotationOffset);
    localMatrix.postTranslate(translationOffset.getX(), translationOffset.getY());
  }

  synchronized (matrixGlobal) {
    synchronized (localMatrix) {
      matrixGlobal.set(localMatrix);
    }
  }
  synchronized (transformParentLock) {
    if (transformParent != null) {
      synchronized (matrixGlobal) {
        matrixGlobal.postConcat(transformParent.getGlobalMatrix());
      }
    }
  }

  synchronized (matrixGlobal) {
    matrixGlobal.getValues(matrixArray);
    glbTX = matrixArray[Matrix.MTRANS_X];
    glbTY = matrixArray[Matrix.MTRANS_Y];
    glbRads = (float) Math.atan2(matrixArray[Matrix.MSKEW_Y], matrixArray[Matrix.MSCALE_Y]);
    glbDgrs = (float) Math.toDegrees(glbRads);
    glbSX = (float) (Math.sqrt(Math.pow(matrixArray[Matrix.MSCALE_X], 2) + Math.pow(matrixArray[Matrix.MSKEW_X], 2)));
    glbSY = (float) (Math.sqrt(Math.pow(matrixArray[Matrix.MSKEW_Y], 2) + Math.pow(matrixArray[Matrix.MSCALE_Y], 2)));
  }
  //
  if (elementProxy != null) elementProxy.setDirtyTransform(true);
}

/**
 * Counts the number of children
 *
 * @return an integer representing the number of children
 */
public int getChildCount() {
  synchronized (transformsChildren) {
    return transformsChildren.size();
  }
}

/**
 * Returns a specific child
 *
 * @param index
 * @return A child Transform object
 */
public Transform getChildAt(int index) {
  if (index < 0 || index >= transformsChildren.size()) return null;
  synchronized (transformsChildren) {
    return transformsChildren.get(index);
  }
}

/**
 * Adds a child to this Transform
 *
 * @param child
 */
public void addChild(Transform child) {
  if (child.getParent() != null) {
    child.getParent().removeChild(child);
  }
  child.setParent(this);

  synchronized (transformsChildren) {
    transformsChildren.add(child);
  }
  child.validate();
}

/**
 * Removes a child from this Transform
 *
 * @param child
 */
public void removeChild(Transform child) {
  synchronized (transformsChildren) {
    if (transformsChildren.indexOf(child) == -1) return;
    transformsChildren.remove(child);
  }
  child.setParentOrigin();
}

/**
 * Removes the child using an index
 *
 * @param index
 */
public void removeChild(int index) {
  Transform child = null;
  synchronized (transformsChildren) {
    child = transformsChildren.remove(index);
  }
  if (child == null) return;
  child.setParentOrigin();
}

/**
 * Removes all children
 */
public void removeChildren() {
  synchronized (transformsChildren) {
    int total = transformsChildren.size();
    for (int i = 0; i < total; i++) {
      transformsChildren.get(i).setParentOrigin();
    }
    transformsChildren.clear();
  }
}

public void setParent(Transform papa) {
  synchronized (transformParentLock) {
    transformParent = papa;
  }
  validate();
}

public void setParentOrigin() {
  synchronized (transformParentLock) {
    transformParent = ORIGIN;
  }
  validate();
}

public Transform getParent() {
  synchronized (transformParentLock) {
    return transformParent;
  }
}


//<editor-fold desc="Local Space">

/**
 * Returns a clone of the TranslationOffset
 *
 * @return
 */
public Vec getTranslationOffset() {
  return translationOffset.cln();
}

public void setTranslationOffset(Vec translationOffset) {
  if (this.translationOffset.isEqual(translationOffset)) return;
  this.translationOffset.setX(translationOffset.getX());
  this.translationOffset.setY(translationOffset.getY());
  validate();
}

public float getTranslationOffsetX() {
  return translationOffset.getX();
}

public void setTranslationOffsetX(float x) {
  if (this.translationOffset.getX() == x) return;
  this.translationOffset.setX(x);
  validate();
}

public float getTranslationOffsetY() {
  return translationOffset.getY();
}

public void setTranslationOffsetY(float y) {
  if (this.translationOffset.getY() == y) return;
  this.translationOffset.setY(y);
  validate();
}

public float getRotationOffset() {
  return rotationOffset;
}

public void setRotationOffset(float rotationOffset) {
  if (this.rotationOffset == rotationOffset) return;
  this.rotationOffset = rotationOffset;
  validate();
}

/**
 * Returns a clone of the ScaleOffset Vector
 *
 * @return
 */
public Vec getScaleOffset() {
  return scaleOffset.cln();
}

public void setScaleOffset(Vec offsetScl) {
  if (this.scaleOffset.isEqual(offsetScl)) return;
  this.scaleOffset.set(offsetScl);
  validate();
}

public void setScaleOffset(float scl) {
  if (this.scaleOffset.getX() == scl && this.scaleOffset.getY() == scl) return;
  this.scaleOffset.setXY(scl, scl);
  validate();
}

public float getScaleOffsetX() {
  return scaleOffset.getX();
}

public void setScaleOffsetX(float x) {
  if (this.scaleOffset.getX() == x) return;
  this.scaleOffset.setX(x);
  validate();
}

public float getScaleOffsetY() {
  return scaleOffset.getY();
}

public void setScaleOffsetY(float y) {
  if (this.scaleOffset.getY() == y) return;
  this.scaleOffset.setY(y);
  validate();
}

/**
 * Returns a clone of the Translation Vector
 *
 * @return
 */
public Vec getTranslation() {
  return translation.cln();
}

public void setTranslation(Vec translation) {
  if (this.translation.isEqual(translation)) return;
  this.translation.set(translation);
  validate();
}

public float getTranslationX() {
  return translation.getX();
}

public void setTranslationX(float x) {
  if (this.translation.getX() == x) return;
  this.translation.setX(x);
  validate();
}

public float getTranslationY() {
  return translation.getY();
}

public void setTranslationY(float y) {
  if (this.translation.getY() == y) return;
  this.translation.setY(y);
  validate();
}

public float getRotation() {
  return rotation;
}

public void setRotation(float rotation) {
  if (this.rotation == rotation) return;
  this.rotation = rotation;
  validate();
}

/**
 * Returns a clone of the Scale Vector
 *
 * @return
 */
public Vec getScale() {
  return scale.cln();
}

public void setScale(Vec scale) {
  if (this.scale.isEqual(scale)) return;
  this.scale.set(scale);
  validate();
}

public void setScale(float scale) {
  if (this.scale.getX() == scale && this.scale.getY() == scale) return;
  this.scale.setXY(scale, scale);
  validate();
}

public float getScaleX() {
  return scale.getX();
}

public void setScaleX(float x) {
  if (this.scale.getX() == x) return;
  this.scale.setX(x);
  validate();
}

public float getScaleY() {
  return scale.getY();
}

public void setScaleY(float y) {
  if (this.scale.getY() == y) return;
  this.scale.setY(y);
  validate();
}
//</editor-fold>

//<editor-fold desc="Global Space">

/**
 * Returns a new Translation Vector in global space
 *
 * @return
 */
public Vec getGlobalTrans() {
  Vec v = new Vec(glbTX, glbSY);
  return v;
}

public float getGlobalTransX() {
  return glbTX;
}

public float getGlobalTransY() {
  return glbTY;
}

public float getGlobalRotDgrs() {
  return glbDgrs;
}

public float getGlobalRotRads() {
  return glbRads;
}

/**
 * Returns a new Scale Vector in global space
 *
 * @return
 */
public Vec getGlobalScale() {
  Vec v = new Vec(glbSX, glbSY);
  return v;
}

public float getGlobalScaleX() {
  return glbSX;
}

public float getGlobalScaleY() {
  return glbSY;
}
//</editor-fold>

//<editor-fold desc="Screen Space">

/**
 * Returns a new Translation Vector in screen space
 *
 * @return
 */
public Vec getScreenTrans(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  Vec v = new Vec(
      MatrixUtils.getTransX(matrix),
      MatrixUtils.getTransY(matrix)
  );
  return v;
}

public float getScreenTransX(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  return MatrixUtils.getTransX(matrix);
}

public float getScreenTransY(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  return MatrixUtils.getTransY(matrix);
}

public float getScreenRotDgrs(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  return MatrixUtils.getRotDgrs(matrix);
}

public float getScreenRotRads(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  return MatrixUtils.getRotRads(matrix);
}

/**
 * Returns a new Scale vector in screen space
 *
 * @return
 */
public Vec getScreenScale(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  Vec v = new Vec(
      MatrixUtils.getScaleX(matrix),
      MatrixUtils.getScaleY(matrix)
  );
  return v;
}

public float getScreenScaleX(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  return MatrixUtils.getScaleX(matrix);
}

public float getScreenScaleY(Matrix camerasMatrix) {
  final Matrix matrix = new Matrix(camerasMatrix);
  synchronized (matrixGlobal) {
    matrix.preConcat(matrixGlobal);
  }
  return MatrixUtils.getScaleY(matrix);
}
//</editor-fold>

//<editor-fold desc="Relative Values">

public void addTranslationOffset(Vec positionOffset) {
  if (positionOffset == null) return;
  if (positionOffset.isEqual(Vec.ZERO)) return;
  this.translationOffset.add(positionOffset);
  validate();
}

public void addTranslationOffsetX(float x) {
  if (x == 0) return;
  this.translationOffset.addX(x);
  validate();
}

public void addTranslationOffsetY(float y) {
  if (y == 0) return;
  this.translationOffset.addY(y);
  validate();
}

public void addRotationOffset(float rotationOffset) {
  if (rotationOffset == 0) return;
  this.rotationOffset += rotationOffset;
  validate();
}

public void addScaleOffset(Vec offsetScl) {
  if (offsetScl == null) return;
  if (offsetScl.isEqual(Vec.ZERO)) return;
  this.scaleOffset.add(offsetScl);
  validate();
}

public void addScaleOffset(float scl) {
  if (scl == 0) return;
  this.scaleOffset.addX(scl);
  this.scaleOffset.addY(scl);
  validate();
}

public void addScaleOffsetX(float x) {
  if (x == 0) return;
  this.scaleOffset.addX(x);
  validate();
}

public void addScaleOffsetY(float y) {
  if (y == 0) return;
  this.scaleOffset.addY(y);
  validate();
}

public void addTranslation(Vec position) {
  if (position == null) return;
  if (position.isEqual(Vec.ZERO)) return;
  this.translation.add(position);
  validate();
}

public void addTranslationX(float x) {
  if (x == 0) return;
  this.translation.addX(x);
  validate();
}

public void addTranslationY(float y) {
  if (y == 0) return;
  this.translation.addY(y);
  validate();
}

public void addRotation(float rotation) {
  if (rotation == 0) return;
  this.rotation += rotation;
  validate();
}

public void addScale(Vec scale) {
  if (scale == null) return;
  if (scale.isEqual(Vec.ZERO)) return;
  this.scale.add(scale);
  validate();
}

public void addScale(float scale) {
  if (scale == 0) return;
  this.scale.addX(scale);
  this.scale.addY(scale);
  validate();
}

public void addScaleX(float x) {
  if (x == 0) return;
  this.scale.addX(x);
  validate();
}

public void addScaleY(float y) {
  if (y == 0) return;
  this.scale.addY(y);
  validate();
}
}


