package com.jibestream.jibestreamandroidlibrary.main;

import android.graphics.RectF;

import com.jibestream.jibestreamandroidlibrary.elements.Element;
import com.jibestream.jibestreamandroidlibrary.elements.Unit;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.PathPerFloor;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Amenity;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Category;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Destination;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.DestinationLabel;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.DestinationProximity;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Device;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapFull;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapLabel;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.WaypointEntityLink;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Zone;

import java.util.ArrayList;
import java.util.Arrays;
// TODO: 2016-06-07 move all remaining methods to M

/**
 * Created by emmanuel on 2015-11-12.
 */
public class Building {

public static RectF viewport;

public interface CallbackPathPerFloors {
  void callback(PathPerFloor[] pathPerFloors);
}

public interface CallbackMapFull {
  void callback(MapFull mapFull);
}

public interface CallbackDestination {
  void callback(Destination destination);
}

public interface CallbackDestinations {
  void callback(Destination[] destinations);
}

public interface CallbackAmenity {
  void callback(Amenity amenity);
}

public interface CallbackAmenities {
  void callback(Amenity[] amenities);
}

public interface CallbackWaypoint {
  void callback(Waypoint waypoint);
}

public interface CallbackWaypoints {
  void callback(Waypoint[] waypoints);
}

public interface CallbackRectF {
  void callback(RectF rectF);
}

/////////////////////////////////////////-------------------------------------          Helper Fns

/**
 * Sets the waypointTo variables
 *
 * @param destination
 * @deprecated Building helper methods
 */
public static void setTo(M m, Destination destination) {
  Waypoint waypoint = getWaypointsOfDestination(m, destination)[0];
  m.setToWaypoint(waypoint);
}

/**
 * Sets the waypointTo variable
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void setTo(M m, Waypoint waypoint) {
  m.setToWaypoint(waypoint);
}

/**
 * Sets the waypointFrom variables
 *
 * @param destination
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void setFrom(M m, Destination destination) {
  Waypoint waypoint = getWaypointsOfDestination(m, destination)[0];
  m.setFromWaypoint(waypoint);
}

/**
 * Sets the destinationFrom variable
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void setFrom(M m, Waypoint waypoint) {
  m.setFromWaypoint(waypoint);
}

/**
 * Wayfind to desired waypoints accesability will be set to false
 * returns the paths per floor
 *
 * @param from The starting waypoint.
 * @param to   The end waypoint.
 * @return PathPerFloor[]
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static PathPerFloor[] wayfind(M m, Waypoint from, Waypoint to) {
  return wayfind(m, from, to, false);
}

/**
 * Wayfind to desired waypoints
 * returns the paths per floor
 *
 * @param from          The starting waypoint.
 * @param to            The end waypoint.
 * @param accessibility
 * @return PathPerFloor[]
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static PathPerFloor[] wayfind(M m, Waypoint from, Waypoint to, boolean accessibility) {
  int acces;
  if (accessibility) {
    acces = 50;
  } else {
    acces = 100;
  }
  return m.wayfind(from, to, acces);
}

/**
 * @param from
 * @param to
 * @param accessibility
 * @param pathPerFloors
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void wayfind(M m, Waypoint from, Waypoint to, boolean accessibility, CallbackPathPerFloors pathPerFloors) {
  PathPerFloor[] p = wayfind(m, from, to, accessibility);
  pathPerFloors.callback(p);
}

/**
 * @param m
 * @param from
 * @param to
 * @param accessibility
 * @param pathPerFloors
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void wayfind(M m, Waypoint from, Waypoint to, int accessibility, CallbackPathPerFloors pathPerFloors) {
  PathPerFloor[] p = m.wayfind(from, to, accessibility);
  pathPerFloors.callback(p);
}

/////////////////////////////////////////-------------------------------------         Camera


/**
 * Frames the map to the screen respecting the orientation that
 * already exists
 */
public static void cameraToMap(M m, Camera camera) {
  RectF viewBox = m.floorViewboxes[m.getCurrentMapIndex()];
  camera.zoomTo(viewBox);
}

/**
 * Frames the path on the current level and returns true if a path exist on the current level.
 * if no path exist it just returns false.
 *
 * @return boolean
 */
public static boolean cameraToPath(M m, Camera camera) {
  PathPerFloor pathForCurrentFloor = m.getPathForCurrentFloor();
  if (pathForCurrentFloor == null || pathForCurrentFloor.mapId != m.getCurrentMap().map.mapId)
    return false;
  RectF rect = m.route.getBBox();
  if (rect == null) return false;
// Converting rect to square
  int mm = (int) (Math.max(rect.width(), rect.height()) / 2f);
  RectF r = new RectF();
  r.left = rect.centerX() - mm;
  r.top = rect.centerY() - mm;
  r.right = rect.centerX() + mm;
  r.bottom = rect.centerY() + mm;
  camera.zoomTo(r, mm);
  return true;
}

/**
 * Frames a Unit and returns true if the operation succeeds.
 *
 * @param destinationID
 * @return if the operation was successful
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static boolean cameraToUnit(M m, int destinationID, Camera camera) {
  return m.cameraToUnit(destinationID);
}

/**
 * Sets the setCurrentMap value to the first waypoint`s mapID
 * that is associated with the requested destination
 *
 * @param id
 */
public static boolean setLevelByDestinationID(M m, int id) {
  Destination destination = getDestinationWithID(m, id);
  Waypoint[] waypoints = getWaypointsOfDestination(m, destination);
  if (waypoints != null && waypoints.length > 0) {
    final int mapId = waypoints[0].mapId;
    final MapFull mapFull = getMapWithID(m, mapId);
    m.setLevel(mapFull);
    return true;
  }
  return false;
}

/**
 * Get the level the requested {@link Waypoint} is on as an index
 *
 * @param id the waypoint`s ID
 */
public static int getLevelIndexOfWaypointWithID(M m, int id) {
  Waypoint waypoint = getWaypointWithID(m, id);
  return getLevelsIndexWithMapID(m, waypoint.mapId);
}

public static int getLevelsIndexWithMapID(M m, int mapID) {
  final MapFull mapFull = getMapWithID(m, mapID);
  final int indexOf = Arrays.asList(m.venueData.maps).indexOf(mapFull);
  return indexOf;
}

/////////////////////////////////////////-------------------------------------         Zones

/**
 * @param m
 * @param id
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Zone getZonetWithID(M m, int id) {
  return m.getZoneByID(id);
}

public static ArrayList<Unit> getUnitsWithZone(M m, Zone zone) {
  final Unit[] unitsWithZone = m.getUnitsWithZone(zone);
  return new ArrayList<>(Arrays.asList(unitsWithZone));
}

public static ArrayList<Waypoint> getWaypointsWithZone(M m, Zone zone) {
  final ArrayList<Waypoint> waypointsWithZone = m.getWaypointsWithZone(zone);
  return waypointsWithZone;
}

public static ArrayList<Destination> getDestinationsWithZone(M m, Zone zone) {
  final Destination[] destinationsByZone = m.getDestinationsByZone(zone);
  return new ArrayList<>(Arrays.asList(destinationsByZone));
}
/////////////////////////////////////////-------------------------------------         Maps

/**
 * Retrieve the {@link MapFull} from its id
 *
 * @param id
 * @param callbackMapFull
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getMapWithID(M m, int id, CallbackMapFull callbackMapFull) {
  callbackMapFull.callback(getMapWithID(m, id));
}

/**
 * Retrieve the {@link MapFull} from its id
 *
 * @param id
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static MapFull getMapWithID(M m, int id) {
  return m.getMapFullById(id);
}

/////////////////////////////////////////-------------------------------------         Waypoints

/**
 * Get a {@link Waypoint} from its id
 *
 * @param id
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Waypoint getWaypointWithID(M m, int id) {
  return m.getWaypointWithID(id);
}


public static void getWaypointWithID(M m, int id, CallbackWaypoint callbackDWaypoint) {
  callbackDWaypoint.callback(getWaypointWithID(m, id));
}

/**
 * Get array of {@link Waypoint} for a destination
 *
 * @param destination
 * @return array of all waypoints associated to the destination
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Waypoint[] getWaypointsOfDestination(M m, Destination destination) {
  return m.getWaypointsOfDestination(destination);
}

/**
 * @param m
 * @param destination
 * @param callbackWaypoints
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getWaypointsOfDestination(M m, Destination destination, CallbackWaypoints callbackWaypoints) {
  callbackWaypoints.callback(getWaypointsOfDestination(m, destination));
}

/**
 * Get array of {@link Waypoint} for a given amenity
 *
 * @param amenity
 * @return array of all waypoints associated to the amenity
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Waypoint[] getWaypointsOfAmenity(M m, Amenity amenity) {
  return m.getWaypointsOfAmenity(amenity);
}

/**
 * @param m
 * @param amenity
 * @param callbackWaypoints
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getWaypointsOfAmenity(M m, Amenity amenity, CallbackWaypoints callbackWaypoints) {
  callbackWaypoints.callback(getWaypointsOfAmenity(m, amenity));
}

/**
 * Finds the closest waypoint to the
 * provided x and y values.
 * Domain value`s accordingly to initial svg map
 * coordinates. If level is not specified engines
 * last level will be used.
 *
 * @param x
 * @param y
 * @param atLevel Floor level to look for waypoint.
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Waypoint findClosestWaypoint(M m, float x, float y, MapFull atLevel) {
  return m.findClosestWaypoint(x, y, atLevel);
}

/**
 * @param m
 * @param x
 * @param y
 * @param atLevel
 * @param callbackWaypoint
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void findClosestWaypoint(M m, float x, float y, MapFull atLevel, CallbackWaypoint callbackWaypoint) {
  callbackWaypoint.callback(findClosestWaypoint(m, x, y, atLevel));
}

/**
 * finds the closest Amenity Type accordingly to
 * the current location thats if reflected ont the
 * waypointFrom vairable found on the model.
 *
 * @param typeID
 * @return Returns waypoint or null
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Waypoint getClosestAmenity(M m, int typeID) {
  return m.getClosestWaypointOfAmenityTypeID(m.getFromWaypoint(), typeID);
}

/**
 * @param m
 * @param typeID
 * @param callbackWaypoint
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getClosestAmenity(M m, int typeID, CallbackWaypoint callbackWaypoint) {
  callbackWaypoint.callback(getClosestAmenity(m, typeID));
}

/**
 * Sets the setToWaypoint to the closest amenity
 * of the specified type.
 *
 * @param typeID
 * @return closest waypoint or null
 */
public static Waypoint wayfindToClosestAmenity(M m, int typeID) {
  Waypoint closestWaypoint = getClosestAmenity(m, typeID);
  if (closestWaypoint != null) {
    m.setToWaypoint(closestWaypoint);
  }
  return closestWaypoint;
}

/**
 * @param m
 * @param typeID
 * @param callbackWaypoint
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void wayfindToClosestAmenity(M m, int typeID, CallbackWaypoint callbackWaypoint) {
  callbackWaypoint.callback(wayfindToClosestAmenity(m, typeID));
}
/////////////////////////////////////////-------------------------------------         Destination

/**
 * Get the destination objects found on the {@link DestinationProximity} field from a given destination
 *
 * @param destination
 * @return array of all Destination associated with the DestinationProximity
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Destination[] getDestinationsOfProximities(M m, Destination destination) {
  return m.getDestinationsOfProximities(destination);
}

/**
 * @param m
 * @param destination
 * @param callbackDestinations
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getDestinationsOfProximities(M m, Destination destination, CallbackDestinations callbackDestinations) {
  callbackDestinations.callback(getDestinationsOfProximities(m, destination));
}

/**
 * @param m
 * @param query
 * @param maxResults
 * @param callbackDestinations
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getDestinationsByQuery(M m, String query, int maxResults, CallbackDestinations callbackDestinations) {
  final ArrayList<Destination> destinationsByQuery = getDestinationsByQuery(m, query, maxResults);
  Destination[] destinations = destinationsByQuery.toArray(new Destination[destinationsByQuery.size()]);
  callbackDestinations.callback(destinations);
}

/**
 * Retrieve the {@link Destination} from its id
 *
 * @param id
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Destination getDestinationWithID(M m, int id) {
  return m.getDestinationByID(id);
}

/**
 * @param m
 * @param id
 * @param callbackDestination
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getDestinationWithID(M m, int id, CallbackDestination callbackDestination) {
  callbackDestination.callback(getDestinationWithID(m, id));
}

/**
 * Get array of {@link Destination} for a given waypoint
 *
 * @param waypoint
 * @return array of destinations associated to the waypoint
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Destination[] getDestinationsOfWaypoint(M m, Waypoint waypoint) {
  return m.getDestinationsOfWaypoint(waypoint);
}

/**
 * @param m
 * @param waypoint
 * @param callbackDestinations
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getDestinationsOfWaypoint(M m, Waypoint waypoint, CallbackDestinations callbackDestinations) {
  callbackDestinations.callback(getDestinationsOfWaypoint(m, waypoint));
}


/////////////////////////////////////////-------------------------------------         Amenitites

/**
 * Get array of {@link com.jibestream.jibestreamandroidlibrary.elements.Amenity} for a given waypoint
 *
 * @param waypoint
 * @return array of amenities associated to the waypoint
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Amenity[] getAmenitiesOfWaypoint(M m, Waypoint waypoint) {
  return m.getAmenitiesOfWaypoint(waypoint);
}

/**
 * @param m
 * @param waypoint
 * @param callbackAmenities
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getAmenitiesOfWaypoint(M m, Waypoint waypoint, CallbackAmenities callbackAmenities) {
  callbackAmenities.callback(getAmenitiesOfWaypoint(m, waypoint));
}


/**
 * Get a {@link com.jibestream.jibestreamandroidlibrary.elements.Amenity} from its id
 *
 * @param id
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Amenity getAmenityWithID(M m, int id) {
  return m.getAmenityByID(id);
}

/**
 * @param m
 * @param id
 * @param callbackAmenity
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void getAmenityWithID(M m, int id, CallbackAmenity callbackAmenity) {
  callbackAmenity.callback(getAmenityWithID(m, id));
}
/////////////////////////////////////////-------------------------------------         Regions

/**
 * @param m
 * @param destinationID
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Element> getElementsOfDestination(M m, int destinationID) {
  final Element[] elementsOfDestination = m.getElementsOfDestination(destinationID);
  return new ArrayList<>(Arrays.asList(elementsOfDestination));
}

/**
 * find the bounds of all instances on the specified level
 * associated from the passed classes names and
 * returns the union operation of them
 *
 * @param classes
 * @param mapIndex
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static RectF getRectOfClassesInstances(M m, Class[] classes, int mapIndex) {
  return m.getRectOfClassesInstances(classes, mapIndex);
}

/////////////////////////////////////////-------------------------------------      Helpers for Elements

/**
 * Gets all elements of type
 *
 * @param aClass
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Element> getElementsByType(M m, Class aClass) {
  final Element[] elementsByType = m.getElementsByType(aClass);
  return new ArrayList<>(Arrays.asList(elementsByType));
}

/////////////////////////////////////////-------------------------------------      Units

/**
 * @param m
 * @param destination
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Unit> getUnitsOfDestination(M m, Destination destination) {
  final Unit[] unitsByDestination = m.getUnitsByDestination(destination);
  return new ArrayList<>(Arrays.asList(unitsByDestination));
}

/**
 * Set highlight state on all units with passed Destination ID
 *
 * @param id
 * @param state
 * @return an ArrayList of Unit class
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Unit> setHighlightOnUnitsByDestinationID(M m, int id, boolean state) {
  final Unit[] units = m.setHighlightOnUnitsByDestinationID(id, state);
  return new ArrayList<>(Arrays.asList(units));
}

/**
 * Sets the selection state of all the elements of class type
 *
 * @param aClass
 * @param state
 * @return an ArrayList of Element class
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Element> setSelectionStateByType(M m, Class aClass, boolean state) {
  final Element[] elements = m.setSelectionStateByType(aClass, state);
  return new ArrayList<>(Arrays.asList(elements));
}

/**
 * Sets the highlighted state of all elements of class type
 *
 * @param aClass
 * @param state
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void setHighlightStateByType(M m, Class aClass, boolean state) {
  m.setHighlightStateByType(aClass, state);
}

/**
 * Sets selection state of all units to false
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void deselectUnits(M m) {
  setSelectionStateByType(m, Unit.class, false);
}

/**
 * Sets highlight state of units to false
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void unHighlightUnits(M m) {
  setHighlightStateByType(m, Unit.class, false);
}

/**
 * Sets selection state of all amenities to false
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void deselectAmenities(M m) {
  setSelectionStateByType(m, com.jibestream.jibestreamandroidlibrary.elements.Amenity.class, false);
}

/**
 * Sets highlight state of all elements to false
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static void deslectAll(M m) {
  setSelectionStateByType(m, Element.class, false);
}

/**
 * highlight all units with passed Category
 *
 * @param categoryToHighlight
 * @return all highlighted units
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Unit> highlightUnitsByCategory(M m, Category categoryToHighlight) {
  final Unit[] units = m.highlightUnitsByCategory(categoryToHighlight);
  return new ArrayList<>(Arrays.asList(units));
}

/**
 * @param m
 * @param zone
 * @return
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Unit> highlightUnitsByZone(M m, Zone zone) {
  final Unit[] units = m.highlightUnitsByZone(zone);
  return new ArrayList<>(Arrays.asList(units));
}

/**
 * searches all destination`s names,keywords and categories
 * Using a query string this method will search through all the destinations those destination's keywords to find the appropriate results.
 *
 * @param query
 * @param maxResults
 * @return An array of destination objects.
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Destination> getDestinationsByQuery(M m, String query, int maxResults) {
  return m.getDestinationsByQuery(query, maxResults);
}

/////////////////////////////////////////-------------------------------------         Destinations

/**
 * Get destinations given destinationId
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Destination getDestinationById(M m, int destId) {
  return m.getDestinationByID(destId);
}

/**
 * Get destination by client id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Destination> getDestinationsByClientId(M m, String clientId) {
  final Destination[] destinationsByClientId = m.getDestinationsByClientId(clientId);
  return new ArrayList<>(Arrays.asList(destinationsByClientId));
}

/**
 * Get destination given waypointId
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Destination> getDestinationsByWpId(M m, Integer wpId) {
  final Destination[] destinationsByWpId = m.getDestinationsByWpId(wpId);
  return new ArrayList<>(Arrays.asList(destinationsByWpId));
}

/**
 * Get destinations given floor sequence
 */
public static ArrayList<Destination> getDestinationsByFloorSequence(M m, int floorSequence) {
  ArrayList<Destination> foundDestinations = new ArrayList<>();
  MapFull[] maps = m.venueData.maps;
  for (int i = 0; i < maps.length; i++) {
    MapFull mapFull = maps[i];
    if (mapFull.map.floorSequence == floorSequence) {
      //Map by floor sequence found

      Waypoint[] waypoints = mapFull.waypoints;
      for (int k = 0; k < waypoints.length; k++) {
        Waypoint p = waypoints[k];
        WaypointEntityLink[] associations = p.associations;
        for (int j = 0; j < associations.length; j++) {
          WaypointEntityLink link = associations[j];
          foundDestinations.add(getDestinationById(m, link.entityId));
        }
      }
    }
  }
  return foundDestinations;
}

/**
 * Get destinations given floor id
 */
public static ArrayList<Destination> getDestinationsByFloorId(M m, int floorId) {
  MapFull[] maps = m.venueData.maps;
  for (int j = 0; j < maps.length; j++) {
    MapFull mapFull = maps[j];
    if (mapFull.map.mapId == floorId) {
      //Map floor found
      ArrayList<Integer> destinationIds = new ArrayList<>();
      Waypoint[] waypoints = mapFull.waypoints;
      if (waypoints == null) continue;
      for (int i = 0; i < waypoints.length; i++) {
        Waypoint wp = waypoints[i];
        WaypointEntityLink[] associations = wp.associations;
        if (associations == null) continue;
        for (int k = 0; k < associations.length; k++) {
          WaypointEntityLink link = associations[k];
          if (link.entityTypeId == 1) {
            destinationIds.add(link.entityId);
          }
        }
      }
      ArrayList<Destination> destinations = new ArrayList<>();
      for (int i = 0; i < destinationIds.size(); i++) {
        Integer entityId = destinationIds.get(i);
        destinations.add(getDestinationById(m, entityId));
      }
      return destinations;
    }
  }
  return null;
}

/**
 * Get destinations given category id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Destination> getDestinationsByCategoryId(M m, Integer catId) {
  final Destination[] destinationsByCategoryId = m.getDestinationsByCategoryId(catId);
  return new ArrayList<>(Arrays.asList(destinationsByCategoryId));
}

/**
 * Get all categories by Id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static ArrayList<Category> getCategoriesById(M m, String categoryId) {
  final ArrayList<Category> categoriesById = m.getCategoriesById(categoryId);
  return categoriesById;
}

/**
 * Get floor by Id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static MapFull getFloorById(M m, Integer mapId) {
  return m.getMapFullById(mapId);
}

/**
 * Get floor given destination Id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static MapFull getMapFullByDestinationId(M m, int destinationId) {
  return m.getMapFullByDestinationId(destinationId);
}

/**
 * Get floor given sequence
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static MapFull getFloorDataBySequence(M m, Integer floorSequence) {
  return m.getMapFullDataBySequence(floorSequence);
}

/**
 * Get waypoint given waypointId
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Waypoint getWaypointsById(M m, int wpId) {
  return m.getWaypointWithID(wpId);
}

/**
 * Get device waypoint assigned to this device
 */
public static Waypoint getDeviceWaypoint(M m) {
  MapFull[] maps = m.venueData.maps;
  for (int i = 0; i < maps.length; i++) {
    MapFull mapFull = maps[i];
    Waypoint[] waypoints = mapFull.waypoints;
    for (int k = 0; k < waypoints.length; k++) {
      Waypoint wp = waypoints[k];
      WaypointEntityLink[] associations = wp.associations;
      for (int j = 0; j < associations.length; j++) {
        WaypointEntityLink link = associations[j];
        Device[] devices = m.venueData.devices;
        for (int l = 0; l < devices.length; l++) {
          Device device = devices[l];
          if (device.id == link.entityId) {
            return wp;
          }
        }
      }
    }
  }
  return null;
}

/**
 * Get all waypoints of amenities
 */
public static ArrayList<Waypoint> getAmenityWaypoints(M m) {
  ArrayList<Waypoint> foundWaypoints = new ArrayList<Waypoint>();
  Amenity[] amenities = m.venueData.amenities;
  for (int i = 0, amenitiesLength = amenities.length; i < amenitiesLength; i++) {
    Amenity amenity = amenities[i];
    Waypoint[] waypoints = amenity.waypoints;
    for (int k = 0; k < waypoints.length; k++) {
      Waypoint wp = waypoints[k];
      foundWaypoints.add(wp);
    }
  }
  return foundWaypoints;
}

/**
 * Get amenity given Id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static Amenity getAmenityById(M m, Integer componentId) {
  return m.getAmenityByID(componentId);
}

/**
 * Get map labels given floor Id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static MapLabel[] getMapLabelsByFloorId(M m, Integer mapId) {
  final MapLabel[] mapLabelsByFloorId = m.getMapLabelsByFloorId(mapId);
  return mapLabelsByFloorId;
}

/**
 * Get destination labels given floor Id
 *
 * @deprecated Building methods are kept for backwards compatibility,
 * please use the same method found on {@link M}.
 */
public static DestinationLabel[] getDestinationLabelsByFloor(M m, Integer mapId) {
  final DestinationLabel[] destinationLabelsByFloor = m.getDestinationLabelsByFloor(mapId);
  return destinationLabelsByFloor;
}

}
