package com.jibestream.jibestreamandroidlibrary.elements;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.RectF;
import android.support.annotation.NonNull;

import com.jibestream.jibestreamandroidlibrary.intents.IntentTouch;
import com.jibestream.jibestreamandroidlibrary.main.Camera;
import com.jibestream.jibestreamandroidlibrary.main.GUID;
import com.jibestream.jibestreamandroidlibrary.main.IElementProxyDirty;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.math.Transform;
import com.jibestream.jibestreamandroidlibrary.shapes.IShape;
import com.jibestream.jibestreamandroidlibrary.utils.ColorsMaterialDesign;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by emmanuel on 15-07-05.
 */
public class Element implements IElement, IElementProxyDirty, Comparable<Element> {
protected static final String TAG = "Element";
private static final AtomicInteger ELEMENTS_COUNTER = new AtomicInteger(0);
public static final AtomicBoolean flag_LevelChange = new AtomicBoolean(false);
public final int id;
public final int number;
public final HashMap<String, String> attributes = new HashMap<>();
protected static final Paint paintDebug;
private volatile boolean isInitialized = false;
private IShape iShape;// = new TwoDent();
private final Object iShapeLock = new Object();
/**
 * Assigns the object to a level (floorwise)
 * It will render if current floor equals its value
 * if value is -1 it will be visible on all floors
 */
private volatile int level = -1;
private volatile int updateInterval = 1;
private final RectF bbox = new RectF();
private final Transform transform = new Transform();
private final Matrix transformation = new Matrix();
private final ArrayList<Element> children = new ArrayList<>();
/**
 * The class name found on this element as a SVG element.
 */
public volatile String classNameCSS;
private final Object lockOffsets = new Object();
private float offsetX;
private float offsetY;
private volatile boolean headsUp = false;
private volatile boolean headsUpFlip = false;
private volatile boolean constantScale = false;

/**
 * Sets the instance state on || off
 * No updates or rendering will be performed
 * if false
 */
private volatile boolean active = true;
/**
 * Visibility of instance
 * if false will not render but
 * its eligible for updates
 */
private volatile boolean visible = true;
/**
 * Determines if object will be selectable
 */
private volatile boolean selectable = false;
/**
 * Determines if object will be highlightable
 */
private volatile boolean highlightable = false;
/**
 * Determines if object will be included in the collision detection
 */
private volatile boolean collidable = false;
/**
 * Sets the selection state
 */
private volatile boolean selectState = false;
/**
 * Sets the highlightState state
 */
private volatile boolean highlightState = false;
/**
 * Shows the bounding box of the element
 */
private volatile boolean boundingBoxVisible = false;
/**
 * Ignores any camera transformation, element would appear in view space
 */
private volatile boolean inViewSpace = false;
//  flags for lazy updating
private Object lockDirtyStyle = new Object();
private Object lockDirtyTransform = new Object();
private Object lockDirtyShape = new Object();
private boolean dirtyStyle = true;
private boolean dirtyTransform = true;
private boolean dirtyShape = true;
private volatile boolean willRender = true;

static {
  paintDebug = new Paint();
  paintDebug.setStyle(Paint.Style.STROKE);
  paintDebug.setStrokeWidth(1);
  paintDebug.setColor(ColorsMaterialDesign.ORANGE5);
  paintDebug.setAntiAlias(true);
}

public Element() {
  id = GUID.get();
  number = ELEMENTS_COUNTER.getAndIncrement();
  transform.setElementProxy(this);
//  setBoundingBoxVisible(true);
}

public boolean willUpdate(long framesTotal) {
  if (framesTotal == 0) return true;
  if (framesTotal == 1) return true;
  if (updateInterval == 0) return false;
  if (updateInterval == 1) return true;
  final long mod = framesTotal % updateInterval;
  if (mod == 0) return true;
  return false;
}

public int getUpdateInterval() {
  return updateInterval;
}

public void setUpdateInterval(int updateInterval) {
  this.updateInterval = updateInterval;
}

/**
 * Adds child`s transform to this transform
 *
 * @param child
 */
public void addChild(Element child) {
  synchronized (children) {
    children.add(child);
  }
  transform.addChild(child.getTransform());
}

/**
 * Remove child`s from
 *
 * @param child
 */
public void removeChild(Element child) {
  synchronized (children) {
    children.remove(child);
  }
  transform.removeChild(child.getTransform());
}

public ArrayList<Element> getChildren() {
  synchronized (children) {
    return children;
  }
}

public Matrix getTransformation() {
  return transformation;
}

public void setTransformation(Matrix m) {
  transformation.set(m);
}

public boolean willRender() {
  return willRender;
}

public void setWillRender() {
  willRender = true;
}

public void setWillNotRender() {
  willRender = false;
}

@Override
public void onCreate(Context context, M m, long timeElapsed, long timeTotal, Camera camera) {
  isInitialized = true;
}

@Override
public void onCollision(M m, ArrayList<Element> collidesWith, long timeElapsed, long timeTotal, int fps, Camera camera) {
}

@Override
public void onUpdate(M m, long timeElapsed, long timeTotal, int fps, Camera camera) {
}

@Override
public void onPreRender(M m, long timeElapsed, long timeTotal, int fps, Camera camera) {
//  if (getDirtyTransform() || camera.isTransformationDirty()) {
  final Transform elementTransform = getTransform();
  transformation.set(elementTransform.getGlobalMatrix());
  final boolean elementHeadsUp = isHeadsUp();
  final boolean elementConstantScale = isConstantScale();
  final boolean headsUpFlip = isHeadsUpFlip();
  if (elementHeadsUp || elementConstantScale || headsUpFlip) {
    float x = elementTransform.getGlobalTransX();
    float y = elementTransform.getGlobalTransY();
    if (elementConstantScale) {
      final float scale = camera.getScale();
      transformation.postScale(scale, scale, x, y);
    }
    if (headsUpFlip) {
      float angle = elementTransform.getRotation() - camera.getRoll();
      angle = (angle + 360) % 360;
      angle = (angle + 360) % 360;
      if (90 < angle && angle < 270) {
        transformation.preRotate(180, 0, 0);
      }
    } else if (elementHeadsUp) {
      transformation.postRotate(-elementTransform.getGlobalRotDgrs() + camera.getRoll(), x, y);
    }
    setDirtyTransform(true);
  }
//  }
  if (getDirtyTransform() || getDirtyShape()) {
    final IShape shape = getShape();
    if (shape != null) {
      final RectF shapeBBox = shape.getBBox();
      if (shapeBBox != null) {
        bbox.set(shapeBBox);
        transformation.mapRect(bbox);
        bbox.offset(offsetX, offsetY);
      }
    }
  }
}

@Override
public void onRender(Canvas canvas, Paint touchPaint) {
}

@Override
public void onDestroy(Context context) {
}

@Override
public void onTouchEvent(IntentTouch intentTouch) {

}

@Override
public IShape getShape() {
  synchronized (iShapeLock) {
    return iShape;
  }
}

@Override
public void setShape(IShape iShape) {
  synchronized (iShapeLock) {
    this.iShape = iShape;
    if (iShape != null) iShape.setElementProxyDirty(this);
    setDirtyShape(true);
  }
}

/**
 * Returns the bbox in Global|Map space
 *
 * @return
 */
@Override
public RectF getBBox() {
  synchronized (bbox) {
    return bbox;
  }
}

/**
 * Ignore shape`s bbox and set this.
 *
 * @param bbox
 */
@Override
public void setBBox(RectF bbox) {
  synchronized (this.bbox) {
    this.bbox.set(bbox);
  }
}

@Override
public void setDirtyStyle(boolean state) {
  synchronized (lockDirtyStyle) {
    this.dirtyStyle = state;
  }
}

@Override
public boolean getDirtyStyle() {
  synchronized (lockDirtyStyle) {
    return dirtyStyle;
  }
}

@Override
public void setDirtyTransform(boolean state) {
  synchronized (lockDirtyTransform) {
    this.dirtyTransform = state;
  }
}

@Override
public boolean getDirtyTransform() {
  synchronized (lockDirtyTransform) {
    return dirtyTransform;
  }
}

@Override
public void setDirtyShape(boolean state) {
  synchronized (lockDirtyShape) {
    dirtyShape = state;
  }
}

@Override
public boolean getDirtyShape() {
  synchronized (lockDirtyShape) {
    return dirtyShape;
  }
}

public Transform getTransform() {
  return transform;
}

/**
 * if the onCreate method has been called on this element
 *
 * @return boolean
 */
public boolean isInitialized() {
  return isInitialized;
}

/**
 * By setting this to true onCreate method wont be called
 *
 * @param isInitialized
 */
public void setIsInitialized(boolean isInitialized) {
  this.isInitialized = isInitialized;
}

public boolean isSelectState() {
  return selectState;
}

public void setSelectState(boolean selectState) {
  if (this.selectState != selectState) setDirtyStyle(true);
  this.selectState = selectState;
}

public boolean isHighlightState() {
  return highlightState;
}

public void setHighlightState(boolean highlightState) {
  if (this.highlightState != highlightState) setDirtyStyle(true);
  this.highlightState = highlightState;
}

/**
 * if the element is active or not.
 *
 * @return
 */
public boolean isActive() {
  return active;
}

/**
 * Sets the active state on || off
 * element wouldn't be visible or receive any updates from the framework.
 *
 * @param active
 */
public void setActive(boolean active) {
  this.active = active;
  synchronized (children) {
    int size = children.size();
    Element element;
    for (int i = 0; i < size; i++) {
      element = children.get(i);
      element.setActive(active);
    }
  }
}

/**
 * if the element is visible or not.
 * @return
 */
public boolean isVisible() {
  return visible;
}

/**
 * Set the visibility flag of this.
 * Elements wont render if set to false.
 * @param visible
 */
public void setVisible(boolean visible) {
  this.visible = visible;
  synchronized (children) {
    int size = children.size();
    Element element;
    for (int i = 0; i < size; i++) {
      element = children.get(i);
      element.setVisible(visible);
    }
  }
}

/**
 * Get the level this element belongs to.
 * @return
 */
public int getLevel() {
  return level;
}

/**
 * Set the level this element will belong to.
 * If the value is -1 it will be visible across all levels or if zero or above it reflects the
 * map it belongs to as an index of the {@link com.jibestream.jibestreamandroidlibrary.main.VenueData#maps}
 * M.VenueData.maps[] array which holds all maps/levels of the particular venue.
 * @param level
 */
public void setLevel(int level) {
  this.level = level;
  synchronized (children) {
    int size = children.size();
    Element element;
    for (int i = 0; i < size; i++) {
      element = children.get(i);
      element.setLevel(level);
    }
  }
  flag_LevelChange.set(true);
}

/**
 * If the element will respond to touch events
 * @return
 */
public boolean isSelectable() {
  return selectable;
}

/**
 * Set if the element will respond to touch events.
 * @param selectable
 */
public void setSelectable(boolean selectable) {
  this.selectable = selectable;
}

/**
 * If the element is highlightable.
 * @return
 */
public boolean isHighlightable() {
  return highlightable;
}

/**
 * If the element will be able to be in a highlight state.
 * @param highlightable
 */
public void setHighlightable(boolean highlightable) {
  this.highlightable = highlightable;
}

public boolean isCollidable() {
  return collidable;
}

public void setCollidable(boolean collidable) {
  this.collidable = collidable;
}

public boolean isBoundingBoxVisible() {
  return boundingBoxVisible;
}

public void setBoundingBoxVisible(boolean boundingBoxVisible) {
  this.boundingBoxVisible = boundingBoxVisible;
}

/**
 * If element is in view space.
 *
 * @return
 */
public boolean isInViewSpace() {
  return inViewSpace;
}

/**
 * If true element ignores any camera transformations,
 * element would appear in view space if true or map space if false.
 *
 * @param inViewSpace
 */
public void setInViewSpace(boolean inViewSpace) {
  this.inViewSpace = inViewSpace;
}

public boolean isHeadsUp() {
  return headsUp;
}

public void setHeadsUp(boolean headsUp) {
  if (this.headsUp == headsUp) return;
  this.headsUp = headsUp;
}

public boolean isHeadsUpFlip() {
  return headsUpFlip;
}

public void setHeadsUpFlip(boolean headsUpFlip) {
  if (this.headsUpFlip == headsUpFlip) return;
  this.headsUpFlip = headsUpFlip;
}

public boolean isConstantScale() {
  return constantScale;
}

public void setConstantScale(boolean constantScale) {
  if (this.constantScale == constantScale) return;
  this.constantScale = constantScale;
}

// TODO: 2015-10-27 to address sorting issue in collision loop
@Override
public int compareTo(@NonNull Element another) {
  return this.id - another.id;
}

/**
 * Returns the render offset X
 *
 * @return
 */
@Override
public float getOffsetX() {
  synchronized (lockOffsets) {
    return offsetX;
  }
}

/**
 * sets the render offset X
 */
@Override
public void setOffsetX(float offsetX) {
  synchronized (lockOffsets) {
    this.offsetX = offsetX;
  }
  setDirtyShape(true);
}

/**
 * Returns the render offset Y
 *
 * @return
 */
@Override
public float getOffsetY() {
  synchronized (lockOffsets) {
    return offsetY;
  }
}

/**
 * sets the render offset Y
 */
@Override
public void setOffsetY(float offsetY) {
  synchronized (lockOffsets) {
    this.offsetY = offsetY;
  }
  setDirtyShape(true);
}

}
