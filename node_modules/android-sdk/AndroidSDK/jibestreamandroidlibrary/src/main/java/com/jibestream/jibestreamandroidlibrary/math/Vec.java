package com.jibestream.jibestreamandroidlibrary.math;

/**
 * Vector math utility class
 * Created by Emmanuel on 27/12/13.
 */
public class Vec {
public final static Vec ZERO = new Vec(0, 0);
public final static Vec X = new Vec(1f, 0);
public final static Vec Y = new Vec(0, 1f);
//public final static Vec tmp = new Vec();
private float x;
private float y;
private final Object lockX = new Object();
private final Object lockY = new Object();

public Vec(Vec src) {
  x = src.x;
  y = src.y;
}

public Vec() {
  x = y = 0;
}

public Vec(float x, float y) {
  this.x = x;
  this.y = y;
}

public float getX() {
  synchronized (lockX) {
    return x;
  }
}

public float getY() {
  synchronized (lockY) {
    return y;
  }
}

public void setX(float x) {
  synchronized (lockX) {
    this.x = x;
  }
}

public void setY(float y) {
  synchronized (lockY) {
    this.y = y;
  }
}

public void setXY(float x, float y) {
  synchronized (lockX) {
    this.x = x;
  }
  synchronized (lockY) {
    this.y = y;
  }
}

/**
 * Vector addition
 *
 * @param vecA
 * @param vecB
 * @return A new vector
 */
public static Vec add(Vec vecA, Vec vecB) {
  Vec sum = new Vec();
  sum.set(vecA.getX() + vecB.getX(), vecA.getY() + vecB.getY());
  return sum;
}

/**
 * Vector subtraction
 *
 * @param vecA
 * @param vecB
 * @return A new vector
 */
public static Vec sub(Vec vecA, Vec vecB) {
  Vec dif = new Vec();
  dif.set(vecA.getX() - vecB.getX(), vecA.getY() - vecB.getY());
  return dif;
}

/**
 * Scalar multiplication of a vector by a float
 *
 * @param vecA
 * @param amount
 * @return A new Vector with the resulting product
 */
public static Vec mul(Vec vecA, float amount) {
  Vec prd = new Vec();
  prd.set(vecA.getX() * amount, vecA.getY() * amount);
  return prd;
}

/**
 * Multiplication of two vectors
 *
 * @param vecA
 * @param vecB
 * @return A new Vector with the resulting product
 */
public static Vec mul(Vec vecA, Vec vecB) {
  Vec prd = new Vec();
  prd.set(vecA.getX() * vecB.getX(), vecA.getY() * vecB.getY());
  return prd;
}

/**
 * Normal of the input vector
 *
 * @param vec
 * @return a new vector normalized.
 */
public static Vec nrm(Vec vec) {
  Vec nrm = new Vec(vec.getX(), vec.getY());
  nrm.nrm();
  return nrm;
}

/**
 * Cross product of input vectors
 *
 * @param vecA
 * @param vecB
 * @return
 */
/*
uxv	=	u.x * v.y - u.y * v.x,
http://mathworld.wolfram.com/CrossProduct.html
The polarity dictates the side the Vec is
 */
public static float crs(Vec vecA, Vec vecB) {
  float crs;
  crs = vecA.getX() * vecB.getY() - vecA.getY() * vecB.getX();
  return crs;
}

/**
 * Reset the vector to zero
 *
 * @return The zero vector
 */
public Vec rst() {
  synchronized (lockX) {
    x = 0;
  }
  synchronized (lockY) {
    y = 0;
  }
  return this;
}

/**
 * Clone this vector
 *
 * @return A clone of this vector
 */
public Vec cln() {
  synchronized (lockX) {
    synchronized (lockY) {
      return new Vec(x, y);
    }
  }
}

/**
 * Set the x and y of the vector
 *
 * @param x
 * @param y
 * @return
 */
public Vec set(float x, float y) {
  synchronized (lockX) {
    this.x = x;
  }
  synchronized (lockY) {
    this.y = y;
  }
  return this;
}

/**
 * Set this vector to have the same x and y as
 * another vector
 *
 * @param vec
 * @return
 */
public Vec set(Vec vec) {
  synchronized (lockX) {
    this.x = vec.getX();
  }
  synchronized (lockY) {
    this.y = vec.getY();
  }
  return this;
}

/**
 * Add another vector to this vector
 *
 * @param vec
 * @return
 */
public Vec add(Vec vec) {
  synchronized (lockX) {
    x += vec.getX();
  }
  synchronized (lockY) {
    y += vec.getY();
  }
  return this;
}

/**
 * Add x and y to this vector's x and y
 *
 * @param x
 * @param y
 * @return
 */
public Vec add(float x, float y) {
  synchronized (lockX) {
    this.x += x;
  }
  synchronized (lockY) {
    this.y += y;
  }
  return this;
}


public Vec addX(float x) {
  synchronized (lockX) {
    this.x += x;
  }
  return this;
}


public Vec addY(float y) {
  synchronized (lockY) {
    this.y += y;
  }
  return this;
}

/**
 * Subtract another vector from this vector
 *
 * @param vec
 * @return
 */
public Vec sub(Vec vec) {
  synchronized (lockX) {
    x -= vec.getX();
  }
  synchronized (lockY) {
    y -= vec.getY();
  }
  return this;
}

/**
 * Subtract x and y from this vector
 *
 * @param x
 * @param y
 * @return
 */
public Vec sub(float x, float y) {
  synchronized (lockX) {
    this.x -= x;
  }
  synchronized (lockY) {
    this.y -= y;
  }
  return this;
}

public Vec subX(float x) {
  synchronized (lockX) {
    this.x -= x;
  }
  return this;
}

public Vec subY(float y) {
  synchronized (lockY) {
    this.y -= y;
  }
  return this;
}

/**
 * Scalar multiplication of this vector by an amount
 *
 * @param amount
 * @return
 */
public Vec mul(float amount) {
  synchronized (lockX) {
    x *= amount;
  }
  synchronized (lockY) {
    y *= amount;
  }
  return this;
}

/**
 * TODO: Check this
 *
 * @param vec
 * @return
 */
public Vec mul(Vec vec) {
  synchronized (lockX) {
    x *= vec.getX();
  }
  synchronized (lockY) {
    y *= vec.getY();
  }
  return this;
}

/**
 * Multuplication of each component with the relative input
 *
 * @param x
 * @param y
 * @return
 */
public Vec mul(float x, float y) {
  synchronized (lockX) {
    this.x *= x;
  }
  synchronized (lockY) {
    this.y *= y;
  }
  return this;
}

/**
 * Inverse scalar multiplication of this vector
 *
 * @param amount
 * @return
 */
public Vec div(float amount) {
  synchronized (lockX) {
    x /= amount;
  }
  synchronized (lockY) {
    y /= amount;
  }
  return this;
}

/**
 * Division of each component by inputs components
 *
 * @param vec
 * @return
 */
public Vec div(Vec vec) {
  synchronized (lockX) {
    x /= vec.getX();
  }
  synchronized (lockY) {
    y /= vec.getY();
  }
  return this;
}

/**
 * Division of each component with relative input
 *
 * @param x
 * @param y
 * @return
 */
public Vec div(float x, float y) {
  synchronized (lockX) {
    this.x /= x;
  }
  synchronized (lockY) {
    this.y /= y;
  }
  return this;
}

/**
 * Length of this vector
 *
 * @return
 */
public float len() {
  return (float) Math.sqrt(lenSqr());
}

/**
 * This vector squared
 *
 * @return
 */
public float lenSqr() {
  synchronized (lockX) {
    synchronized (lockY) {
      return x * x + y * y;
    }
  }
}

/**
 * The inverse of this vector
 *
 * @return
 */
public Vec inv() {
  synchronized (lockX) {
    x = x * -1f;
  }
  synchronized (lockY) {
    y = y * -1f;
  }
  return this;
}

/**
 * Normalize this vector
 *
 * @return
 */
public Vec nrm() {
  float resip = 1.0f / len();
  synchronized (lockX) {
    x *= resip;
  }
  synchronized (lockY) {
    y *= resip;
  }
  return this;
}


/**
 * Dot product of this vector and another vector
 * <p/>
 * a•b = axbx + ayby
 *
 * @param vec
 * @return
 */
public float dot(Vec vec) {
  float v;
  synchronized (lockX) {
    synchronized (lockY) {
      v = x * vec.getX() + y * vec.getY();
    }
  }
  return v;
}

/**
 * Pseudo Cross product of this vector with input
 * The polarity dictates the side the Vec is
 */
public float crs(Vec vec) {
  float crs;
  synchronized (lockX) {
    synchronized (lockY) {
      crs = x * vec.getY() - y * vec.getX();
    }
  }
  return crs;
}

/**
 * Returns a perpendicular vector
 */
public Vec crs() {
  Vec vec;
  synchronized (lockX) {
    synchronized (lockY) {
      vec = new Vec(y, -x);
    }
  }
  return vec;
}

/**
 * Vector`s angle in radians
 *
 * @return angle in radians
 */
public float angleRad() {
  float atan2;
  synchronized (lockX) {
    synchronized (lockY) {
      atan2 = (float) Math.atan2(y, x);
    }
  }
  return atan2;
}

/**
 * Vector`s angle in degrees
 *
 * @return angle in degrees
 */
public float angleDgrs() {
  return (float) Math.toDegrees(angleRad());
}

/**
 * Returns angle between two unit vectors a b
 * From   a•b = |a|•|b|•cos(∂)
 * can be simplified to
 * ' a•b = 1•1•cos(∂) =>
 * ∂ = arcos( a•b )'
 */
public float angleRad(Vec vec) {
  final float dot = dot(vec);
  final float rads = (float) Math.acos(dot);
  return rads;
}

/**
 * Angle between two vectors in degrees
 *
 * @param vec
 * @return
 */
public float angleDeg(Vec vec) {
  return (float) Math.toDegrees(angleRad(vec));
}

/**
 * Sets the x and y from polar coordinates
 *
 * @param angle  the angle in radians
 * @param radius
 * @return
 */
public Vec setFromPolar(float angle, float radius) {
  synchronized (lockX) {
    x = (float) Math.cos(angle) * radius;
  }
  synchronized (lockY) {
    y = (float) Math.sin(angle) * radius;
  }
  return this;
}

/**
 * Vector to array of floats
 *
 * @return Three component array
 */
public float[] toArray() {
  float[] floats = new float[3];
  synchronized (lockX) {
    floats[0] = x;
  }
  synchronized (lockY) {
    floats[1] = y;
  }
  floats[2] = 1f;
  return floats;
}

public boolean isEqual(Vec v) {
  boolean result = false;
  synchronized (lockX) {
    synchronized (lockY) {
      if (x == v.getX() && y == v.getY()) result = true;
    }
  }
  return result;
}

public String toString() {
  return "[ " + x + ", " + y + " ]";
}

}
