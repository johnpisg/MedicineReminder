package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter;

import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.Helpers;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.TDConsecutive;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.TDInstruction;

import java.util.ArrayList;

/**
 * Created by frankduffy on 2016-01-27.
 */
public class ComboDirections {
    public void comboDirections(TDFilterInput inst) {

        Helpers hlp = new Helpers();
        int loopTo = inst.textDirectionsFloorArray.size() - 1;
        ArrayList<String> consecutiveArrayDirection = new ArrayList<String>();
        ArrayList<Number> consecutiveArrayTimes = new ArrayList<Number>();
        TDInstruction firstConsecutiveInstruction = null;

        for(int i = 1; i < loopTo; i++) {
            // Fold second last
            TDInstruction currentInstruction = inst.textDirectionsFloorArray.get(i);

            // Different landmark?
            if((firstConsecutiveInstruction == null) || (firstConsecutiveInstruction.landmarkDestination.id != currentInstruction.landmarkDestination.id)) {
                // Process array if more than 1
                if(consecutiveArrayDirection.size() > 1) {

                    String combinedDirections = "";
                    String nextDirection = "";
                    // combo directions tracker
                    ArrayList<TDConsecutive> consecutive = new ArrayList<>();

                    for(int j = 0; j < consecutiveArrayDirection.size(); j++) {
                        nextDirection = consecutiveArrayDirection.get(j);
                        Number nextDirectionTimes = consecutiveArrayTimes.get(j);

                        // Avoid "Forward" unless this is the last textDirection
                        boolean canPass = true;

                        if((nextDirection.toLowerCase().equals("forward")) && (j < (consecutiveArrayDirection.size()-1)))
                        // -1 is to allow for last consecutive direction to be Forward
                        {
                            // Do not process
                            canPass = false;
                        }
                        if(canPass) {
                            // Make string
                            String nextCombinedDirection = "";
                            // Singular or plural
                            if(nextDirectionTimes.intValue() == 1) {
                                // Singular
                                nextCombinedDirection = nextDirection.toString();
                            } else {
                                // Plural
                                ArrayList<String> stringList = new ArrayList<String>();
                                stringList.add("% % times");
                                stringList.add(nextDirection);
                                stringList.add(nextDirectionTimes.toString());
                                nextCombinedDirection = hlp.stringWithFormat(stringList);
                            }

                            TDConsecutive tdConsecutive = new TDConsecutive();
                            tdConsecutive.nextDirection = nextDirection;
                            tdConsecutive.nextDirectionTimes = nextDirectionTimes;
                            consecutive.add(tdConsecutive);

                            // Last?
                            if(j != (consecutiveArrayDirection.size()-1)) {
                                // Not Last
                                nextCombinedDirection += ", then ";
                            }

                            // combinedDirections
                            combinedDirections += nextCombinedDirection;
                        }
                    }

                    // Combine firstConsecutiveInstruction output
                    ArrayList<String> stringList = new ArrayList<String>();
                    stringList.add("With % on your %, go %");
                    stringList.add(firstConsecutiveInstruction.landmarkDestination.name);
                    stringList.add(firstConsecutiveInstruction.directionToLandmark);
                    stringList.add(combinedDirections);
                    String newOutput = hlp.stringWithFormat(stringList);

                    //Remove first item in consecutive array, belongs to initial instruction
                    consecutive.remove(0);

                    // Update
                    firstConsecutiveInstruction.type = "combo";
                    firstConsecutiveInstruction.secondaryDirections = consecutive;
                    firstConsecutiveInstruction.output = newOutput;
                }

                // Reset array
                consecutiveArrayDirection = new ArrayList<String>();
                consecutiveArrayTimes = new ArrayList<Number>();

                // Next consecutive
                firstConsecutiveInstruction = currentInstruction;

                // Add first direction
                consecutiveArrayDirection.add(firstConsecutiveInstruction.direction);
                consecutiveArrayTimes.add(1);
            } else {
                // Add direction to array
                // Unless the last direction is same as this one, then add another step to it
                String lastObject = consecutiveArrayDirection.get(consecutiveArrayDirection.size()-1);
                // NOTE: Do not count up in case of Forward.
                // Bad:  With X on your Left, go Forward 3 times.
                // Good: With X on your Left, go Forward
                if(lastObject.toLowerCase().equals(currentInstruction.direction.toLowerCase())) {
                    String current_dir = currentInstruction.direction.toLowerCase();
                    if(!current_dir.equals("forward")) {
                        // Inc one more
                        int currentCounter = consecutiveArrayTimes.get(consecutiveArrayTimes.size()-1).intValue();
                        currentCounter++;
                        // Delete last object
                        consecutiveArrayTimes.remove(consecutiveArrayTimes.size()-1);
                        // Add new
                        consecutiveArrayTimes.add(currentCounter);
                    }
                } else {
                    // Add first different direction
                    consecutiveArrayDirection.add(currentInstruction.direction);
                    consecutiveArrayTimes.add(1);
                }

                // Fold current into firstConsecutiveInstruction
                firstConsecutiveInstruction.foldInFront(currentInstruction);

                // Remove from textDirectionsFloorArray
                inst.textDirectionsFloorArray.remove(i);

                // Dec loopTo
                loopTo--;
                // Go back one index
                i--;
            }
        }
        // Add from here:

        // Process array if more than 1
        if(consecutiveArrayDirection.size() > 1) {
            // combinedDirections
            String combinedDirections = "";
            String nextDirection = "";
            // combo directions tracker
            ArrayList<TDConsecutive> consecutive = new ArrayList<>();
            for(int j = 0; j < consecutiveArrayDirection.size(); j++) {
                nextDirection = consecutiveArrayDirection.get(j);
                Number nextDirectionTimes = consecutiveArrayTimes.get(j);
                // Avoid "Forward" unless this is the last textDirection
                boolean canPass = true;

                if((nextDirection.toLowerCase().equals("forward")) && (j < (consecutiveArrayDirection.size()-1)))
                // -1 is to allow for last consecutive direction to be Forward
                {
                    // Do not process
                    canPass = false;
                }
                if(canPass) {
                    // Make string
                    String nextCombinedDirection = "";
                    // Singular or plural
                    if(nextDirectionTimes.intValue() == 1) {
                        nextCombinedDirection = nextDirection.toString();
                    } else {
                        ArrayList<String> stringList = new ArrayList<String>();
                        stringList.add("% % times");
                        stringList.add(nextDirection);
                        stringList.add(nextDirectionTimes.toString());
                        nextCombinedDirection = hlp.stringWithFormat(stringList);
                    }

                    TDConsecutive tdConsecutive = new TDConsecutive();
                    tdConsecutive.nextDirection = nextDirection;
                    tdConsecutive.nextDirectionTimes = nextDirectionTimes;
                    consecutive.add(tdConsecutive);

                    // Last?
                    if(j != (consecutiveArrayDirection.size()-1)) {
                        // Not Last
                        nextCombinedDirection += ", then ";
                    }
                    // combinedDirections
                    combinedDirections += nextCombinedDirection;
                }
            }

            // Combine firstConsecutiveInstruction output
            ArrayList<String> stringList = new ArrayList<String>();
            stringList.add("With % on your %, go %");
            stringList.add(firstConsecutiveInstruction.landmarkDestination.name);
            stringList.add(firstConsecutiveInstruction.directionToLandmark);
            stringList.add(combinedDirections);
            String newOutput = hlp.stringWithFormat(stringList);

            //Remove first item in consecutive array, belongs to initial instruction
            consecutive.remove(0);

            firstConsecutiveInstruction.type = "combo";
            firstConsecutiveInstruction.secondaryDirections = consecutive;
            firstConsecutiveInstruction.output = newOutput;
        }


    }
}