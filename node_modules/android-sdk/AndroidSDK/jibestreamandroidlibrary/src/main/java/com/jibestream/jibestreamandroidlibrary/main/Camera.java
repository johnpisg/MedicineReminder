package com.jibestream.jibestreamandroidlibrary.main;

import android.content.Context;
import android.graphics.Matrix;
import android.graphics.Rect;
import android.graphics.RectF;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;
import android.view.Choreographer;
import android.view.ViewConfiguration;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;


/**
 * Wrapper for a view matrix, simulates a camera by removing the complexity of manipulating the view matrix.
 * Users do not need to instantiate this object the SDK will do it and its available as a field on the {@link M} instance
 * Created by emmanuel on 15-06-22.
 */
public class Camera implements Choreographer.FrameCallback {
public static final float FRICTION_MULTIPLIER = 0.0625f;
private static final String TAG = "Camera";
private static final float CAST_MULTI = 10000f;
private static final float CAST_MULTI_RECIP = 1f / CAST_MULTI;
private final Matrix matrix = new Matrix();
private final Matrix out = new Matrix();
private final Matrix outPrev = new Matrix();
private final float[] fovPoints = new float[8];
public final float[] normals = new float[4];
public final double[] projectedMin = new double[4];
public final double[] projectedMax = new double[4];
private RectF fovBBox = new RectF();
private float rollDgrs;
private float scale;
private float x;
private float y;
private float xPrev;
private float yPrev;
private float zoomOutMax;
private float zoomInMax = 32;
private float zoomRange;
private float scaleUnit;
private final Rect viewport = new Rect();
private final RectF contentSize = new RectF();
private final RectF availableCamRegion = new RectF();
private float mapWidthScreenSpace;
private float mapHeightSceenSpace;
public float fovWidthScreenSpace;
public float fovHeightScreenSpace;
private float zoom;
public float lastPivotX;
public float lastPivotY;
private Object lockTransformation = new Object();
private Object lockIsUserInteracting = new Object();
private Object lockIsFling = new Object();
private Object lockIsTransformationDirty = new Object();
private boolean isUserInteracting;
private boolean isFling;
private boolean isTransformationDirty;
private long timeStampInMillis;
private long timeStampInMillisPrev;
private static final int INIT = 0;
private static final int RESET = 1;
private static final int UPDATE = 2;
private static final int SET_VIEWPORT = 3;
private static final int SET_CONTENT_SIZE = 4;
private static final int IS_USER_INTERACTING = 5;
private static final int FORCE_FINISH = 6;
private static final int SET_SCALE = 100;
private static final int SET_ROTATE = 101;
private static final int SET_TRANSLATE = 102;
private static final int ADD_SCALE = 103;
private static final int ADD_ROTATE = 104;
private static final int ADD_TRANSLATE = 105;
private static final int ADD_SCALE_PIVOTS = 106;
private static final int ADD_ROTATE_PIVOTS = 107;
private static final int ZOOM_TO = 108;
private static final int FLING = 109;
private static final int ADD_TRANSLATE_GLB = 110;
//
private OverScrollerF scroller;
private final Handler handler;
private final Handler.Callback callback = new Handler.Callback() {
  @Override
  public boolean handleMessage(Message msg) {
    //region switch statement
    switch (msg.what) {
      case INIT:
//        _init();
        break;
      case RESET:
        _reset();
        break;
      case UPDATE:

        break;
      case SET_VIEWPORT:
//        _setViewport(msg.arg1, msg.arg2);
        break;
      case SET_CONTENT_SIZE:
        _setContentSize((RectF) msg.obj);
        break;
      case IS_USER_INTERACTING:
        _setIsUserInteracting((Boolean) msg.obj);
        break;
      case FORCE_FINISH:
        _forceFinish();
        break;
      case SET_SCALE:
        _setScale((Float) msg.obj);
        break;
      case ADD_SCALE:
        _addScale((Float) msg.obj);
        break;
      case ZOOM_TO:
        _zoomTo((RectF) msg.obj, msg.arg1);
        break;
      case ADD_SCALE_PIVOTS:
        _addS((Float) msg.obj, msg.arg1, msg.arg2);
        break;
      case SET_ROTATE:
        _setRoll((Float) msg.obj);
        break;
      case ADD_ROTATE:
        _addRoll((Float) msg.obj);
        break;
      case ADD_ROTATE_PIVOTS:
        _addRoll((Float) msg.obj, msg.arg1, msg.arg2);
        break;
      case SET_TRANSLATE:
        _setTranslation(msg.arg1, msg.arg2);
        break;
      case ADD_TRANSLATE:
        _addTranslate(msg.arg1, msg.arg2);
        break;
      case FLING:
        _fling(msg.arg1, msg.arg2);
        break;
      case ADD_TRANSLATE_GLB:
        _addTranslateGlbl(msg.arg1, msg.arg2);
        break;
    }
    return false;
    //endregion
  }
};
public float deltaX;
public float deltaY;

// TODO: 2016-04-15 lock rest of values
public Camera(Context context, Looper looper) {
  scroller = new OverScrollerF(context);
  final float scrollFriction = ViewConfiguration.getScrollFriction();
  scroller.setFriction(scrollFriction * FRICTION_MULTIPLIER);
  handler = new Handler(looper, callback);
  validate();
}

private void validate() {
  if (viewport.isEmpty()) return;
  if (contentSize.isEmpty()) return;
  //
    float vW = viewport.width();
    float vH = viewport.height();
    float viewportHyp = (float) Math.sqrt(vW * vW + vH * vH);
    float smallestContentSide = Math.min(contentSize.width(), contentSize.height());
    zoomOutMax = viewportHyp / smallestContentSide;
    zoomRange = zoomInMax - zoomOutMax;
    //constraint scale
    zoom = 1f / scale;
    if (zoom < zoomOutMax) {
      scale = 1f / zoomOutMax;
      zoom = zoomOutMax;
    }
    if (zoom > zoomInMax) {
      scale = 1f / zoomInMax;
      zoom = 1f / scale;
    }
    // wrap roll
    rollDgrs = rollDgrs % 360;
    if (rollDgrs < 0) rollDgrs += 360;
    //
    viewportHyp *= 0.5f;
    viewportHyp *= scale;
    availableCamRegion.left = viewportHyp;
    availableCamRegion.top = viewportHyp;
    availableCamRegion.right = contentSize.width() - viewportHyp;
    availableCamRegion.bottom = contentSize.height() - viewportHyp;
    //constraint translate
    if (scroller.isFinished()) {
      if (x < availableCamRegion.left) {
        x = availableCamRegion.left;
      }
      if (y < availableCamRegion.top) {
        y = availableCamRegion.top;
      }
      if (x > availableCamRegion.right) {
        x = availableCamRegion.right;
      }
      if (y > availableCamRegion.bottom) {
        y = availableCamRegion.bottom;
      }
    }
    //
    matrix.reset();
    matrix.postTranslate(-viewport.centerX(), -viewport.centerY());
    matrix.postScale(scale, scale);
    matrix.postRotate(rollDgrs);
    matrix.postTranslate(x, y);
    //>>
    fovPoints[0] = viewport.left;
    fovPoints[1] = viewport.top;
    fovPoints[2] = viewport.right;
    fovPoints[3] = viewport.top;
    fovPoints[4] = viewport.right;
    fovPoints[5] = viewport.bottom;
    fovPoints[6] = viewport.left;
    fovPoints[7] = viewport.bottom;
    matrix.mapPoints(fovPoints);
    fovBBox.set(viewport);
    matrix.mapRect(fovBBox);
    //<<
  synchronized (lockTransformation) {
    outPrev.set(out);
    out.reset();
    out.postTranslate(-x, -y);
    out.postRotate(-rollDgrs);
    out.postScale(zoom, zoom);
    out.postTranslate(viewport.centerX(), viewport.centerY());
  }
    //
    fovWidthScreenSpace = viewport.width() * zoom;
    fovHeightScreenSpace = viewport.height() * zoom;
    //
    mapWidthScreenSpace = contentSize.width() * scale;
    mapHeightSceenSpace = contentSize.height() * scale;
    //
    scaleUnit = (zoom - zoomOutMax) / zoomRange;
    //
    float vX, vY, normalX, normalY;
    vX = fovPoints[2] - fovPoints[0];
    vY = fovPoints[3] - fovPoints[1];
    normalX = vY;
    normalY = -vX;
    normals[0] = normalX;
    normals[1] = normalY;
    vX = fovPoints[4] - fovPoints[2];
    vY = fovPoints[5] - fovPoints[3];
    normalX = vY;
    normalY = -vX;
    normals[2] = normalX;
    normals[3] = normalY;
    //
    for (int i = 0; i < 4; i += 2) {
      projectedMin[i] = Double.POSITIVE_INFINITY;
      projectedMax[i] = Double.NEGATIVE_INFINITY;
      normalX = normals[i];
      normalY = normals[i + 1];
      for (int j = 0; j < 8; j += 2) {
        float pX = fovPoints[j];
        float pY = fovPoints[j + 1];
        double projected = normalX * pX + normalY * pY;
        if (projected < projectedMin[i]) projectedMin[i] = projected;
        if (projected > projectedMax[i]) projectedMax[i] = projected;
      }
    }
    //
    timeStampInMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
    float tD = timeStampInMillisPrev - timeStampInMillis;
    timeStampInMillisPrev = timeStampInMillis;
    float xD = x - xPrev;
    float yD = y - yPrev;
    xPrev = x;
    yPrev = y;
    deltaX = xD;
    deltaY = yD;
//  if (tD != 0) {
//    velocityX = xD / tD;
//    velocityY = yD / tD;
//  } else {
//    velocityX = 0;
//    velocityY = 0;
//  }
    //
    isTransformationDirty = true;
  }

public void forceFinish() {
  final Message message = handler.obtainMessage(FORCE_FINISH);
  handler.sendMessage(message);
}

private void _forceFinish() {
  scroller.forceFinished(true);
  Choreographer.getInstance().removeFrameCallback(this);
  isFling = false;
}

protected void init() {
//  final Message message = handler.obtainMessage(INIT);
//  handler.sendMessage(message);
//}
//
//private void _init() {
  handler.removeCallbacksAndMessages(null);
  //
  matrix.reset();
  out.reset();
  Arrays.fill(fovPoints, 0);
  fovBBox.set(0, 0, 0, 0);
  rollDgrs = 0;
  scale = 0;
  x = 0;
  y = 0;
  zoomOutMax = 0;
  zoomInMax = 32;
  zoomRange = 0;
  scaleUnit = 0;
  viewport.set(0, 0, 0, 0);
  contentSize.set(0, 0, 0, 0);
  availableCamRegion.set(0, 0, 0, 0);
  mapWidthScreenSpace = 0;
  mapHeightSceenSpace = 0;
  fovWidthScreenSpace = 0;
  fovHeightScreenSpace = 0;
  zoom = 0;
  lastPivotX = 0;
  lastPivotY = 0;
  isTransformationDirty = false;
  isUserInteracting = false;
  isFling = false;
  validate();
}

/**
 * reset the camera
 */
public void reset() {
  final Message message = handler.obtainMessage(RESET);
  handler.sendMessage(message);
}

private void _reset() {
  _forceFinish();
  matrix.reset();
  out.reset();
  final boolean empty = contentSize.isEmpty();
  if (!empty) {
    x = contentSize.centerX();
    y = contentSize.centerY();
  } else {
    x = 0;
    y = 0;
  }
  rollDgrs = 0;
  scale = 1;
  validate();
}

public float[] screenToGlobal(float viewportX, float viewportY) {
  float[] glbs = new float[2];
  float vX = viewportX - viewport.centerX();
  float vY = viewportY - viewport.centerY();
  vX /= zoom;
  vY /= zoom;
  double rollRads = Math.toRadians(rollDgrs);
  double s = Math.sin(rollRads);
  double c = Math.cos(rollRads);
  float vXX = (float) (vX * c - vY * s);
  float vYY = (float) (vY * c + vX * s);
  glbs[0] = vXX + x;
  glbs[1] = vYY + y;
  return glbs;
}

public Matrix getMatrix() {
  synchronized (lockTransformation) {
    return new Matrix(out);
  }
}

// TODO: 2016-05-17 use this for efficiency
/**
 * Copies the camera`s matrix values to this
 *
 * @param m
 * @return
 */
public Matrix copyMatrix(Matrix m) {
  synchronized (lockTransformation) {
    m.set(out);
  }
  return m;
}

private void setComponentsFromMatrix(Matrix matrix) {
  float[] matrixArray = new float[9];
  matrix.getValues(matrixArray);
  float skY = matrixArray[Matrix.MSKEW_Y];
  float scY = matrixArray[Matrix.MSCALE_Y];
  scale = (float) (1f / Math.sqrt(skY * skY + scY * scY));
  double rollRads = Math.atan2(skY, scY);
  rollDgrs = (float) Math.toDegrees(rollRads);
  rollDgrs = (rollDgrs + 360) % 360;
  x = -matrixArray[Matrix.MTRANS_X];
  y = -matrixArray[Matrix.MTRANS_Y];
  validate();
}

////////////////////////////////////////////////////////////////////////// SCALE
public void setScale(float amount) {
  Message message = handler.obtainMessage(SET_SCALE, amount * CAST_MULTI);
  handler.sendMessage(message);
}

private void _setScale(float amount) {
  amount *= CAST_MULTI_RECIP;
  if (amount == 0) return;
  _forceFinish();
  scale = amount;
  validate();
}

/**
 * Additive zooming by post scaling the camera matrix around the
 * center of the screen.
 * Input value will be capped to min and max values defined
 * on the camera.
 *
 * @param amount
 */
public void addScale(float amount) {
  Message message = handler.obtainMessage(ADD_SCALE, amount * CAST_MULTI);
  handler.sendMessage(message);
}

private void _addScale(float amount) {
  amount *= CAST_MULTI_RECIP;
  if (amount == 0) return;
  _forceFinish();
  scale += amount;
  validate();
}

/**
 * Stepped zoom-in by 25%
 */
public void zoomIn() {
  setScale(scale - scale * 0.25f);
}

/**
 * Stepped zoom-out by 25%
 */
public void zoomOut() {
  setScale(scale + scale * 0.25f);
}

/**
 * Zoom to the specific region
 *
 * @param region the region to zoom to
 */
public void zoomTo(RectF region) {
  zoomTo(region, 0);
}

public void zoomTo(RectF region, int padding) {
  Message message = handler.obtainMessage(ZOOM_TO, padding, padding, region);
  handler.sendMessage(message);
}

private void _zoomTo(RectF region, int padding) {
  if (region == null || region.width() == 0 || region.height() == 0) return;
  if (viewport.isEmpty()) {
    zoomTo(region, padding);
    return;
  }
  _forceFinish();
  region = new RectF(region);
  region.inset(-padding, -padding);
  RectF viewport = new RectF(this.viewport);
  viewport.offset(-this.viewport.centerX(), -this.viewport.centerY());
  boolean canMap = out.setRectToRect(region, viewport, Matrix.ScaleToFit.CENTER);
  if (!canMap) return;
//    out.postRotate(rollDgrs, viewport.centerX(), viewport.centerY());

  float[] matrixArray = new float[9];
  out.getValues(matrixArray);
  float skY = matrixArray[Matrix.MSKEW_Y];
  float scY = matrixArray[Matrix.MSCALE_Y];
  scale = (float) (1f / Math.sqrt(skY * skY + scY * scY));
//  double rollRads = Math.atan2(skY, scY);
//    rollDgrs = (float) Math.toDegrees(rollRads);
  x = matrixArray[Matrix.MTRANS_X] * -scale;
  y = matrixArray[Matrix.MTRANS_Y] * -scale;
  validate();
}


/**
 * Allows to set the camera scale around a pivot point.
 * Useful for manipulation from touch events.
 *
 * @param amount
 * @param pivotX
 * @param pivotY
 */
public void addS(float amount, float pivotX, float pivotY) {
  Message message = handler.obtainMessage(ADD_SCALE_PIVOTS, (int) (pivotX * CAST_MULTI), (int) (pivotY * CAST_MULTI), amount);
  handler.sendMessage(message);
}

private void _addS(float amount, float pivotX, float pivotY) {
  pivotX *= CAST_MULTI_RECIP;
  pivotY *= CAST_MULTI_RECIP;
  if (amount == 0) return;
  lastPivotX = pivotX;
  lastPivotY = pivotY;
  _forceFinish();

  scale /= amount;
  float[] globlPivot = screenToGlobal(pivotX, pivotY);
  float vX = x - globlPivot[0];
  float vY = y - globlPivot[1];
  x += vX * (1f - amount);
  y += vY * (1f - amount);
  validate();
}

public void framePerCent(float percent) {
  percent /= 100f;
  float scaleDesired = percent * zoomRange + zoomOutMax;
  scaleDesired = 1f / scaleDesired;
  setScale(scaleDesired);
}

//public float getFramePerCent() {
//  return (scaleUnit) * 100f;
//}

public float getScale() {
  return scale;
}

public float getZoom() {
  return zoom;
}

public float getZoomInMax() {
  return zoomInMax;
}

public void setZoomInMax(float zoomInMax) {
  this.zoomInMax = zoomInMax;
  validate();
}

/**
 * Gets the normalized value of the zoom factor;
 *
 * @return a float with a range from 0 to 1
 */
public float getScaleUnit() {
  return scaleUnit;
}

public void zoomOutMax() {
  scale = zoomInMax;
  validate();
}

public void zoomInMax() {
  scale = zoomOutMax;
  validate();
}
////////////////////////////////////////////////////////////////////////// ROTATION

/**
 * start the rotation of the camera in degrees.
 * Values range from -180 to 180
 *
 * @return degrees of rotarion.
 */
public float getRoll() {
  return rollDgrs;
}

public void setRoll(float dgr) {
  Message message = handler.obtainMessage(SET_ROTATE, dgr * CAST_MULTI);
  handler.sendMessage(message);
}

private void _setRoll(float dgr) {
  dgr *= CAST_MULTI_RECIP;
  _forceFinish();
  rollDgrs = dgr;
  validate();
}

/**
 * roatates camera a certain amount in unit degrees
 *
 * @param dgr degree values
 */
public void addRoll(float dgr) {
  Message message = handler.obtainMessage(ADD_ROTATE, dgr * CAST_MULTI);
  handler.sendMessage(message);
}

private void _addRoll(float dgr) {
  dgr *= CAST_MULTI_RECIP;
  _forceFinish();
  rollDgrs += dgr;
  validate();
}

/**
 * Allows to set the camera rotation around a pivot point.
 * Useful for manipulation from touch events.
 *
 * @param dgr
 * @param pivotX
 * @param pivotY
 */
public void addRoll(float dgr, float pivotX, float pivotY) {
  Message message = handler.obtainMessage(ADD_ROTATE_PIVOTS, (int) (pivotX * CAST_MULTI), (int) (pivotY * CAST_MULTI), dgr);
  handler.sendMessage(message);
}

private void _addRoll(float dgr, float pivotX, float pivotY) {
  pivotX *= CAST_MULTI_RECIP;
  pivotY *= CAST_MULTI_RECIP;
  lastPivotX = pivotX;
  lastPivotY = pivotY;
  _forceFinish();

  float vX, vY;
  double rollRads, vYY, s, c, vXX;
  float[] globlPivot = screenToGlobal(pivotX, pivotY);
  vX = x - globlPivot[0];
  vY = y - globlPivot[1];
  rollRads = Math.toRadians(dgr);
  s = Math.sin(rollRads);
  c = Math.cos(rollRads);
  vXX = (float) (vX * c - vY * s);
  vYY = (float) (vY * c + vX * s);
  x = (float) (globlPivot[0] + vXX);
  y = (float) (globlPivot[1] + vYY);
  rollDgrs += dgr;
  validate();
}

////////////////////////////////////////////////////////////////////////// TRANSLATION

public void setTranslation(float x, float y) {
  Message message = handler.obtainMessage(SET_TRANSLATE, (int) (x * CAST_MULTI), (int) (y * CAST_MULTI));
  handler.sendMessage(message);
}

private void _setTranslation(float x, float y) {
  this.x = x / CAST_MULTI;
  this.y = y / CAST_MULTI;
  validate();
}

/**
 * @param x value to move camera horizontally
 * @param y value to move camera vertically
 */
public void addTranslateGlbl(float x, float y) {
  Message message = handler.obtainMessage(ADD_TRANSLATE_GLB, (int) (x * CAST_MULTI), (int) (y * CAST_MULTI));
  handler.sendMessage(message);
}

public void _addTranslateGlbl(float x, float y) {
  x *= CAST_MULTI_RECIP;
  y *= CAST_MULTI_RECIP;
  _forceFinish();
  double rollRads = Math.toRadians(rollDgrs);
  double s = Math.sin(rollRads);
  double c = Math.cos(rollRads);
  double xx = x * c - y * s;
  double yy = y * c + x * s;
  this.x += xx;
  this.y += yy;
  validate();
}

/**
 * @param x value to move camera horizontally
 * @param y value to move camera vertically
 */
public void addTranslate(float x, float y) {
  Message message = handler.obtainMessage(ADD_TRANSLATE, (int) (x * CAST_MULTI), (int) (y * CAST_MULTI));
  handler.sendMessage(message);
}

public void _addTranslate(float x, float y) {
  x *= CAST_MULTI_RECIP;
  y *= CAST_MULTI_RECIP;
  _forceFinish();
  this.x += x;
  this.y += y;
  validate();
}

/**
 * Get the x positon of the camera
 *
 * @return
 */
public float getX() {
  return x;
}

/**
 * Get the y position of the camera.
 *
 * @return
 */
public float getY() {
  return y;
}

public void fling(float velocityX, float velocityY) {
  Message message = handler.obtainMessage(FLING, (int) (velocityX * CAST_MULTI), (int) (velocityY * CAST_MULTI));
  handler.sendMessage(message);
}

private void _fling(float velocityX, float velocityY) {
  velocityX *= CAST_MULTI_RECIP;
  velocityY *= CAST_MULTI_RECIP;
  _forceFinish();
  float roll = (float) Math.toRadians(rollDgrs);
  double s = Math.sin(roll);
  double c = Math.cos(roll);
  double xx = velocityX * c - velocityY * s;
  double yy = velocityX * s + velocityY * c;
  final double v;
  v = scale * 0.5d;
//  v = 1f;
  scroller.fling(
      x * 1f, y * 1f,
      (float) (-xx * v), (float) (-yy * v),
      availableCamRegion.left, availableCamRegion.right,
      availableCamRegion.top, availableCamRegion.bottom
      , contentSize.width() * 0.1f, contentSize.height() * 0.1f
  );
  isFling = true;
  Choreographer.getInstance().postFrameCallback(this);
}


@Override
public void doFrame(long frameTimeNanos) {
  if (isUserInteracting) {
    if (!scroller.isFinished()) {
      _forceFinish();
    }
  } else {
    if (!scroller.isFinished()) {
      scroller.computeScrollOffset();
      x = (float) scroller.getCurrX() / 1f;
      y = (float) scroller.getCurrY() / 1f;
      validate();
      Choreographer.getInstance().postFrameCallback(this);
    }
  }
}
////////////////////////////////////////////////////////////////////////// MISC

public void setIsUserInteracting(boolean isTouched) {
  Message message = handler.obtainMessage(IS_USER_INTERACTING, isTouched);
  handler.sendMessage(message);
}

private void _setIsUserInteracting(boolean isTouched) {
  synchronized (lockIsUserInteracting) {
    isUserInteracting = isTouched;
  }
}

public boolean isUserInteracting() {
  synchronized (lockIsUserInteracting) {
    return isUserInteracting;
  }
}

public void setViewport(int width, int height) {
//  Message message = handler.obtainMessage(SET_VIEWPORT, width, height);
//  handler.sendMessage(message);
//}
//
//private void _setViewport(int width, int height) {
  viewport.set(0, 0, width, height);
  validate();
}

public Rect getViewport() {
  return viewport;
}

public float getMapWidthScreenSpace() {
  return mapWidthScreenSpace;
}

public float getMapHeightSceenSpace() {
  return mapHeightSceenSpace;
}

public float[] getFieldOfView() {
  return fovPoints;
}

public RectF getFieldOfViewBBox() {
  return fovBBox;
}

public void setContentSize(RectF contentSize) {
  Message message = handler.obtainMessage(SET_CONTENT_SIZE, contentSize);
  handler.sendMessage(message);
}

private void _setContentSize(RectF contentSize) {
  this.contentSize.set(contentSize);
  validate();
}

public RectF getContentSize() {
  return contentSize;
}

public RectF getAvailableCamRegion() {
  return availableCamRegion;
}

public boolean isFling() {
  synchronized (lockIsFling) {
    return isFling;
  }
}


public boolean isTransformationDirty() {
  synchronized (lockIsTransformationDirty) {
    return isTransformationDirty;
  }
}

public void setIsTransformationDirty(boolean isTransformationDirty) {
  synchronized (lockIsTransformationDirty) {
    this.isTransformationDirty = isTransformationDirty;
  }
}

public float getDeltaX() {
  return deltaX;
}

public float getDeltaY() {
  return deltaY;
}
}
