package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter;

import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.Point;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.Helpers;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.TDInstruction;

/**
 * Created by frankduffy on 2016-01-27.
 */
public class ConsecutiveForwards {

    public void consecutiveForwards(TDFilterInput inst) {
        Helpers hlp = new Helpers();
        if(inst.enableDistanceFilters) {
            // Fill in the gaps
            // Disable is not over zero
            if(inst.addTDifEmptyMeters > 0) {
                // Make array
                int numberOfReduced = 0;
                float distanceTotalPX = -1;
                // Use xyScale
                float theAbsorbingDistance = (float) hlp.convertMetersToPixels(inst.addTDifEmptyMeters, inst.xScale);
                // Get previous
                int indexOfReferenceForward = 0;
                TDInstruction lastStandingInstruction = inst.textDirectionsFloorArray.get(0);
                Point previousPoint = new Point(lastStandingInstruction.wp.x, lastStandingInstruction.wp.y, 0);
                // Loop through all else
                int loopTo3 = inst.textDirectionsFloorArray.size() - 1;

                for(int i = 1; i < loopTo3; i++) {
                    // Get direction
                    TDInstruction nextInstruction = inst.textDirectionsFloorArray.get(i);
                    Point nextPoint = new Point(nextInstruction.wp.x, nextInstruction.wp.y, 0);
                    // Forward?
                    if(nextInstruction.direction.toLowerCase().equals("forward")) {
                        // Process

                        // Calculate the distance between first and last
                        // Distance in px
                        distanceTotalPX = (float) hlp.distanceBetween(previousPoint, nextPoint);
                        // Within absorbing distance?
                        if(distanceTotalPX < theAbsorbingDistance) {
                            // PacMan it
                            // Carry angleTo back and forth
                            //...

                            // Fold to back of next next
                            lastStandingInstruction.foldInFront(nextInstruction);
                            inst.textDirectionsFloorArray.remove(i);

                            numberOfReduced++;

                            // Dec loopTo
                            loopTo3--;
                            // Go back one index
                            i--;
                        } else {
                            // Outside of theAbsorbingDistance
                            // Reset cycle
                            previousPoint.x = 0;
                            previousPoint.y = 0;
                            previousPoint.z = 0;

                            // Pick up first in cycle
                            lastStandingInstruction = nextInstruction;
                            indexOfReferenceForward = i;
                            previousPoint.x = lastStandingInstruction.wp.x;
                            previousPoint.y = lastStandingInstruction.wp.y;
                            previousPoint.z = 0;
                        }

                    } else if(lastStandingInstruction.direction.toLowerCase().equals("forward")) {
                        // lastStandingInstruction

                        // Calculate the distance between first and last
                        // Distance in px
                        distanceTotalPX = (float) hlp.distanceBetween(previousPoint, nextPoint);

                        // Within absorbing distance?
                        if (distanceTotalPX < theAbsorbingDistance) {
                            // PacMan self
                            // Carry angleTo back and forth
                            //...

                            // Not if first
                            // Fold it to previous
                            if(0 != indexOfReferenceForward) {
                                // Fold it in next behind
                                nextInstruction.foldToBack(lastStandingInstruction);

                                // Remove from textDirectionsFloorArray
                                inst.textDirectionsFloorArray.remove(indexOfReferenceForward);
                                numberOfReduced++;
                                // Dec loopTo
                                loopTo3--;
                                // Go back one index
                                // Don't prev index, because we have to skip to next
                            }
                        }
                        // Skip to next point?
                        // Set new previous
                        lastStandingInstruction = nextInstruction;
                        indexOfReferenceForward = i;
                        previousPoint.x = lastStandingInstruction.wp.x;
                        previousPoint.y = lastStandingInstruction.wp.y;
                        previousPoint.z = 0;
                    } else {
                        lastStandingInstruction = nextInstruction;
                        indexOfReferenceForward = i;
                        previousPoint.x = lastStandingInstruction.wp.x;
                        previousPoint.y = lastStandingInstruction.wp.y;
                        previousPoint.z = 0;
                    }
                }
            }
        }
    }
}