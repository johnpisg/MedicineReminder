package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections;

import com.jibestream.jibestreamandroidlibrary.elements.UnitLabel;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.ASNode;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.PathPerFloor;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.Point;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Path;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by frankduffy on 2016-01-22.
 */
public class Helpers {

    public void Helpers() {

    }

    public String stringWithFormat(List<String> arguments) {
        String output = "";
        String[] response = arguments.get(0).split("%");

        for(int i = 1; i < arguments.size(); i++) {
            output += response[i-1];
            output += arguments.get(i);
        }

        return output;
    }

    public String landmarkDirectionFromDeltaAngle(Double angleDelta, Object customThresholds) {
        return "";

    }

    public String directionFromAngle(Double angle, Object customThresholds) {

        // direction thresholds
        double forwardFrom = -25;
        double forwardTo = 25;

        // update 135 to 130

        //Right
        double rightSlightFrom = 25;
        double rightSlightTo = 45;
        double rightFrom = 45;
        double rightTo = 135;
        double rightBackFrom = 135;
        double rightBackTo = 180;

        //Left
        double leftSlightFrom = -45;
        double leftSlightTo = -25;
        double leftFrom = -135;
        double leftTo = -45;
        double leftBackFrom = -180;
        double leftBackTo = -135;

        //Custom Threshold
        if(customThresholds != null) {
            // in case user wants to have their own ones
        }

        String returnDirection = "";

        if((forwardFrom <= angle) && (angle <= forwardTo)) {
            returnDirection = "Forward";
        } else if ((rightSlightFrom <= angle) && (angle <= rightSlightTo)) {
            returnDirection = "Slight Right";
        } else if ((rightFrom <= angle) && (angle <= rightTo)) {
            returnDirection = "Right";
        } else if ((leftSlightFrom <= angle) && (angle <= leftSlightTo)) {
            returnDirection = "Slight Left";
        } else if ((leftFrom <= angle) && (angle <= leftTo)) {
            returnDirection = "Left";
        } else if (((leftBackFrom <= angle) && (angle <= leftBackTo)) ||
                ((rightBackFrom <= angle) && (angle <= rightBackTo))) {
            returnDirection = "Back";
        }

        return returnDirection;
    }

    public String returnDirectionToPoint(Point currentPoint, Point toPoint, double previousAngle) {

        // angle we are pointing to using point we start at and the point we want to get to
        // always return true north in terms of the direction we are going
        double angle = this.pointPairToBearingDegrees(currentPoint, toPoint);

        // find delta in terms of angle to angle as our true north has changed
        double angleToLandmarkDifference = previousAngle - angle;
        while(angleToLandmarkDifference < -180) angleToLandmarkDifference += 360;
        while(angleToLandmarkDifference > 180) angleToLandmarkDifference -= 360;

        return this.directionFromAngle(angleToLandmarkDifference, null);
    }

    public Boolean isPointInsideRotatedRect(Point p, Point a, Point b, Point c, Point d) {
        if((this.triangleArea(a, b, p) > 0) || (this.triangleArea(b,c,p) > 0) || (this.triangleArea(c,d,p) > 0) || (this.triangleArea(d,a,p) > 0)) {
            return false;
        }

        return true;
    }

    public double triangleArea(Point a, Point b, Point c) {
        return ((c.x * b.y) - (b.x * c.y)) - ((c.x * a.y) - (a.x * c.y)) + ((b.x * a.y) - (a.x * b.y));
    }

    public Boolean doLineSegmentsIntersect(Point l11, Point l12, Point l21, Point l22) {
        double d = (l12.x - l11.x) * (l22.y - l21.y) - (l12.y - l11.y) * (l22.x - l21.x);

        if(d == 0) {
            return false;
        }

        double u = ((l21.x - l11.x) * (l22.y - l21.y) - (l21.y - l11.y) * (l22.x - l21.x)) / d;
        double v = ((l21.x - l11.x) * (l12.y - l11.y) - (l21.y - l11.y) * (l12.x - l11.x)) / d;

        if(u < 0.0 || u > 1.0) {
            return false;
        }

        if(v < 0.0 || v > 1.0) {
            return false;
        }

        return true;
    }

    public Point[] arrayOfRotatedPoints(UnitLabel rect) {
        return rect.lBox;
    }

    public Point rotatePoint(Point point, Point center, double angle) {
        double tempX = point.x - center.x;
        double tempY = point.y - center.y;

        double rotatedX = tempX * Math.cos(angle) - tempY * Math.sin(angle);
        double rotatedY = tempX * Math.sin(angle) + tempY * Math.cos(angle);

        double x = rotatedX + center.x;
        double y = rotatedY + center.y;

        return new Point(x, y, 0);
    }

    public double distanceToLine(Point xy, Point p1, Point p2, Point intersect){
        return Math.sqrt(this.distToSegmentSquared(xy,p1,p2,intersect));
    }

    public double distToSegmentSquared(Point xy, Point p1, Point p2, Point pointOfIntersect) {
        double l2 = this.dist2(p1, p2);

        if(l2 == 0) {
            pointOfIntersect.x = p2.x;
            pointOfIntersect.y = p2.y;
            return this.dist2(xy, p2);
        }

        double t = ((xy.x - p1.x) * (p2.x - p1.x) + (xy.y - p1.y) * (p2.y - p1.y)) / l2;

        if(t < 0) {
            pointOfIntersect.x = p1.x;
            pointOfIntersect.y = p1.y;
            return this.dist2(xy, p1);
        }

        if(t > 1) {
            pointOfIntersect.x = p2.x;
            pointOfIntersect.y = p2.y;
            return this.dist2(xy, p2);
        }

        pointOfIntersect.x =(p1.x + t * (p2.x - p1.x));
        pointOfIntersect.y = (p1.y + t * (p2.y - p1.y));

        return this.dist2(xy, pointOfIntersect);
    }

    public double dist2(Point p1, Point p2) {
        return Math.pow(p1.x - p2.x,2) + Math.pow(p1.y - p2.y,2);//(this.sqr() + this.sqr(p1.y - p2.y));
    }

    public double sqr(double x) {
        return x * x;
    }

    public double pointPairToBearingDegrees(Point startingPoint, Point endingPoint) {

        Point vector = new Point(endingPoint.x - startingPoint.x, endingPoint.y - startingPoint.y, 0);
        double angleCalc;

        if(vector.y < 0) {
            angleCalc = Math.atan2(-vector.y, vector.x);
        } else {
            angleCalc = Math.atan2(vector.y, -vector.x) + Math.PI;
        }

        return angleCalc * (180/Math.PI);
    }

    public Point pointOnLineUsingDistanceFromStart(Point lp1, Point lp2, double distanceFromP1) {
        double radians = Math.atan2(lp2.y - lp1.y, lp2.x - lp1.x);

        double derrivedPointX = lp1.x + distanceFromP1 * Math.cos(radians);
        double derrivedPointY = lp1.y + distanceFromP1 * Math.sin(radians);

        return new Point(derrivedPointX, derrivedPointY, 0);
    }

    public double distanceBetween(Point fromXY, Point andXY) {
        double xSegment = andXY.x - fromXY.x;
        double ySegment = andXY.y - fromXY.y;
        return Math.sqrt((xSegment * xSegment) + (ySegment * ySegment));
    }

    public boolean stringContainsString(String str, String con) {
        return str.contains(con);
    }

    public double convertMetersToPixels(float meters, float xyscale) {
        if(xyscale == 0) {
            return -1.0;
        }

        return (meters * 1000.0) / xyscale;
    }

    public double convertPixelsToMeters(float pixels, float xyscale) {
        if(xyscale == 0) {
            return -1.0;
        }

        return (pixels * xyscale) / 1000;
    }

    public Point correctPathUsingWayfindPath(PathPerFloor setOfPoints, Point point, float noFurtherThan) {
        Point returnPoint = new Point(0,0,0);
        double closestDistanceFromPath = -1;

        for(int i = 0; i < setOfPoints.points.length-1; i++) {
            ASNode first = setOfPoints.points[i];
            Point lineP1 = new Point(first.x, first.y, 0);

            ASNode second = setOfPoints.points[i + 1];
            Point lineP2 = new Point(second.x, second.y, 0);

            Point tempPointOfIntercept = new Point(0,0,0);

            double nextDistance = this.distanceToLine(point, lineP1, lineP2, tempPointOfIntercept);
            if((closestDistanceFromPath == -1) || (nextDistance < closestDistanceFromPath)) {
                closestDistanceFromPath = nextDistance;
                returnPoint = tempPointOfIntercept;
            }

        }

        if(0 < noFurtherThan) {
            double xDist = (returnPoint.x - point.x);
            double yDist = (returnPoint.y - point.y);
            double distanceFromIntended = Math.sqrt(this.sqr(xDist) + this.sqr(yDist));
            if(noFurtherThan < distanceFromIntended) {
                returnPoint = point;
            }
        }

        return returnPoint;
    }

   public Point correctPointUsingPaths (Path[] setOfPaths, Waypoint[] allWaypoints,int onFloor, Point point, float noFurtherThan){
       Point returnPoint = new Point(0,0,0);

       double closestDistanceFromPath = -1;

       final int length = allWaypoints.length;

       // Loop through points and make lines
       for (Path nextPath: setOfPaths){
           ArrayList<Waypoint> waypointOnFloor = new ArrayList<Waypoint>();
           // Get all waypoints on this floor
           for (int nextWayPointId: nextPath.waypoints){
               // Get Waypoint
               ArrayList<Waypoint> waypointArray = new ArrayList<Waypoint>();
               for (int i = 0; i < length; i++) {
                   Waypoint waypoint = allWaypoints[i];
                   if (nextWayPointId == waypoint.id) {
                       waypointArray.add(waypoint);
                   }
               }
               if (waypointArray.size() == 1){
                   // Got it
                   Waypoint nextWaypoint = waypointArray.get(0);
                   // Same floor?
                   if (nextWaypoint.mapId == onFloor){
                       // on same floor

                       // add to array
                       waypointOnFloor.add(nextWaypoint);
                   }
               }
           }

           // How many?
           // NOTE: I am expecting only 2
           if (waypointOnFloor.size() != 2){
              // do nothing
           }
           // Less than 2 is fine too: waypoint on floor 1 connecting mover to waypoint on floor 2...
           else {
               // Got only 2
               // Get next two points
               Waypoint first = waypointOnFloor.get(0);
               Point lineP1 = new Point(first.x,first.y,0);

               Waypoint second = waypointOnFloor.get(waypointOnFloor.size()-1);
               Point lineP2 = new Point(second.x,second.y,0);

               // Get the distance
               Point tempInterceptPoint = new Point(0,0,0);
               double nextDistance = distanceToLine(point,lineP1,lineP2,tempInterceptPoint);

               if ((closestDistanceFromPath == -1) || (nextDistance < closestDistanceFromPath)){
                   // New point
                   closestDistanceFromPath = nextDistance;

                   // Get new point
                   returnPoint = tempInterceptPoint;
               }

           }
       }

       // no further than?
       if (0 < noFurtherThan)
       {
           double xDist = (returnPoint.x - point.x);
           double yDist = (returnPoint.y - point.y);
           double distanceFromIntended = Math.sqrt(this.sqr(xDist) + this.sqr(yDist));
           if(noFurtherThan < distanceFromIntended) {
               // Point too far from intended, return original point
               returnPoint = point;
           }
       }

       return returnPoint;
   }

    public boolean shouldCorrectToRerouteWayfindPath(PathPerFloor setOfPoints,Point currentPoint,float threshold, float max_map_width){
        if (0<threshold){
            Point correctedPoint = correctPathUsingWayfindPath(setOfPoints,currentPoint,max_map_width);

            float xDist = (float) (correctedPoint.x - currentPoint.x);
            float yDist = (float) (correctedPoint.y - currentPoint.y);
            float distanceFromIntended = (float) Math.sqrt((xDist * xDist) + (yDist * yDist));
            if (threshold < distanceFromIntended) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return true;
        }
    }

}
