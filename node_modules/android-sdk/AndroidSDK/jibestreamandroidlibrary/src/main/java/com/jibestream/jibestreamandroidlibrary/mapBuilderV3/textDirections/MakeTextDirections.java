package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections;

import com.jibestream.jibestreamandroidlibrary.elements.Element;
import com.jibestream.jibestreamandroidlibrary.elements.UnitLabel;
import com.jibestream.jibestreamandroidlibrary.main.Building;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.ASNode;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.PathPerFloor;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.Point;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Destination;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.MapFull;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Waypoint;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter.ComboDirections;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter.ConsecutiveForwards;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter.ContinuePast;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter.EndAsLandmark;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter.StartAsLandmark;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter.TDFilterInput;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter.UTurn;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by frankduffy on 2016-01-26.
 */
public class MakeTextDirections {

    MapFull[] floorList;
    UnitLabel[] lBoxes;
    Helpers hlp;
    LineOfSight los;
    M model;


    public MakeTextDirections(M model) {
        this.buildModelData(model);
        this.hlp = new Helpers();
        List<Destination> destinations = Arrays.asList(this.model.venueData.destinations);
        this.los = new LineOfSight(destinations, model);
    }

    public void buildModelData(M model) {
        this.model = model;
        this.floorList = this.model.venueData.maps;

        ArrayList<Element> mapElement = new ArrayList<>(Arrays.asList(this.model.getElementList()));
        ArrayList<UnitLabel> unitLabelList = new ArrayList<UnitLabel>();

        for (int i = 0; i < mapElement.size(); i++) {
            if (mapElement.get(i) instanceof UnitLabel) {
                unitLabelList.add((UnitLabel) mapElement.get(i));
            }
        }

        lBoxes = new UnitLabel[unitLabelList.size()];
        unitLabelList.toArray(lBoxes);
    }

    public ArrayList<ArrayList<TDInstruction>> makeProcessedTextDirections(TextDirectionOptions options) {
        PathPerFloor[] wayfindArray = options.pointArray;
        boolean filterOn = options.filter;
        double UTurnInMeters = options.uTurnMeters;
        int addTDiffEmptyMeters = options.joinForwardInstructionWithinMeters;

        // Protect code
        if (wayfindArray.length == 0) {
            // Do not proceed
            return null;
        }

        // Get the waypoints needed to go from start to end across all floors
        ArrayList<ArrayList<TDInstruction>> textDirectionsForAllFloorsArray = new ArrayList<ArrayList<TDInstruction>>();
        // Text directions of One floor
        // First node
        ASNode firstNode = null;
        // Direction to next point will always be from 0 to 360
        // Negative means start
        // This angle will be carried to next direction to figure out turning direction
        double previousAngle = -1;

        // NOTE: Once we figure out which floor mover will take us to, skip all other floors in sequence
        PathPerFloor moverTakesUsToFloor = null;

        for (int i = 0; i < wayfindArray.length; i++) {
            // get waypoints on current floor that are part of your path
            PathPerFloor useArrayOfFloorWaypoints = wayfindArray[i];
            ArrayList<TDInstruction> textDirectionsFloorArray = new ArrayList<TDInstruction>();

            // Loop throught all
            // Continue if this is not the next floor
            if (moverTakesUsToFloor != null) {
                // Skip if not expected floor
                if (moverTakesUsToFloor != useArrayOfFloorWaypoints) {
                    continue;
                }
            }

            // Reset moverTakesUsToFloor
            moverTakesUsToFloor = null;

            firstNode = useArrayOfFloorWaypoints.points[0];

            if (firstNode != null) {

                // Make next text instruction
                // Get arrayOfFloorWaypoints for input floor
                MapFull currentFloorTextDirection = this.getMapById(firstNode.mapId);
                UnitLabel[] curCanvas = this.getLBoxesOnFloor(firstNode.mapId);

                if (currentFloorTextDirection.map.mapId == firstNode.mapId) {

                    // Skip floor's way point if already passed it using an elevator
                    // ex: Going from floor 2 to floor 4 means skip floor 3's waypoint as no need for it
                    // future: keep destination in mind when going on elevator for example
                    ASNode nextNode = null;
                    if (useArrayOfFloorWaypoints.points.length > 1) {
                        nextNode = useArrayOfFloorWaypoints.points[1];
                    }

                    // Populate basic info
                    TDInstruction nextDir = this.makeProcessedTextDirectionInstruction(wayfindArray, useArrayOfFloorWaypoints, currentFloorTextDirection, firstNode, nextNode, -1);

                    // Carry angle to next for next step and call it previousAngle
                    previousAngle = nextDir.angleToNext;

                    // Coming from ...?
                    // 'Arrive at *'
                    String startingFrom;
                    boolean usingLandmark = false;

                    // Absolute start?
                    if (i == 0) {

                        // This will always be the case if this is the absolute start
                        // Make sure we have nearest destination
                        if (nextDir.destination != null) {
                            startingFrom = nextDir.destination.name;
                        } else {
                            // Find nearest Destination
                            if (nextDir.landmarkDestination != null) {
                                startingFrom = nextDir.landmarkDestination.name;
                                usingLandmark = true;
                            } else {
                                startingFrom = "Nearest Destination";
                            }
                        }
                    } else if (firstNode.usedEdgeTypeId == 1) {
                        // Not sure this will ever be the case
                        startingFrom = nextDir.destination.name;
                    }
                    // Mover?
                    else {
                        startingFrom = "Mover";

                        // Go to parent node floor and pick up mover info
                        Waypoint parentWaypoint = this.getWPFromId(firstNode.parent.id);
                        // Find floor info
                        // Get arrayOfFloorWaypoints for input floor
                        for (int k=0; k < wayfindArray.length; k++) {
                            PathPerFloor arrayOfFloorWaypoints = wayfindArray[k];
                            // From Direction
                            // Get current
                            ASNode tempNode = arrayOfFloorWaypoints.points[0];

                            if (tempNode != null) {
                                // Same floor as parent?
                                if (parentWaypoint.mapId == tempNode.mapId) {
                                    // Got it
                                    if (arrayOfFloorWaypoints.pathType != null) {
                                        startingFrom = arrayOfFloorWaypoints.pathType.typeName;
                                    } else {
                                        startingFrom = "mover";
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    ArrayList<String> stringList = new ArrayList<String>();

                    // Output
                    if (usingLandmark) {
                        stringList.add("With % on your %, go %");
                        stringList.add(startingFrom);
                        stringList.add(nextDir.directionToLandmark);
                        stringList.add(nextDir.direction);
                        nextDir.type = "orientation";
                    } else {
                        stringList.add("With % behind you, go %");
                        stringList.add(startingFrom);
                        stringList.add(nextDir.direction);
                        nextDir.type = "orientation";
                    }

                    // format output by combining stringlist's values
                    nextDir.output = this.hlp.stringWithFormat(stringList);

                    // Add to array
                    textDirectionsFloorArray.add(nextDir);

                    // Decision points
                    // Get previous, current and next
                    for (int l = 1; l < (useArrayOfFloorWaypoints.points.length - 1); l++) {
                        stringList = new ArrayList<String>();

                        // Get current
                        ASNode currentNode = useArrayOfFloorWaypoints.points[l];
                        // Get next
                        nextNode = useArrayOfFloorWaypoints.points[l + 1];

                        // Make next text instruction
                        nextDir = this.makeProcessedTextDirectionInstruction(wayfindArray, useArrayOfFloorWaypoints, currentFloorTextDirection, currentNode, nextNode, previousAngle);

//                        model.cp.getTransform().setTranslationX(Building.getWaypointsById(model,15955).x);
//                        model.cp.getTransform().setTranslationY(Building.getWaypointsById(model,15955).y);

                        // Carry angle to next for next step and call it previousAngle
                        previousAngle = nextDir.angleToNext;

                        // Output
                        if (nextDir.landmarkDestination != null){

                            stringList.add("With % on your %, go %");
                            stringList.add(nextDir.landmarkDestination.name);
                            stringList.add(nextDir.directionToLandmark);
                            stringList.add(nextDir.direction);
                            nextDir.output = this.hlp.stringWithFormat(stringList);

                            nextDir.type = "orientation";

                            // Add to array
                            textDirectionsFloorArray.add(nextDir);
                        }
                    }

                    // Last?
                    // Get current
                    ASNode lastNode = useArrayOfFloorWaypoints.points[useArrayOfFloorWaypoints.points.length - 1];
                    if (lastNode != null) {
                        // Add last
                        // Make last text instruction
                        nextDir = this.makeProcessedTextDirectionInstruction(wayfindArray, useArrayOfFloorWaypoints, currentFloorTextDirection, lastNode, null, previousAngle);

                        // Arrrive at?
                        String lastDirection = "";

                        stringList = new ArrayList<String>();

                        if ((useArrayOfFloorWaypoints.pathType == null) || (useArrayOfFloorWaypoints.pathType.pathTypeId == 1)) {
                            // Final Destination
                            Destination de = nextDir.destination;
                            stringList.add("Arrive at %");
                            if (de != null) stringList.add(de.name);
                            else stringList.add("destination");
                            nextDir.type = "end";
                            lastDirection = this.hlp.stringWithFormat(stringList);

                        }
                        // Mover?
                        else {
                            // Mover name
                            String moverName = useArrayOfFloorWaypoints.pathType.description;

                            if (moverName.length() == 0) {
                                moverName = useArrayOfFloorWaypoints.pathType.typeName;
                            }

                            // Mover Direction
                            PathPerFloor floorAfter = wayfindArray[i + 1];
                            String moverGoesToLevel = "";
                            int nextSequence;

                            // Unknown
                            nextDir.direction = "Unknown Mover Direction";

                            if (floorAfter != null) {
                                nextSequence = floorAfter.seq;

                                if (nextSequence > useArrayOfFloorWaypoints.seq) {
                                    // Up
                                    nextDir.direction = "Up";
                                } else if (nextSequence < useArrayOfFloorWaypoints.seq) {
                                    // Down
                                    nextDir.direction = "Down";
                                }
                            }

                            // Let's try to figure out how far we can go
                            // Get next floor by going one array up/down using wayfind array
                            // Get next array using floorIndex
                            // pathTypeId:
                            // 2 == Elevator
                            // 4 == Stairs
                            // 3 == Escalator
                            // Get index of current floor
                            int flIndex = Arrays.asList(wayfindArray).indexOf(useArrayOfFloorWaypoints);

                            // Sequence
                            int sequenceFrom = useArrayOfFloorWaypoints.seq;

                            int previousFloorNodeId = lastNode.id;
                            int highestFloorSeq = useArrayOfFloorWaypoints.seq;
                            boolean keepLooking = true;

                            while (keepLooking) {
                                // Get next floor index
                                flIndex++;
                                // Can it be?
                                if ((wayfindArray.length > flIndex) && flIndex >= 0) {
                                    // Get next floor
                                    PathPerFloor nextArrayOfFloorWaypoints = wayfindArray[flIndex];

                                    // Logic: Is the first node same as previous (parent node) AND
                                    // Is first node same as last node AND
                                    // Is first next node same as last next node
                                    ASNode[] pts = nextArrayOfFloorWaypoints.points;
                                    ASNode firstNodeNext = pts[0];
                                    ASNode lastNodeNext = pts[pts.length - 1];

                                    // Is the first node same as previous (parent node)
                                    if (previousFloorNodeId == firstNodeNext.parent.id) {
                                        // Yes
                                        // This is new highest floor
                                        highestFloorSeq = nextArrayOfFloorWaypoints.seq;

                                        // Remember it so we don't generate text directions for skipped floors
                                        moverTakesUsToFloor = nextArrayOfFloorWaypoints;

                                        // First node same as next node
                                        if (firstNodeNext.id == lastNodeNext.id) {
                                            // There is a possibility we can go higher
                                            previousFloorNodeId = lastNodeNext.id;
                                        } else {
                                            // Cannot continue
                                            keepLooking = false;
                                        }
                                    } else {
                                        // No match
                                        // This would be odd
                                        keepLooking = false;
                                    }
                                } else {
                                    // No more floors, out of the loop
                                    keepLooking = false;
                                }
                            }

                            // Get next floor
                            MapFull finalNextFloor = this.getFloorBySequence(highestFloorSeq);
                            moverGoesToLevel = finalNextFloor.map.name;

                            if(sequenceFrom < highestFloorSeq)
                            {
                                nextDir.direction = "Up";
                            } else
                            {
                                nextDir.direction = "Down";
                            }

                            nextDir.type = "mover";
                            nextDir.moverType = moverName;

                            // Translate mover info
                            stringList = new ArrayList<String>();
                            stringList.add("Take % %, to %");
                            stringList.add(moverName);
                            stringList.add(nextDir.direction);
                            stringList.add(moverGoesToLevel);

                            lastDirection = this.hlp.stringWithFormat(stringList);
                        }

                        // Output
                        nextDir.output = lastDirection;

                        // Angle to next
                        nextDir.angleToNext = -1;

                        // Add to array
                        textDirectionsFloorArray.add(nextDir);
                    }
                } else {
                    return null;
                }

                // Filter?
                //filterOn = false;
                if (filterOn) {
                    // Get scale
                    // this is a float of how many milimeters are prepresented by one pixel on the map
                    MapFull currentFloor = this.getMapById(useArrayOfFloorWaypoints.mapId);
                    double xScale = currentFloor.map.xScale;
                    double yScale = currentFloor.map.yScale;
                    boolean enableDistanceFilters = ((xScale > 0) && (yScale > 0));

                    TDFilterInput instruction = new TDFilterInput();
                    instruction.textDirectionsFloorArray = textDirectionsFloorArray;
                    instruction.useArrayOfFloorWaypoints = useArrayOfFloorWaypoints;
                    instruction.wayfindArray = wayfindArray;
                    instruction.filterOn = filterOn;
                    instruction.addTDifEmptyMeters = addTDiffEmptyMeters;
                    instruction.UTurnInMeters = UTurnInMeters;
                    instruction.enableDistanceFilters = enableDistanceFilters;
                    instruction.xScale = (float) xScale;
                    instruction.yScale = (float) yScale;
                    instruction.currentFloor = currentFloor.map;
                    instruction.curCanvas = curCanvas;

                    // Filter array
                    // 1. Take out text directions between last one and the first one that has final Destination as its landmark.
                    EndAsLandmark endAsLandmark = new EndAsLandmark();
                    endAsLandmark.endAsLandmark(instruction);

                    // 2. Start Direction assumes directions of all next directions which use its Destination as their Landmarks.
                    // Start with: 1) With Store behind you, go Forward. 2) With Store on your Right, go Right. 3) next...
                    // Correct to: 1) With Store behind you, go Right. 2) next...
                    // On first floor!
                    // See if next text direction is using start-destination and if it does, fold it, taking its direction as first.
                    StartAsLandmark startAsLandmark = new StartAsLandmark();
                    startAsLandmark.startAsLandmark(instruction);

                    // 3. U-Turn detection: eg.: Three lefts with combined angle of over 100 deg become Left U-Turn
                    UTurn uturn = new UTurn();
                    uturn.uTurn(instruction);

                    // 4. Remove consecutive Forwards
                    ConsecutiveForwards consecutiveForwards = new ConsecutiveForwards();
                    consecutiveForwards.consecutiveForwards(instruction);

                    // 5. Redundant instructions in the Middle of Instructions (combo-directions)
                    // Left at Macys, Right at Macys... into: "Turn Left then Right at Macys"
                    // NOTE: Avoid Forward directions unless they are at the very end of combo-instruction.
                    // Don't have Right, Forward, Left, Forward
                    // Instead have: Right, Left, Forward
                    // Keep looping while
                    ComboDirections comboDirections = new ComboDirections();
                    comboDirections.comboDirections(instruction);

                    // Filter No.6 Continue Past, FiLLer!
                    ContinuePast continuePast = new ContinuePast(this.model);
                    continuePast.continuePast(instruction);
                }

                // Language filters
                int loopToS = textDirectionsFloorArray.size() - 1;
                for (int s = 1; s < loopToS; s++) {
                    TDInstruction _currentInstruction = textDirectionsFloorArray.get(s);
                    if (_currentInstruction.output == null){
                        continue;
                    }
                    _currentInstruction.output = this.languageFilters(_currentInstruction.output);
                    textDirectionsFloorArray.set(s, _currentInstruction);
                }

                textDirectionsForAllFloorsArray.add(textDirectionsFloorArray);
            }
        }

        //Add distance to every text direction
        for (int floorIndex = 0; floorIndex < textDirectionsForAllFloorsArray.size(); floorIndex++) {
            // Get next floor
            ArrayList<TDInstruction> _nextFloor = textDirectionsForAllFloorsArray.get(floorIndex);
            // Get to way find array
            PathPerFloor _useArrayOfFloorWaypoints = wayfindArray[floorIndex];
            MapFull currentFloor_ = this.getMapById(_useArrayOfFloorWaypoints.mapId);
            double xScale_ = currentFloor_.map.xScale;
            double yScale_ = currentFloor_.map.yScale;
            boolean enableDistanceFilters_ = ((xScale_ > 0) && (yScale_ > 0));

            // Counters
            float currentDistancePixels = 0;

            // Go through text directions
            for (int __nextDirection = 1; __nextDirection < _nextFloor.size(); __nextDirection++) {
                TDInstruction nextInstruction__ = _nextFloor.get(__nextDirection);
                TDInstruction previousInstruction__ = _nextFloor.get((__nextDirection - 1));

                // Get CGPoint
                Point nextPoint__ = new Point(nextInstruction__.wp.x, nextInstruction__.wp.y, 0);
                Point previousPoint__ = new Point(previousInstruction__.wp.x, previousInstruction__.wp.y, 0);

                // Get distance from to
                double distance = this.hlp.distanceBetween(previousPoint__, nextPoint__);

                // currentDistancePixels
                currentDistancePixels += distance;

                // Add to total distance
                nextInstruction__.distanceFromStartPixels = currentDistancePixels;

                // Add to previousInstruction__
                previousInstruction__.distanceToNextPixels = (float) distance;

                // Meters
                if (enableDistanceFilters_) {
                    // Add to total distance in meters
                    nextInstruction__.distanceFromStartMeters = (float) this.hlp.convertPixelsToMeters(( nextInstruction__.distanceFromStartPixels), ((float) xScale_));
                    // Add to previousInstruction__
                    previousInstruction__.distanceToNextMeters = (float) this.hlp.convertPixelsToMeters((previousInstruction__.distanceToNextPixels), ((float) xScale_));
                }

                // Carry point
                previousPoint__.x = nextPoint__.x;
                previousPoint__.y = nextPoint__.y;
            }
        }

        return textDirectionsForAllFloorsArray;
    }

    // Make single Text Direction
    public TDInstruction makeProcessedTextDirectionInstruction(PathPerFloor[] wayfindArray, PathPerFloor floorWaypoints, MapFull floor, ASNode currentNode, ASNode nextNode, double previousToAngle) {

        // Make next text instruction
        TDInstruction nextDir = new TDInstruction();

        // Text direction floor information
        // Get first WP
        nextDir.floor = floor.map.mapId;
        nextDir.floorName = floor.map.name;

        // Current Waypoint, Destination and Direction

        // Waypoint
        nextDir.wp = this.getWPFromId(currentNode.id);

        if (nextDir.wp == null){
            return null;
        }

        // Get destination
        Destination[] destinationsArray = getDestinationByWaypointId(currentNode.id);

        if (destinationsArray == null || destinationsArray.length == 0) {
        } else {
            nextDir.destination = destinationsArray[0];
        }

        // Direction
        // Get Direction
        // Figure out the angle to next

        // Current point
        Point currentPoint = new Point(currentNode.x, currentNode.y, 0);
        Point nextPoint = new Point(currentNode.x, currentNode.y, 0);

//        model.cp.getTransform().setTranslationX((float) currentPoint.x);
//        model.cp.getTransform().setTranslationY((float) currentPoint.y);

        // Next point
        if (nextNode != null) {
            nextPoint.x = nextNode.x;
            nextPoint.y = nextNode.y;
        } else {
            nextPoint.x = currentPoint.x;
            nextPoint.y = currentPoint.y;
        }

        // Get angle
        double angle = this.hlp.pointPairToBearingDegrees(currentPoint, nextPoint);

        // Get angle to next
        nextDir.angleToNext = angle;

        // previousAngle
        // If we are starting on new floor, previousToAngle should be -1
        if (previousToAngle == -1) {
            // Repeat angle
            nextDir.angleToNextOfPreviousDirection = angle;
        } else {
            // This Text Direction is not the first one on this floor so use previousToAngle
            nextDir.angleToNextOfPreviousDirection = previousToAngle;
        }

        // What is the angle difference?
        double angleDifference = nextDir.angleToNextOfPreviousDirection - nextDir.angleToNext;
        while (angleDifference < -180) angleDifference += 360;
        while (angleDifference > 180) angleDifference -= 360;

        // Compute next direction
        nextDir.direction = this.hlp.directionFromAngle(angleDifference, null);

        // Use angleToNext to create blockers
        // If you don't find any destinations, go in sequence:
        // Step 1 - Left Down
        // Step 2 - Up Left
        // Step 3 - Right Down
        // Step 4 - Right Up

        // falseTE: Using true angles (pointPairToBearingDegrees) produces angle with 0 degree which is on x axis on left side
        //        90
        //        |
        //        y
        //        |
        // 180--x-+--- 0 degrees
        //        |
        //        |
        //        270
        //        |
        // ************************
        // Create blockers
        // These will be rectangles covering the portion of map with possible Landmarks which are less desirable
        Destination tempLandmark = null;

        // Landmark
        // Get Landmark using line of sight
        // Used to describe point of reference eg.: 'With *Landmark* on your Left, proceed Forward'
        // Get nearest destination using line of sight
        Point returnClosestPoint = new Point(0, 0, 0);
        ArrayList<UnitLabel> theCanvas = new ArrayList<UnitLabel>(Arrays.asList(this.getLBoxesOnFloor(floor.map.mapId)));

        tempLandmark = this.los.lineOfSightFromClosestLandmarkXY(currentPoint, returnClosestPoint, nextDir.direction, nextDir.angleToNextOfPreviousDirection, theCanvas);

        if (tempLandmark != null) {
            nextDir.landmarkDestination = tempLandmark;

            // Find WP so we can accurately determine angle to destination's entrance
            Waypoint landmarkWP = this.getWaypointFromDestination(nextDir.landmarkDestination.id)[0];

            if (landmarkWP != null) {
                nextDir.landmarkWP = landmarkWP;
                // Get angle comparing Direction angleToNext
                // Direction
                //property NSString *direction;
                // Get Direction
                // Figure out the angle to next
                // Get angle
                angle = this.hlp.pointPairToBearingDegrees(currentPoint, returnClosestPoint);

                // Get angle to next
                nextDir.angleToLandmark = (float) angle;

                // What is the angle difference?
                double angleToLandmarkDifference = nextDir.angleToNextOfPreviousDirection - nextDir.angleToLandmark;
                while (angleToLandmarkDifference < -180) angleToLandmarkDifference += 360;
                while (angleToLandmarkDifference > 180) angleToLandmarkDifference -= 360;

                // Compute next direction
                nextDir.directionToLandmark = this.hlp.directionFromAngle(angleToLandmarkDifference, null);
                nextDir.directionToLandmark = nextDir.directionToLandmark.replace("Slight ","");
            }
        } else {
            // No destination
            nextDir.landmarkDestination = null;
            nextDir.landmarkWP = null;
            nextDir.angleToLandmark = -1;
        }

        return nextDir;
    }

    public String languageFilters(String thisOutput) {

        // Bad:  On your Forward
        // Good: in front
        thisOutput = thisOutput.replaceAll("on your Forward", "in Front");
        // Bad:  On your Back
        // Good: in front
        thisOutput = thisOutput.replaceAll("on your Back", "behind you");
        // Bad:  go Right
        // Good: turn Right
        thisOutput = thisOutput.replaceAll("go Right", "turn Right");
        // Bad:  go Left
        // Good: turn Left
        thisOutput = thisOutput.replaceAll("go Left", "turn Left");
        return thisOutput;
    }

    public Waypoint getWPFromId(int waypointId) {
        Waypoint wp = null;
        for (int i = 0; i < this.model.venueData.waypoints.length; i++) {
            if (this.model.venueData.waypoints[i].id == waypointId) {
                wp = this.model.venueData.waypoints[i];
            }
        }

        return wp;
    }

    public Destination[] getDestinationByWaypointId(int waypointId) {
        Waypoint waypointsById = Building.getWaypointsById(model, waypointId);
        return Building.getDestinationsOfWaypoint(model, waypointsById);
    }

    public Waypoint[] getWaypointFromDestination(int destinationId) {
        ArrayList<Waypoint> wpList = new ArrayList<Waypoint>();
        for (int i = 0; i < this.model.venueData.waypoints.length; i++) {
            if (this.model.venueData.waypoints[i].associations == null) {
                continue;
            }
            for (int j = 0; j < this.model.venueData.waypoints[i].associations.length; j++) {
                if (this.model.venueData.waypoints[i].associations[j].entityTypeId == 1) {
                    if (this.model.venueData.waypoints[i].associations[j].entityId == destinationId) {
                        wpList.add(this.model.venueData.waypoints[i]);
                    }
                }
            }
        }
        return wpList.toArray(new Waypoint[wpList.size()]);
    }

    public MapFull getFloorBySequence(int floorSeq) {
        MapFull returnMap = null;
        for (int i = 0; i < this.floorList.length; i++) {
            if (this.floorList[i].map.floorSequence == floorSeq) {
                returnMap = this.floorList[i];
                break;
            }
        }
        return returnMap;
    }

    //Helpers
    public MapFull getMapById(int mapId) {
        MapFull returnMap = null;
        for (MapFull aFloorList : this.floorList) {
            if (aFloorList.map.mapId == mapId) {
                returnMap = aFloorList;
                break;
            }
        }

        return returnMap;
    }

    public UnitLabel[] getLBoxesOnFloor(int mapId) {
        ArrayList<UnitLabel> lboxList = new ArrayList<UnitLabel>();
        for (UnitLabel lBox : this.lBoxes) {
            MapFull map = model.venueData.maps[lBox.getLevel()];
            if (map.map.mapId == mapId) {
                lboxList.add(lBox);
            }
        }

        return lboxList.toArray(new UnitLabel[lboxList.size()]);
    }

}
