package com.jibestream.jibestreamandroidlibrary.styles.configDOs;

import android.graphics.Color;
import android.graphics.Paint;

import com.google.gson.annotations.SerializedName;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.styles.RenderStyle;
import com.jibestream.jibestreamandroidlibrary.styles.CssStyles;

/**
 * Created by emmanuel on 2015-10-02.
 */
public class ConfigStyleDO {
/**
 * The name of the style
 * dash separated, camel case,
 * append "-Layer" to the naming conventions
 */
public String name;
/**
 * Visibility field
 * expected values would be "none" for invisible
 * and null for visible element
 */
public String display;
/**
 * a boolean value as a string
 * that dictates if the type will be interactive
 */
public String clickable;
/**
 * The hex color of the fill eg"#D8D8D8"
 */
public String fill;
/**
 * The hex color of the stroke eg"#D8D8D8"
 */
public String stroke;
/**
 * The width of the stroke
 */
public String strokeWidth;
/**
 * stroke opacity
 * values will be 0-1.
 */
@SerializedName("stroke-opacity")
public String strokeOpacity;
/**
 * fill opacity
 * values will be 0-1.
 */
@SerializedName("fill-opacity")
public String fillOpacity;

public static RenderStyle getRenderStyle(ConfigStyleDO configStyleDO,M m) {
  // Catch display:"none" and hide accordingly
  if (configStyleDO.display != null && configStyleDO.display.equalsIgnoreCase("none")) {
    switch (configStyleDO.name) {
      case CssStyles.Background:
        m.setActiveBackground(false);
        break;
      case "Parking-Lots":
      case CssStyles.Interior_Parking_Lots:
        m.setActiveParkingLots(false);
        break;
      case CssStyles.Streets_SmallAlleys:
        m.setActiveStreetsSmallAlleys(false);
        break;
      case CssStyles.Streets_Minor:
        m.setActiveStreetsMinor(false);
        break;
      case CssStyles.Streets_Major:
        m.setActiveStreetsMajor(false);
        break;
      case CssStyles.Mall_Boundary:
        m.setActiveMallBoundary(false);
        break;
      case CssStyles.Obstacles:
        m.setActiveObstacles(false);
        break;
      case CssStyles.Units:
        m.setActiveUnits(false);
        break;
      case CssStyles.Restrooms:
        m.setActiveRestrooms(false);
        break;
      case CssStyles.Stairs:
        m.setActiveStairs(false);
        break;
      case CssStyles.Escalators:
        m.setActiveEscalators(false);
        break;
      case CssStyles.Elevators:
        m.setActiveElevators(false);
        break;
    }
    return null;
  }

  //check for none and set back to null
  if (configStyleDO.fill != null && configStyleDO.fill.equalsIgnoreCase("none"))
    configStyleDO.fill = null;
  if (configStyleDO.stroke != null && configStyleDO.stroke.equalsIgnoreCase("none"))
    configStyleDO.stroke = null;

  //Define the type of the RenderStyle: fill, stroke or both
  RenderStyle renderStyle = null;
  if (configStyleDO.fill != null && configStyleDO.stroke != null) {
    renderStyle = new RenderStyle(configStyleDO.name, Paint.Style.FILL_AND_STROKE);
    renderStyle.paintFill.setAntiAlias(true);
    renderStyle.paintStroke.setAntiAlias(true);
  } else if (configStyleDO.fill != null) {
    renderStyle = new RenderStyle(configStyleDO.name, Paint.Style.FILL);
    renderStyle.paintFill.setAntiAlias(true);
  } else if (configStyleDO.stroke != null) {
    renderStyle = new RenderStyle(configStyleDO.name, Paint.Style.STROKE);
    renderStyle.paintStroke.setAntiAlias(true);
  }

  if (renderStyle == null) {
    return null;
  }

  // fill color
  try {
    if ((renderStyle.getStyle() == Paint.Style.FILL_AND_STROKE || renderStyle.getStyle() == Paint.Style.FILL) &&
        configStyleDO.fill != null) {
      final int fillColorValue = Color.parseColor(configStyleDO.fill);
      renderStyle.paintFill.setColor(fillColorValue);
    }
  } catch (IllegalArgumentException e) {
    e.printStackTrace();
  }
  // stroke color
  try {
    if ((renderStyle.getStyle() == Paint.Style.FILL_AND_STROKE || renderStyle.getStyle() == Paint.Style.STROKE) &&
        configStyleDO.stroke != null) {
      final int strokeColorValue = Color.parseColor(configStyleDO.stroke);
      renderStyle.paintStroke.setColor(strokeColorValue);
    }
  } catch (IllegalArgumentException e) {
    e.printStackTrace();
  }
  // fillOpacity
  try {
    if ((renderStyle.getStyle() == Paint.Style.FILL_AND_STROKE || renderStyle.getStyle() == Paint.Style.FILL) &&
        configStyleDO.fillOpacity != null) {
      final float fillOpacityValue = Float.parseFloat(configStyleDO.fillOpacity);
      renderStyle.paintFill.setAlpha((int) (fillOpacityValue * 255f));
    }
  } catch (IllegalArgumentException e) {
    e.printStackTrace();
  }
  // strokeOpacity
  try {
    if ((renderStyle.getStyle() == Paint.Style.FILL_AND_STROKE || renderStyle.getStyle() == Paint.Style.STROKE) &&
        configStyleDO.strokeOpacity != null) {
      final float strokeOpacityValue = Float.parseFloat(configStyleDO.strokeOpacity);
      renderStyle.paintStroke.setAlpha((int) (strokeOpacityValue * 255f));
    }
  } catch (IllegalArgumentException e) {
    e.printStackTrace();
  }
  // strokeWidth
  try {
    if ((renderStyle.getStyle() == Paint.Style.FILL_AND_STROKE || renderStyle.getStyle() == Paint.Style.STROKE) &&
        configStyleDO.strokeWidth != null) {
      final float strokeWidthValue = Float.parseFloat(configStyleDO.strokeWidth);
      renderStyle.paintStroke.setStrokeWidth(strokeWidthValue);
    }
  } catch (IllegalArgumentException e) {
    e.printStackTrace();
  }
  return renderStyle;
}
}
