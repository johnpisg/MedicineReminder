package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections;

import com.jibestream.jibestreamandroidlibrary.elements.UnitLabel;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.Point;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.dataObjects.Destination;

import java.util.List;


/**
 * Created by frankduffy on 2016-01-24.
 */
public class LineOfSight {

    public Helpers hlp;
    public M m;
    public List<Destination> destinations;

    public LineOfSight(List<Destination> destinations, M m_copy) {
        hlp = new Helpers();
        this.m = m_copy;
        this.destinations = destinations;
    }

    public Destination lineOfSightFromClosestLandmarkXY(Point thisXY, Point pointOfIntercept, String direction, double previousAngle, List<UnitLabel> forCanvas) {

        Destination returnDest = null;

        int finalUnitId = -1;

        Point tempIntersectPointForward = new Point(0, 0, 0);
        double closestDestinationPixelsForward = -1;
        int closestUnitIdForward = -1;

        Point tempIntersectPointLeftSlight = new Point(0, 0, 0);
        double closestDestinationPixelsLeftSlight = -1;
        int closestUnitIdLeftSlight = -1;

        Point tempIntersectPointLeft = new Point(0, 0, 0);
        double closestDestinationPixelsLeft = -1;
        int closestUnitIdLeft = -1;

        Point tempIntersectPointRightSlight = new Point(0, 0, 0);
        double closestDestinationPixelsRightSlight = -1;
        int closestUnitIdRightSlight = -1;

        Point tempIntersectPointRight = new Point(0, 0, 0);
        double closestDestinationPixelsRight = -1;
        int closestUnitIdRight = -1;

        Point tempIntersectPointBack = new Point(0, 0, 0);
        double closestDestinationPixelsBack = -1;
        int closestUnitIdBack = -1;


        // GO through entire array of lboxes on floor to get the direction/distance to the next point
        // in each direction
        // pick king of hill out of it
        for (int i = 0; i < forCanvas.size(); i++) {
            UnitLabel lbox = forCanvas.get(i);

            if (lbox != null) {
                final int[] destinationIDs = lbox.getDestinationIDs();
                if (destinationIDs ==null || destinationIDs.length == 0) continue;

                int unitId = -1;
                Point[] rotatedPoints = null;

                unitId = destinationIDs[0];

                if (unitId == -1) {
                    continue;
                }

                // TO-DO: cache the result for future use
                // big perf hit
                // get lbox's rotated points that are in the way
                rotatedPoints = this.hlp.arrayOfRotatedPoints(lbox);

                Point tempIntersectPoint = new Point(0, 0, 0);

                boolean newRecordForward = false;
                boolean newRecordLeftSlight = false;
                boolean newRecordLeft = false;
                boolean newRecordRightSlight = false;
                boolean newRecordRight = false;
                boolean newRecordBack = false;

                double currentProposedDestinationPixelsForward = -1;
                double currentProposedDestinationPixelsLeftSlight = -1;
                double currentProposedDestinationPixelsLeft = -1;
                double currentProposedDestinationPixelsRightSlight = -1;
                double currentProposedDestinationPixelsRight = -1;
                double currentProposedDestinationPixelsBack = -1;

                Point p1 = rotatedPoints[0];
                Point p2 = rotatedPoints[1];
                Point p3 = rotatedPoints[2];
                Point p4 = rotatedPoints[3];

                // Get the distance of nearest intersect
                // update this intersect point as well
                double distance = this.hlp.distanceToLine(thisXY, p1, p2, tempIntersectPoint);

                // get direction for the proposed intersect point
                String proposedDirection = this.hlp.returnDirectionToPoint(thisXY, tempIntersectPoint, previousAngle);

                // Update the one needed
                if(proposedDirection.toLowerCase().equals("forward")){
                    // Forward
                    if((distance < closestDestinationPixelsForward) || (closestDestinationPixelsForward == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsForward == -1) || (distance < currentProposedDestinationPixelsForward))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsForward = distance;
                            // newRecord
                            newRecordForward = true;
                            // tempIntersectPointForward
                            tempIntersectPointForward.x = tempIntersectPoint.x;
                            tempIntersectPointForward.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("slight left")){
                    // Left Slight
                    if((distance < closestDestinationPixelsLeftSlight) || (closestDestinationPixelsLeftSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeftSlight == -1) || (distance < currentProposedDestinationPixelsLeftSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeftSlight = distance;
                            // newRecord
                            newRecordLeftSlight = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeftSlight.x = tempIntersectPoint.x;
                            tempIntersectPointLeftSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("left")){
                    // Left
                    if((distance < closestDestinationPixelsLeft) || (closestDestinationPixelsLeft == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeft == -1) || (distance < currentProposedDestinationPixelsLeft))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeft = distance;
                            // newRecord
                            newRecordLeft = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeft.x = tempIntersectPoint.x;
                            tempIntersectPointLeft.y = tempIntersectPoint.y;
                        }
                    }
                }else if(proposedDirection.toLowerCase().equals("slight right")){
                    // Right
                    if((distance < closestDestinationPixelsRightSlight) || (closestDestinationPixelsRightSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRightSlight == -1) || (distance < currentProposedDestinationPixelsRightSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRightSlight = distance;
                            // newRecord
                            newRecordRightSlight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRightSlight.x = tempIntersectPoint.x;
                            tempIntersectPointRightSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("right")) {
                    // Right
                    if((distance < closestDestinationPixelsRight) || (closestDestinationPixelsRight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRight == -1) || (distance < currentProposedDestinationPixelsRight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRight = distance;
                            // newRecord
                            newRecordRight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRight.x = tempIntersectPoint.x;
                            tempIntersectPointRight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("back")){
                    // Back
                    if((distance < closestDestinationPixelsBack) || (closestDestinationPixelsBack == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsBack == -1) || (distance < currentProposedDestinationPixelsBack))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsBack = distance;
                            // newRecord
                            newRecordBack = true;
                            // tempIntersectPointBack
                            tempIntersectPointBack.x = tempIntersectPoint.x;
                            tempIntersectPointBack.y = tempIntersectPoint.y;
                        }
                    }
                }

                distance = this.hlp.distanceToLine(thisXY, p2, p3, tempIntersectPoint);
                proposedDirection = this.hlp.returnDirectionToPoint(thisXY, tempIntersectPoint, previousAngle);

                // Update the one needed
                if(proposedDirection.toLowerCase().equals("forward")){
                    // Forward
                    if((distance < closestDestinationPixelsForward) || (closestDestinationPixelsForward == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsForward == -1) || (distance < currentProposedDestinationPixelsForward))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsForward = distance;
                            // newRecord
                            newRecordForward = true;
                            // tempIntersectPointForward
                            tempIntersectPointForward.x = tempIntersectPoint.x;
                            tempIntersectPointForward.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("slight left")){
                    // Left Slight
                    if((distance < closestDestinationPixelsLeftSlight) || (closestDestinationPixelsLeftSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeftSlight == -1) || (distance < currentProposedDestinationPixelsLeftSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeftSlight = distance;
                            // newRecord
                            newRecordLeftSlight = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeftSlight.x = tempIntersectPoint.x;
                            tempIntersectPointLeftSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("left")){
                    // Left
                    if((distance < closestDestinationPixelsLeft) || (closestDestinationPixelsLeft == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeft == -1) || (distance < currentProposedDestinationPixelsLeft))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeft = distance;
                            // newRecord
                            newRecordLeft = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeft.x = tempIntersectPoint.x;
                            tempIntersectPointLeft.y = tempIntersectPoint.y;
                        }
                    }
                }else if(proposedDirection.toLowerCase().equals("slight right")){
                    // Right
                    if((distance < closestDestinationPixelsRightSlight) || (closestDestinationPixelsRightSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRightSlight == -1) || (distance < currentProposedDestinationPixelsRightSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRightSlight = distance;
                            // newRecord
                            newRecordRightSlight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRightSlight.x = tempIntersectPoint.x;
                            tempIntersectPointRightSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("right")) {
                    // Right
                    if((distance < closestDestinationPixelsRight) || (closestDestinationPixelsRight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRight == -1) || (distance < currentProposedDestinationPixelsRight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRight = distance;
                            // newRecord
                            newRecordRight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRight.x = tempIntersectPoint.x;
                            tempIntersectPointRight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("back")){
                    // Back
                    if((distance < closestDestinationPixelsBack) || (closestDestinationPixelsBack == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsBack == -1) || (distance < currentProposedDestinationPixelsBack))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsBack = distance;
                            // newRecord
                            newRecordBack = true;
                            // tempIntersectPointBack
                            tempIntersectPointBack.x = tempIntersectPoint.x;
                            tempIntersectPointBack.y = tempIntersectPoint.y;
                        }
                    }
                }

                distance = this.hlp.distanceToLine(thisXY, p3, p4, tempIntersectPoint);
                proposedDirection = this.hlp.returnDirectionToPoint(thisXY, tempIntersectPoint, previousAngle);

                // Update the one needed
                if(proposedDirection.toLowerCase().equals("forward")){
                    // Forward
                    if((distance < closestDestinationPixelsForward) || (closestDestinationPixelsForward == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsForward == -1) || (distance < currentProposedDestinationPixelsForward))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsForward = distance;
                            // newRecord
                            newRecordForward = true;
                            // tempIntersectPointForward
                            tempIntersectPointForward.x = tempIntersectPoint.x;
                            tempIntersectPointForward.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("slight left")){
                    // Left Slight
                    if((distance < closestDestinationPixelsLeftSlight) || (closestDestinationPixelsLeftSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeftSlight == -1) || (distance < currentProposedDestinationPixelsLeftSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeftSlight = distance;
                            // newRecord
                            newRecordLeftSlight = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeftSlight.x = tempIntersectPoint.x;
                            tempIntersectPointLeftSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("left")){
                    // Left
                    if((distance < closestDestinationPixelsLeft) || (closestDestinationPixelsLeft == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeft == -1) || (distance < currentProposedDestinationPixelsLeft))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeft = distance;
                            // newRecord
                            newRecordLeft = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeft.x = tempIntersectPoint.x;
                            tempIntersectPointLeft.y = tempIntersectPoint.y;
                        }
                    }
                }else if(proposedDirection.toLowerCase().equals("slight right")){
                    // Right
                    if((distance < closestDestinationPixelsRightSlight) || (closestDestinationPixelsRightSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRightSlight == -1) || (distance < currentProposedDestinationPixelsRightSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRightSlight = distance;
                            // newRecord
                            newRecordRightSlight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRightSlight.x = tempIntersectPoint.x;
                            tempIntersectPointRightSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("right")) {
                    // Right
                    if((distance < closestDestinationPixelsRight) || (closestDestinationPixelsRight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRight == -1) || (distance < currentProposedDestinationPixelsRight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRight = distance;
                            // newRecord
                            newRecordRight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRight.x = tempIntersectPoint.x;
                            tempIntersectPointRight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("back")){
                    // Back
                    if((distance < closestDestinationPixelsBack) || (closestDestinationPixelsBack == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsBack == -1) || (distance < currentProposedDestinationPixelsBack))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsBack = distance;
                            // newRecord
                            newRecordBack = true;
                            // tempIntersectPointBack
                            tempIntersectPointBack.x = tempIntersectPoint.x;
                            tempIntersectPointBack.y = tempIntersectPoint.y;
                        }
                    }
                }


                distance = this.hlp.distanceToLine(thisXY, p1, p4, tempIntersectPoint);
                proposedDirection = this.hlp.returnDirectionToPoint(thisXY, tempIntersectPoint, previousAngle);

                // Update the one needed
                if(proposedDirection.toLowerCase().equals("forward")){
                    // Forward
                    if((distance < closestDestinationPixelsForward) || (closestDestinationPixelsForward == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsForward == -1) || (distance < currentProposedDestinationPixelsForward))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsForward = distance;
                            // newRecord
                            newRecordForward = true;
                            // tempIntersectPointForward
                            tempIntersectPointForward.x = tempIntersectPoint.x;
                            tempIntersectPointForward.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("slight left")){
                    // Left Slight
                    if((distance < closestDestinationPixelsLeftSlight) || (closestDestinationPixelsLeftSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeftSlight == -1) || (distance < currentProposedDestinationPixelsLeftSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeftSlight = distance;
                            // newRecord
                            newRecordLeftSlight = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeftSlight.x = tempIntersectPoint.x;
                            tempIntersectPointLeftSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("left")){
                    // Left
                    if((distance < closestDestinationPixelsLeft) || (closestDestinationPixelsLeft == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsLeft == -1) || (distance < currentProposedDestinationPixelsLeft))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsLeft = distance;
                            // newRecord
                            newRecordLeft = true;
                            // tempIntersectPointLeft
                            tempIntersectPointLeft.x = tempIntersectPoint.x;
                            tempIntersectPointLeft.y = tempIntersectPoint.y;
                        }
                    }
                }else if(proposedDirection.toLowerCase().equals("slight right")){
                    // Right
                    if((distance < closestDestinationPixelsRightSlight) || (closestDestinationPixelsRightSlight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRightSlight == -1) || (distance < currentProposedDestinationPixelsRightSlight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRightSlight = distance;
                            // newRecord
                            newRecordRightSlight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRightSlight.x = tempIntersectPoint.x;
                            tempIntersectPointRightSlight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("right")) {
                    // Right
                    if((distance < closestDestinationPixelsRight) || (closestDestinationPixelsRight == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsRight == -1) || (distance < currentProposedDestinationPixelsRight))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsRight = distance;
                            // newRecord
                            newRecordRight = true;
                            // tempIntersectPointRight
                            tempIntersectPointRight.x = tempIntersectPoint.x;
                            tempIntersectPointRight.y = tempIntersectPoint.y;
                        }
                    }
                } else if(proposedDirection.toLowerCase().equals("back")){
                    // Back
                    if((distance < closestDestinationPixelsBack) || (closestDestinationPixelsBack == -1))
                    {
                        // Of current 4, which one is the closest?
                        if((currentProposedDestinationPixelsBack == -1) || (distance < currentProposedDestinationPixelsBack))
                        {
                            // This is the closest one
                            currentProposedDestinationPixelsBack = distance;
                            // newRecord
                            newRecordBack = true;
                            // tempIntersectPointBack
                            tempIntersectPointBack.x = tempIntersectPoint.x;
                            tempIntersectPointBack.y = tempIntersectPoint.y;
                        }
                    }
                }

                boolean weHaveLineOfSight = false;
                if (newRecordForward || newRecordLeft || newRecordLeftSlight || newRecordRight || newRecordRightSlight || newRecordBack) {
                    weHaveLineOfSight = this.lineOfSight(unitId, thisXY, unitId, tempIntersectPoint, forCanvas);
                }

                if(newRecordForward)
                {
                    // Line of sight?
                    if(weHaveLineOfSight)
                    {
                        // Set new record
                        closestDestinationPixelsForward = currentProposedDestinationPixelsForward;
                        // closestUnitId
                        closestUnitIdForward = unitId;
                    }
                }
                if(newRecordLeft)
                {
                    // Line of sight?
                    if(weHaveLineOfSight)
                    {
                        // Set new record
                        closestDestinationPixelsLeft = currentProposedDestinationPixelsLeft;
                        // closestUnitId
                        closestUnitIdLeft = unitId;
                    }
                }
                if(newRecordLeftSlight)
                {
                    // Line of sight?
                    if(weHaveLineOfSight)
                    {
                        // Set new record
                        closestDestinationPixelsLeftSlight = currentProposedDestinationPixelsLeftSlight;
                        // closestUnitId
                        closestUnitIdLeftSlight = unitId;
                    }
                }
                if(newRecordRight)
                {
                    // Line of sight?
                    if(weHaveLineOfSight)
                    {
                        // Set new record
                        closestDestinationPixelsRight = currentProposedDestinationPixelsRight;
                        // closestUnitId
                        closestUnitIdRight = unitId;
                    }
                }
                if(newRecordRightSlight)
                {
                    // Line of sight?
                    if(weHaveLineOfSight)
                    {
                        // Set new record
                        closestDestinationPixelsRightSlight = currentProposedDestinationPixelsRightSlight;
                        // closestUnitId
                        closestUnitIdRightSlight = unitId;
                    }
                }
                if(newRecordBack)
                {
                    // Line of sight?
                    if(weHaveLineOfSight)
                    {
                        // Set new record
                        closestDestinationPixelsBack = currentProposedDestinationPixelsBack;
                        // closestUnitId
                        closestUnitIdBack = unitId;
                    }
                }
            }
        }

        // Ranking system
        if (direction.toLowerCase().equals("forward")){
            // Forward
            if (closestUnitIdForward != -1){
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y;
            } else if (closestUnitIdLeftSlight != -1){
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
            }else if (closestUnitIdRightSlight != -1){
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y;
            }else if (closestUnitIdLeft != -1){
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y;
            }else if (closestUnitIdRight != -1){
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y = tempIntersectPointRight.y;
            }else if (closestUnitIdBack != -1){
                finalUnitId = closestUnitIdBack;
                pointOfIntercept.x = tempIntersectPointBack.x;
                pointOfIntercept.y = tempIntersectPointBack.y;
            }

            // If right/slight or left/slight closer than forward or back, use it
            // See if left/s or right/s beat it
            if((closestDestinationPixelsForward > closestDestinationPixelsLeftSlight) && (closestUnitIdLeftSlight != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
                // This prevents Right from overwriting but allows it to compete
                closestDestinationPixelsForward = closestDestinationPixelsLeftSlight;
            }
            // See if left/s or right/s beat it
            if((closestDestinationPixelsForward > closestDestinationPixelsRightSlight) && (closestUnitIdRightSlight != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y;
                closestDestinationPixelsForward = closestDestinationPixelsRightSlight;
            }
            // See if left or right beat it
            if((closestDestinationPixelsForward > closestDestinationPixelsLeft) && (closestUnitIdLeft != -1))
            {
                // Left
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y;
                closestDestinationPixelsForward = closestDestinationPixelsLeft;
            }
            // Right
            if((closestDestinationPixelsForward > closestDestinationPixelsRight) && (closestUnitIdRight != -1))
            {
                // Right
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y = tempIntersectPointRight.y;
            }
        } else if (direction.toLowerCase().equals("slight left")){
            if (closestUnitIdLeftSlight != -1){
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
            } else if (closestUnitIdLeft != -1){
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y;
            }else if (closestUnitIdForward != -1){
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y;
            }else if (closestUnitIdBack != -1){
                finalUnitId = closestUnitIdBack;
                pointOfIntercept.x = tempIntersectPointBack.x;
                pointOfIntercept.y = tempIntersectPointBack.y;
            }else if (closestUnitIdRight != -1){
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y = tempIntersectPointRight.y;
            }else if (closestUnitIdRightSlight != -1){
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y;
            }
            // Slight Left:
            // Forward, Left can beat it
            if((closestDestinationPixelsLeftSlight > closestDestinationPixelsForward) && (closestUnitIdForward != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
                closestDestinationPixelsLeftSlight = closestDestinationPixelsForward;
            }
            // See if left or right beat it
            if((closestDestinationPixelsLeftSlight > closestDestinationPixelsLeft) && (closestUnitIdLeft != -1))
            {
                // Left
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y= tempIntersectPointLeft.y;
                closestDestinationPixelsLeftSlight = closestDestinationPixelsLeft;
            }
        }else if (direction.toLowerCase().equals("left")){
            if (closestUnitIdLeft != -1){
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y ;
            } else if (closestUnitIdLeftSlight != -1){
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
            }else if (closestUnitIdForward != -1){
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
            }else if (closestUnitIdBack != -1){
                finalUnitId = closestUnitIdBack;
                pointOfIntercept.x = tempIntersectPointBack.x;
                pointOfIntercept.y = tempIntersectPointBack.y ;
            }else if (closestUnitIdRight != -1){
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y= tempIntersectPointRight.y;
            }else if (closestUnitIdRightSlight != -1){
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y ;
            }
            // Left:
            // Forward, Slight Left can beat it
            if((closestDestinationPixelsLeft > closestDestinationPixelsForward) && (closestUnitIdForward != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
                closestDestinationPixelsLeft = closestDestinationPixelsForward;
            }
            // See if left or right beat it
            if((closestDestinationPixelsLeft > closestDestinationPixelsLeftSlight) && (closestUnitIdLeftSlight != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
                closestDestinationPixelsLeft = closestDestinationPixelsLeftSlight;
            }
        } else if (direction.toLowerCase().equals("slight right")){
            if (closestUnitIdRightSlight != -1){
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y ;
            } else if (closestUnitIdRight != -1){
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y= tempIntersectPointRight.y;
            }else if (closestUnitIdForward != -1){
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
            }else if (closestUnitIdBack != -1){
                finalUnitId = closestUnitIdBack;
                pointOfIntercept.x = tempIntersectPointBack.x;
                pointOfIntercept.y = tempIntersectPointBack.y ;
            }else if (closestUnitIdLeft != -1){
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y;
            }else if (closestUnitIdLeftSlight != -1){
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
            }
            // Slight Right:
            // Forward, Right can beat it
            if((closestDestinationPixelsRightSlight > closestDestinationPixelsForward) && (closestUnitIdForward != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
                closestDestinationPixelsRightSlight = closestDestinationPixelsForward;
            }
            // See if left or right beat it
            if((closestDestinationPixelsRightSlight > closestDestinationPixelsRight) && (closestUnitIdRight != -1))
            {
                // Right
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y= tempIntersectPointRight.y;
                closestDestinationPixelsRightSlight = closestDestinationPixelsRight;
            }
        }else if (direction.toLowerCase().equals("right")){
            if (closestUnitIdRight != -1){
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y= tempIntersectPointRight.y;
            } else if (closestUnitIdRightSlight != -1){
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y ;
            }else if (closestUnitIdForward != -1){
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
            }else if (closestUnitIdBack != -1){
                finalUnitId = closestUnitIdBack;
                pointOfIntercept.x = tempIntersectPointBack.x;
                pointOfIntercept.y = tempIntersectPointBack.y ;
            }else if (closestUnitIdLeft != -1){
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y;
            }else if (closestUnitIdLeftSlight != -1){
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
            }
            // Right:
            // Forward, Slight Right can beat it
            if((closestDestinationPixelsRight > closestDestinationPixelsForward) && (closestUnitIdForward != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
                closestDestinationPixelsRight = closestDestinationPixelsForward;
            }
            // See if left or right beat it
            if((closestDestinationPixelsRight > closestDestinationPixelsRightSlight) && (closestUnitIdRightSlight != -1))
            {
                // Right
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y;
                closestDestinationPixelsRight = closestDestinationPixelsRightSlight;
            }
        } else if (direction.toLowerCase().equals("back")){
            if (closestUnitIdBack != -1){
                finalUnitId = closestUnitIdBack;
                pointOfIntercept.x = tempIntersectPointBack.x;
                pointOfIntercept.y = tempIntersectPointBack.y;
            }
            if (closestUnitIdLeftSlight != -1){
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
            }else if (closestUnitIdRightSlight != -1){
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y;
            }else if (closestUnitIdLeft != -1){
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y;
            }else if (closestUnitIdRight != -1){
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y= tempIntersectPointRight.y;
            }else if (closestUnitIdForward != -1){
                finalUnitId = closestUnitIdForward;
                pointOfIntercept.x = tempIntersectPointForward.x;
                pointOfIntercept.y = tempIntersectPointForward.y ;
            }
            // Back
            // If right/slight or left/slight closer than forward or back, use it
            // See if left/s or right/s beat it
            if((closestDestinationPixelsForward > closestDestinationPixelsLeftSlight) && (closestUnitIdLeftSlight != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdLeftSlight;
                pointOfIntercept.x = tempIntersectPointLeftSlight.x;
                pointOfIntercept.y = tempIntersectPointLeftSlight.y;
                closestDestinationPixelsForward = closestDestinationPixelsLeftSlight;
            }
            // See if left/s or right/s beat it
            if((closestDestinationPixelsForward > closestDestinationPixelsRightSlight) && (closestUnitIdRightSlight != -1))
            {
                // Left Slight
                finalUnitId = closestUnitIdRightSlight;
                pointOfIntercept.x = tempIntersectPointRightSlight.x;
                pointOfIntercept.y = tempIntersectPointRightSlight.y;
                closestDestinationPixelsForward = closestDestinationPixelsRightSlight;
            }
            // See if left or right beat it
            if((closestDestinationPixelsBack > closestDestinationPixelsLeft) && (closestUnitIdLeft != -1))
            {
                // Left
                finalUnitId = closestUnitIdLeft;
                pointOfIntercept.x = tempIntersectPointLeft.x;
                pointOfIntercept.y = tempIntersectPointLeft.y;
                closestDestinationPixelsForward = closestDestinationPixelsLeft;
            }
            // Right
            if((closestDestinationPixelsBack > closestDestinationPixelsRight) && (closestUnitIdRight != -1))
            {
                // Right
                finalUnitId = closestUnitIdRight;
                pointOfIntercept.x = tempIntersectPointRight.x;
                pointOfIntercept.y= tempIntersectPointRight.y;
            }
        }

        if(finalUnitId != -1) {
            for(int j = 0; j < this.destinations.size(); j++) {
                if(this.destinations.get(j).id == finalUnitId) {
                    returnDest = this.destinations.get(j);
                    break;
                }
            }
        } else {
            // nothing here
        }
        return returnDest;
    }

    public boolean lineOfSight(int unitId, Point fromXY, int toUnitId, Point toXY, List<UnitLabel> forCanvas) {
        // We have the new closest distance, but do we have line of sight?

        // NOTE: algorithm assumes from point is not obstructed by Blockers

        // Flag that fails if Unit's shape gets in the line of sight
        boolean weHaveLineOfSight = true;

        for (int i = 0; i < forCanvas.size(); i++) {
            UnitLabel lbox = forCanvas.get(i);

            if (lbox != null) {

                int[] dataLBox = lbox.getDestinationIDs();
                Point[] rotatedPoints = this.hlp.arrayOfRotatedPoints(lbox);

                Point p1 = new Point(rotatedPoints[0].x, rotatedPoints[0].y, 0);
                Point p2 = new Point(rotatedPoints[1].x, rotatedPoints[1].y, 0);
                Point p3 = new Point(rotatedPoints[2].x, rotatedPoints[2].y, 0);
                Point p4 = new Point(rotatedPoints[3].x, rotatedPoints[3].y, 0);
                boolean differentUnit = true;

                if (dataLBox != null) {

                    for (int aDataLBox : dataLBox) {
                        if (aDataLBox == unitId) {
                            differentUnit = false;
                            break;
                        }
                    }

                }

                if (differentUnit) {
                    // Identify if fromXY is inside empty LBox and avoid using it for lineOfSight
                    if (dataLBox==null || dataLBox.length == 0) {
                        // If fromXY is inside?
                        // If inside, don't use the rect, continue
                        // If not inside, use the rect
                        if (this.hlp.isPointInsideRotatedRect(fromXY, p1, p2, p3, p4)) {
                            continue;
                        }
                    }

                    // intersect?
                    // Dont do all if you don't have to
                    boolean b1 = this.hlp.doLineSegmentsIntersect(fromXY, toXY, p1, p2);
                    if (b1 == false) {
                        boolean b2 = this.hlp.doLineSegmentsIntersect(fromXY, toXY, p2, p3);
                        if (b2 == false) {
                            boolean b3 = this.hlp.doLineSegmentsIntersect(fromXY, toXY, p3, p4);
                            if (b3 == false) {
                                boolean b4 = this.hlp.doLineSegmentsIntersect(fromXY, toXY, p4, p1);
                                if (b4 == false) {
                                    //fantastic
                                } else {
                                    // This rect is in the way
                                    return false;
                                }
                            } else {
                                // This rect is in the way
                                return false;
                            }
                        } else {
                            // This rect is in the way
                            return false;
                        }
                    } else {
                        // This rect is in the way
                        return false;
                    }
                }
            }
        }

        return weHaveLineOfSight;
    }
}