// Modified and adopted from
// https://github.com/pents90/svg-android/blob/master/svgandroid/src/com/larvalabs/svgandroid/SVGParser.java
/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.jibestream.jibestreamandroidlibrary.svg;

import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.RectF;
import android.util.Log;
import android.util.Xml;

import com.jibestream.jibestreamandroidlibrary.elements.Element;
import com.jibestream.jibestreamandroidlibrary.elements.IPreProcessedElem;
import com.jibestream.jibestreamandroidlibrary.elements.Unit;
import com.jibestream.jibestreamandroidlibrary.elements.UnitLabel;
import com.jibestream.jibestreamandroidlibrary.elements.Use;
import com.jibestream.jibestreamandroidlibrary.main.M;
import com.jibestream.jibestreamandroidlibrary.main.SymbolsLib;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.Point;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.Helpers;
import com.jibestream.jibestreamandroidlibrary.math.Vec;
import com.jibestream.jibestreamandroidlibrary.shapes.Circle;
import com.jibestream.jibestreamandroidlibrary.shapes.IShape;
import com.jibestream.jibestreamandroidlibrary.shapes.IconShape;
import com.jibestream.jibestreamandroidlibrary.shapes.JPath;
import com.jibestream.jibestreamandroidlibrary.shapes.Line;
import com.jibestream.jibestreamandroidlibrary.shapes.MultiShape;
import com.jibestream.jibestreamandroidlibrary.shapes.Oval;
import com.jibestream.jibestreamandroidlibrary.shapes.Polygon;
import com.jibestream.jibestreamandroidlibrary.shapes.Rectangle;
import com.jibestream.jibestreamandroidlibrary.shapes.Symbol;
import com.jibestream.jibestreamandroidlibrary.styles.CssStyles;
import com.jibestream.jibestreamandroidlibrary.styles.RenderStyle;
import com.jibestream.jibestreamandroidlibrary.utils.MatrixUtils;

import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class SVGParser {
private static final String TAG = "SVGParser";
private static final int PARSING_SVGDOM = 0;
private static final int PARSING_SYMBOLS = 1;

public static ParsedSVG parseMaps(String in, M m) {
  ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(in.getBytes());
//  while (byteArrayInputStream.read()!=-1){
//    Log.i(TAG,"waitting");
//  }
  final ParsedSVG parsedSVG = new ParsedSVG();
  try {
    XmlPullParser parser = Xml.newPullParser();
    parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
    parser.setInput(byteArrayInputStream, null);
    parseMaps(parser, parsedSVG, m);
  } catch (XmlPullParserException e) {
    e.printStackTrace();
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    try {
      byteArrayInputStream.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return parsedSVG;
  }
}

public static ParsedSVG parseIcon(String in) throws XmlPullParserException, IOException {
  return parseIcon(new ByteArrayInputStream(in.getBytes()));
}

public static ParsedSVG parseIcon(InputStream in) throws XmlPullParserException, IOException {
  final ParsedSVG parsedSVG = new ParsedSVG();
  try {
    XmlPullParser parser = Xml.newPullParser();
    parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
    parser.setInput(in, null);
    parseIcon(parser, parsedSVG);
  } finally {
    in.close();
    return parsedSVG;
  }
}

public static ParsedSVG parseSVG(String in) throws XmlPullParserException, IOException {
  final ParsedSVG parsedSVG = new ParsedSVG();
  XmlPullParser parser = Xml.newPullParser();
  parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
  final StringReader stringReader = new StringReader(in);
  parser.setInput(stringReader);
  parseSVG(parser, parsedSVG);
  return parsedSVG;
}

private static void parseSVG(XmlPullParser parser, ParsedSVG parsedSVG) throws XmlPullParserException, IOException {
  final MultiShape multiShape = new MultiShape();
  String elementType;
  while (parser.next() != XmlPullParser.END_DOCUMENT) {
    int eventType = parser.getEventType();
    if (eventType != XmlPullParser.START_TAG) continue;
    elementType = parser.getName();
    switch (elementType) {
      case "svg":
        parsedSVG.viewBox.set(parseViewBox(parser));
        break;
      case "style":
        setStyles(parser, parsedSVG);
        break;
      case "g":
      case "symbol":
      case "use":
        break;
      case "circle":
      case "rect":
      case "line":
      case "path":
      case "polyline":
      case "polygon":
      case "ellipse":
        final IShape iShape = parseBasicShape(parser);
        // find the viewbox cntr
        final float offsetX = -parsedSVG.viewBox.centerX();
        final float offsetY = -parsedSVG.viewBox.centerY();
        offsetShapesBy(parser, iShape, offsetX, offsetY);
        iShape.getBBox().offset(offsetX, offsetY);
        multiShape.addShape(iShape);
        break;
      default:
        Log.w(TAG, "parseSVG() skipping... no case for element : " + elementType);
    }
  }
  final Element element = new Element();
  element.setShape(multiShape);
  parsedSVG.elements.add(element);
}

private static void parseIcon(XmlPullParser parser, ParsedSVG parsedSVG) throws XmlPullParserException, IOException {
  final IconShape iconShape = new IconShape();
  String elementType;
  while (parser.next() != XmlPullParser.END_DOCUMENT) {
    int eventType = parser.getEventType();
    if (eventType != XmlPullParser.START_TAG) continue;
    elementType = parser.getName();
    switch (elementType) {
      case "svg":
        parsedSVG.viewBox.set(parseViewBox(parser));
        break;
      case "style":
        setStyles(parser, parsedSVG);
      case "g":
      case "symbol":
      case "use":
        break;
      case "circle":
      case "rect":
      case "line":
      case "path":
      case "polyline":
      case "polygon":
      case "ellipse":
        final IShape iShape = parseBasicShape(parser);
        // find the viewbox cntr
        final float offsetX = -parsedSVG.viewBox.centerX();
        final float offsetY = -parsedSVG.viewBox.centerY();
        offsetShapesBy(parser, iShape, offsetX, offsetY);
        String cssClass = parser.getAttributeValue(null, "class");
        cssClass = cssClass.toLowerCase();
        RenderStyle renderStyle = null;
        for (int i = 0; i < parsedSVG.renderStyles.size(); i++) {
          renderStyle = parsedSVG.renderStyles.get(i);
          String name = renderStyle.name;
          if (cssClass.equalsIgnoreCase(name)) break;
        }
        switch (cssClass) {
          case IconShape.BACKGROUND:
            iconShape.addShape(iShape, IconShape.BACKGROUND, renderStyle);
            break;
          case IconShape.MIDDLEGROUND:
            iconShape.addShape(iShape, IconShape.MIDDLEGROUND, renderStyle);
            break;
          case IconShape.FOREGROUND:
            iconShape.addShape(iShape, IconShape.FOREGROUND, renderStyle);
            break;
          default:
            iconShape.addShape(iShape, IconShape.CUSTOM, renderStyle);
        }
        break;
      default:
        Log.w(TAG, "parseIcon() skipping... no case for element : " + elementType);
    }
  }
//          element.setShape(iShape);
//          setTransformMatrixAndMoveToCOG(parser, element);
//          setStyleAccordingToCSSClassName(parser, element);
  final Element element = new Element();
  element.setShape(iconShape);
  parsedSVG.elements.add(element);
}

private static void parseMaps(XmlPullParser parser, ParsedSVG parsedSVG, M m) throws XmlPullParserException, IOException {
  int currentlyParsing = PARSING_SVGDOM;
  Symbol symbol = null;
  String elementType;
  while (parser.next() != XmlPullParser.END_DOCUMENT) {
    int eventType = parser.getEventType();
    elementType = parser.getName();
    String cssClass = parser.getAttributeValue(null, "class");
//    Log.v(TAG, "tag type " + elementType + " css class name " + cssClass);
    switch (eventType) {
      case XmlPullParser.START_TAG:
        switch (elementType) {
          case "svg":
            currentlyParsing = PARSING_SVGDOM;
            parsedSVG.viewBox.set(parseViewBox(parser));
            break;
          case "style":
            setStyles(parser, parsedSVG);
            break;
          case "g":
//          String id = parser.getAttributeValue(null, "id");
//          if (id != null) Log.i(TAG, "group >>: " + id);
            break;
          case "symbol":
            currentlyParsing = PARSING_SYMBOLS;
            symbol = new Symbol();
            symbol.viewBox.set(parseViewBox(parser));
            symbol.ID = parser.getAttributeValue(null, "id");
            break;
          case "use":
            final Use use = parseUse(parser);
            if (use != null) {
              use.classNameCSS = cssClass;
              parsedSVG.elements.add(use);
            }
            break;
          case "circle":
          case "rect":
          case "line":
          case "path":
          case "polyline":
          case "polygon":
          case "ellipse":
            final IShape parseBasicShape = parseBasicShape(parser);
            // Edge case for private elements
            if (cssClass != null && cssClass.toLowerCase().indexOf("private") != -1) {
//              Log.e(TAG, "Skipping element assigned a private css class " + cssClass);
              break;
            }
            if (currentlyParsing == PARSING_SVGDOM) {
              Element element = getElementFromClassName(parser, m);
              // Edge case for LBox
              if (cssClass != null && cssClass.equalsIgnoreCase("LBox")) {
                parseLBox(parser, element);
                element.classNameCSS = cssClass;
                parsedSVG.elements.add(element);
                break;
              }
              if (element != null) {
                populateAttributesFromSVG(parser, element);
                element.setShape(parseBasicShape);
                setTransformMatrixAndMoveToCOG(parser, element);
                element.classNameCSS = cssClass;
                parsedSVG.elements.add(element);
              }
            } else if (currentlyParsing == PARSING_SYMBOLS) {
              symbol.addShape(parseBasicShape);
            }
            break;
          default:
            Log.w(TAG, "parseMaps() skipping... no case for element : " + elementType);
        }
        break;
      case XmlPullParser.END_TAG:
        // Create symbol from accumulated elements
        elementType = parser.getName();
        if (elementType.equalsIgnoreCase("symbol")) {
          SymbolsLib.setSymbol(symbol.ID, symbol, false);
          currentlyParsing = PARSING_SVGDOM;
        }
        break;
    }
  }
}

private static IShape parseBasicShape(XmlPullParser parser) {
  IShape shape = null;
  String elementType = parser.getName();
  switch (elementType) {
    case "circle":
      shape = parseCircle(parser);
      break;
    case "rect":
      shape = parseRect(parser);
      break;
    case "line":
      shape = parseLine(parser);
      break;
    case "path":
      shape = parsePath(parser);
      break;
    case "polyline":
      shape = parsePolyline(parser);
      break;
    case "polygon":
      shape = parsePolygon(parser);
      break;
    case "ellipse":
      shape = parseEllipse(parser);
      break;
  }
  return shape;
}


/**
 * transform the transformation matrix if existent on the element
 * and move the origin to the cog of each element.
 *
 * @param parser
 * @param element
 */
private static void setTransformMatrixAndMoveToCOG(XmlPullParser parser, Element element) {
  String transformString = parser.getAttributeValue(null, "transform");
  String elementType = parser.getName();

  switch (elementType) {
    case "circle":
      final Circle circle = (Circle) element.getShape();
      float x = circle.getX();
      float y = circle.getY();
      circle.setX(0);
      circle.setY(0);
      if (transformString != null) {
        bakeTransformFoundOnElement(element, x, y, transformString);
      } else {
        element.getTransform().setTranslationX(x);
        element.getTransform().setTranslationY(y);
      }
      break;
    case "rect":
      final Rectangle rectangle = (Rectangle) element.getShape();
      float centerX = rectangle.getBBox().centerX();
      float centerY = rectangle.getBBox().centerY();
      float w = rectangle.getBBox().width();
      float h = rectangle.getBBox().height();
      rectangle.setLeft(w * -0.5f);
      rectangle.setRight(w * 0.5f);
      rectangle.setTop(h * -0.5f);
      rectangle.setBottom(h * 0.5f);
      if (transformString != null) {
        bakeTransformFoundOnElement(element, centerX, centerY, transformString);
      } else {
        element.getTransform().setTranslationX(centerX);
        element.getTransform().setTranslationY(centerY);
      }
      break;
    case "line":
      final Line line = (Line) element.getShape();
      if (transformString != null) {
        bakeTransformFoundOnElement(element, 0, 0, transformString);
      } else {
        //Global to local
        Vec v = new Vec();
        float x1 = line.getStartX();
        float x2 = line.getStopX();
        float y1 = line.getStartY();
        float y2 = line.getStopY();
        v.add(x1, y1);
        v.add(x2, y2);
        v.div(2f);
        x1 -= v.getX();
        x2 -= v.getX();
        y1 -= v.getY();
        y2 -= v.getY();
        line.setStartX(x1);
        line.setStartY(y1);
        line.setStopX(x2);
        line.setStopY(y2);
        element.getTransform().setTranslationX(v.getX());
        element.getTransform().setTranslationY(v.getY());
      }
      break;
    case "path":
      final JPath jPath = (JPath) element.getShape();
      if (transformString != null) {
        bakeTransformFoundOnElement(element, 0, 0, transformString);
      } else {
        jPath.setPath(pathGlobalToLocal(element, jPath.getPath()));
      }
      break;
    case "polyline":
      final JPath jPathP = (JPath) element.getShape();
      if (transformString != null) {
        bakeTransformFoundOnElement(element, 0, 0, transformString);
      } else {
        jPathP.setPath(pathGlobalToLocal(element, jPathP.getPath()));
      }
      break;
    case "polygon":
      final Polygon polygon = (Polygon) element.getShape();
      if (transformString != null) {
        bakeTransformFoundOnElement(element, 0, 0, transformString);
      } else {
        polygon.setPath(pathGlobalToLocal(element, polygon.getPath()));
      }
      break;
    case "ellipse":
      final Oval oval = (Oval) element.getShape();
      float ovalCenterX = oval.getBBox().centerX();
      float ovalCenterY = oval.getBBox().centerY();
      if (transformString != null) {
        bakeTransformFoundOnElement(element, ovalCenterX, ovalCenterY, transformString);
      } else {
        element.getTransform().setTranslationX(ovalCenterX);
        element.getTransform().setTranslationY(ovalCenterY);
      }
      break;
    case "use":
      final MultiShape multiShape = (MultiShape) element.getShape();
      if (transformString != null) {
        bakeTransformFoundOnElement(element, 0, 0, transformString);
      } else {
//        element.getTransform().setTranslationX(x);
//        element.getTransform().setTranslationY(y);
      }
      break;
  }

}

// TODO: 2015-10-24 make offsetData fn in each class
private static void offsetShapesBy(XmlPullParser parser, IShape iShape, float offsetX, float offsetY) {
  String elementType = parser.getName();
  switch (elementType) {
    case "circle":
      final Circle circle = (Circle) iShape;
      float x = circle.getX();
      float y = circle.getY();
      circle.setX(x + offsetX);
      circle.setY(y + offsetY);
      break;
    case "rect":
      final Rectangle rectangle = (Rectangle) iShape;
      final float top = rectangle.getTop();
      final float left = rectangle.getLeft();
      final float right = rectangle.getRight();
      final float bottom = rectangle.getBottom();
      rectangle.setLeft(left + offsetX);
      rectangle.setRight(right + offsetX);
      rectangle.setTop(top + offsetY);
      rectangle.setBottom(bottom + offsetY);
      break;
    case "line":
      final Line line = (Line) iShape;
      float x1 = line.getStartX();
      float x2 = line.getStopX();
      float y1 = line.getStartY();
      float y2 = line.getStopY();
      line.setStartX(x1 + offsetX);
      line.setStartY(y1 + offsetY);
      line.setStopX(x2 + offsetX);
      line.setStopY(y2 + offsetY);
      break;
    case "path":
    case "polyline":
      final JPath jPath = (JPath) iShape;
      final Path path1 = jPath.getPath();
      path1.offset(offsetX, offsetY);
      jPath.setPath(path1);
      break;
    case "polygon":
      final Polygon polygon = (Polygon) iShape;
      final Path path = polygon.getPath();
      path.offset(offsetX, offsetY);
      polygon.setPath(path);
      break;
    case "ellipse":
      final Oval oval = (Oval) iShape;
      final RectF rectF = oval.getRectF();
      rectF.offset(offsetX, offsetY);
      oval.setRectF(rectF);
      break;
  }

}

private static Element getElementFromClassName(XmlPullParser parser, M m) {
  Element element = null;
  String cssClass = parser.getAttributeValue(null, "class");
  if (cssClass == null) return element;
  try {
    switch (cssClass) {
      case CssStyles.Units:
        element = (Element) m.classLib.unitClass.newInstance();
        preProcessedElement(parser, element);
        break;
      case CssStyles.Obstacles:
        element = (Element) m.classLib.obstacleClass.newInstance();
        break;
      case CssStyles.Escalators:
        element = (Element) m.classLib.escalatorClass.newInstance();
        break;
      case CssStyles.Elevators:
        element = (Element) m.classLib.elevatorsClass.newInstance();
        break;
      case CssStyles.Stairs:
        element = (Element) m.classLib.stairClass.newInstance();
        break;
      case CssStyles.Interior_Parking_Lots:
      case CssStyles.Parking_Lots:
        element = (Element) m.classLib.parkingLotClass.newInstance();
        break;
      case CssStyles.Streets_Major:
        element = (Element) m.classLib.streetMajorClass.newInstance();
        break;
      case CssStyles.Streets_Minor:
        element = (Element) m.classLib.streetMinorClass.newInstance();
        break;
      case CssStyles.Streets_SmallAlleys:
        element = (Element) m.classLib.streetSmallAlleyClass.newInstance();
        break;
      case CssStyles.Mall_Boundary:
        element = (Element) m.classLib.mallBoundaryClass.newInstance();
        break;
      case CssStyles.Restrooms:
        element = (Element) m.classLib.restroomClass.newInstance();
        break;
      case CssStyles.Background:
        element = (Element) m.classLib.backgroundClass.newInstance();
        break;
      case CssStyles.Corridor:
        element = (Element) m.classLib.corridorClass.newInstance();
        break;
      case CssStyles.Kiosks:
        element = (Element) m.classLib.kioskClass.newInstance();
        break;
      case "LBox":
        element = (Element) m.classLib.unitLabelClass.newInstance();
        preProcessedElement(parser, element);
        break;
      case CssStyles.CustomArtLayer1:
        element = (Element) m.classLib.customArtLayer1.newInstance();
        break;
      case CssStyles.CustomArtLayer2:
        element = (Element) m.classLib.customArtLayer2.newInstance();
        break;
      case CssStyles.CustomArtLayer3:
        element = (Element) m.classLib.customArtLayer3.newInstance();
        break;
      case CssStyles.CustomArtLayer4:
        element = (Element) m.classLib.customArtLayer4.newInstance();
        break;
      case CssStyles.CustomArtLayer5:
        element = (Element) m.classLib.customArtLayer5.newInstance();
        break;
      case CssStyles.CustomArtLayer6:
        element = (Element) m.classLib.customArtLayer6.newInstance();
        break;
      case "Pattern-Grass":
      case "Pattern-OutdoorTerrace":
      case "Offices":
//        Log.w(TAG, "Bypassing class name : " + cssClass);
        break;
      default:
        element = (Element) m.classLib.elementCustomClass.newInstance();
        Log.w(TAG, "Created custom element with name : " + cssClass);
    }
  } catch (InstantiationException e) {
    e.printStackTrace();
  } catch (IllegalAccessException e) {
    e.printStackTrace();
  }
  return element;
}

/**
 * Parsing of svg elements that have been processed on the server
 *
 * @param parser
 * @param element
 */
private static void preProcessedElement(XmlPullParser parser, Element element) {
  String dataAttribute;
  String waypointAttribute;
  if (element instanceof Unit) {
    dataAttribute = "data-unit";
    waypointAttribute = "waypoint-unit";
  } else {
    dataAttribute = "data-lbox";
    waypointAttribute = "waypoint-lbox";
  }

  IPreProcessedElem iPreProcessedElem;
  if (element instanceof IPreProcessedElem) {
    iPreProcessedElem = (IPreProcessedElem) element;
  } else {
    return;
  }
  int[] destinationIDs;
  final String destinationsValue = parser.getAttributeValue(null, dataAttribute);
  if (destinationsValue != null) {
    String[] destinationIDsAsStrings = destinationsValue.split(",");
    destinationIDs = new int[destinationIDsAsStrings.length];
    for (int j = 0; j < destinationIDsAsStrings.length; j++) {
      destinationIDs[j] = Integer.parseInt(destinationIDsAsStrings[j]);
    }
    iPreProcessedElem.setDestinationIDs(destinationIDs);
  }

  int[] waypointsIDs;
  final String waypointsValue = parser.getAttributeValue(null, waypointAttribute);
  if (waypointsValue != null) {
    String[] waypointsIDsAsStrings = waypointsValue.split(",");
    waypointsIDs = new int[waypointsIDsAsStrings.length];
    for (int j = 0; j < waypointsIDsAsStrings.length; j++) {
      waypointsIDs[j] = Integer.parseInt(waypointsIDsAsStrings[j]);
    }
    iPreProcessedElem.setWaypointIDs(waypointsIDs);
  }
}

/**
 * Pick Css styles from the svg and store them
 *
 * @param parser
 * @throws XmlPullParserException
 * @throws IOException
 */
private static void setStyles(XmlPullParser parser, SVGParser.ParsedSVG parsedSVG) throws XmlPullParserException, IOException {
  parser.require(XmlPullParser.START_TAG, null, "style");
  while (parser.next() != XmlPullParser.END_TAG) {
    String text = parser.getText();
    Pattern pattern = Pattern.compile("\\.[-[aA-zZ][0-9]]*\\{.*\\}");
    Matcher matcher = pattern.matcher(text);
    ArrayList<String> classSelectors = new ArrayList<>();
    while (matcher.find()) {
      String aClassSelector = matcher.group(0);
//      Log.i(TAG, aClassSelector);
      if (aClassSelector.toLowerCase().indexOf("lbox") > -1) continue;
      classSelectors.add(aClassSelector);
    }

    for (int i = 0; i < classSelectors.size(); i++) {
      String aClass = classSelectors.get(i);
      String name = null;
      String fill = null;
      String opacityFill = null;
      String stroke = null;
      String strokeWidth = null;
      String opacityStroke = null;

      matcher = Pattern.compile("\\.([^\\{]*)").matcher(aClass);
      if (matcher.find()) {
        name = matcher.group(1);
      } else {
        continue;
      }

      String floatRegexSel = "(\\d*\\.?\\d*)";
      String colorRegexSel = "([^;]*)";

      matcher = Pattern.compile("fill:" + colorRegexSel).matcher(aClass);
      if (matcher.find()) fill = matcher.group(1);
      matcher = Pattern.compile("opacity:" + floatRegexSel).matcher(aClass);
      if (matcher.find()) opacityFill = matcher.group(1);
      if (fill != null && fill.equalsIgnoreCase("none") && opacityFill == null) {
        fill = null;
      }

      matcher = Pattern.compile("stroke:" + colorRegexSel).matcher(aClass);
      if (matcher.find()) stroke = matcher.group(1);
      matcher = Pattern.compile("stroke-width:" + floatRegexSel).matcher(aClass);
      if (matcher.find()) strokeWidth = matcher.group(1);
      matcher = Pattern.compile("stroke-opacity:" + floatRegexSel).matcher(aClass);
      if (matcher.find()) opacityStroke = matcher.group(1);

      if (fill != null && (!fill.equalsIgnoreCase("none"))) {
        try {
          int color = Color.parseColor(fill);
          // color is a valid color
        } catch (IllegalArgumentException iae) {
          Log.d(TAG, "fill color skipped");
          fill = null;
        }
      }

      RenderStyle renderStyle = new RenderStyle(name, null);
      if ((fill != null && (!fill.equalsIgnoreCase("none"))) || opacityFill != null) {
        renderStyle.paintFill = new Paint();
        renderStyle.paintFill.setStyle(Paint.Style.FILL);
        renderStyle.paintFill.setAntiAlias(true);
      }
      if (stroke != null || opacityStroke != null) {
        renderStyle.paintStroke = new Paint();
        renderStyle.paintStroke.setStyle(Paint.Style.STROKE);
        renderStyle.paintStroke.setAntiAlias(true);
      }

      if (fill != null && (!fill.equalsIgnoreCase("none"))) {
        int color = Color.parseColor(fill);
        renderStyle.paintFill.setColor(color);
      }

      if (opacityFill != null && !opacityFill.isEmpty()) {
        try {
          renderStyle.paintFill.setAlpha((int) (Float.parseFloat(opacityFill) * 255f));
        } catch (NumberFormatException e) {
          e.printStackTrace();
        }
      }
      if (stroke != null) {
        try {
          renderStyle.paintStroke.setColor(Color.parseColor(stroke));
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
      if (opacityStroke != null) {
        try {
          renderStyle.paintStroke.setAlpha((int) (Float.parseFloat(opacityFill) * 255f));
        } catch (NumberFormatException e) {
          e.printStackTrace();
        }
      }
      if (strokeWidth != null) {
        try {
          renderStyle.setStrokeWidth(Float.parseFloat(strokeWidth));
        } catch (NumberFormatException e) {
          e.printStackTrace();
        }
      }
      parsedSVG.renderStyles.add(renderStyle);
    }
  }
}

///////////////////////////////////////////////////////////
// Private methods to read particular shapes
///////////////////////////////////////////////////////////

private static Circle parseCircle(XmlPullParser parser) {
  Circle circle = new Circle();
  float x = 0, y = 0, radius = 0;
  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "cx":
        x = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "cy":
        y = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "r":
        radius = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
    }
  }
  circle.setX(x);
  circle.setY(y);
  circle.setRadius(radius);
  return circle;
}

private static Oval parseEllipse(XmlPullParser parser) {
  Oval oval = new Oval();
  float x = 0, y = 0, radiusX = 0, radiusY = 0;
  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "cx":
        x = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "cy":
        y = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "rx":
        radiusX = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "ry":
        radiusY = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
    }
  }

  oval.setRectF(
      new RectF(
          x - radiusX,
          y - radiusY,
          x + radiusX,
          y + radiusY
      )
  );
  return oval;
}

private static Rectangle parseRect(XmlPullParser parser) {
  Rectangle rectangle = new Rectangle();
  float x = 0, y = 0, width = 0, height = 0;
  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "x":
        x = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "y":
        y = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "width":
        width = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "height":
        height = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
    }
  }

  rectangle.setLeft(x);
  rectangle.setTop(y);
  rectangle.setRight(x + width);
  rectangle.setBottom(y + height);
  return rectangle;
}

private static void parseLBox(XmlPullParser parser, Element element) {
  float x = 0f, y = 0f, width = 0f, height = 0f;
  String transformString = null;
  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name.toLowerCase()) {
      case "x":
        x = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "y":
        y = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "width":
        width = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "height":
        height = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "transform":
        transformString = parser.getAttributeValue(null, name);
        break;
    }
  }

  float widthHalf = width * 0.5f;
  float heightHalf = height * 0.5f;

  final Point[] lBox = new Point[4];
  Point[] rotated_points = new Point[4];

  for (int i = 0; i < 4; i++) {
    lBox[i] = new Point(0d, 0d, 0d);
    rotated_points[i] = new Point(0d, 0d, 0d);
  }

  lBox[0].x = x;
  lBox[0].y = y;
  lBox[1].x = x + width;
  lBox[1].y = y;
  lBox[2].x = x + width;
  lBox[2].y = y + height;
  lBox[3].x = x;
  lBox[3].y = y + height;

  if (transformString != null) {
    ((UnitLabel) element).lBoxMatrix = parseTransform(transformString);
    Matrix m = bakeTransformFoundOnElement(element, x + widthHalf, y + heightHalf, transformString);

    Helpers helpers = new Helpers();

    double centreX = x + widthHalf;
    double centreY = y + heightHalf;

//      float[] ints = new float[9];
//      ((UnitLabel) element).getTransform().getLocalMatrix().getValues(ints);
//      Double a = (double) ints[Matrix.MSCALE_X];
//      Double b = (double) ints[Matrix.MSKEW_Y];
//      Double theta = Math.atan2(b,a);

    for (int i = 0; i < 4; i++) {
      Point temppoint = new Point(centreX, centreY, 0d);
      rotated_points[i] = helpers.rotatePoint(lBox[i], temppoint, Math.toRadians(element.getTransform().getRotation()));
    }

    lBox[0].x = rotated_points[0].x;
    lBox[0].y = rotated_points[0].y;
    lBox[1].x = rotated_points[1].x;
    lBox[1].y = rotated_points[1].y;
    lBox[2].x = rotated_points[2].x;
    lBox[2].y = rotated_points[2].y;
    lBox[3].x = rotated_points[3].x;
    lBox[3].y = rotated_points[3].y;

  } else {
    element.getTransform().setTranslationX(x + widthHalf);
    element.getTransform().setTranslationY(y + heightHalf);
    //
  }

  ((UnitLabel) element).lBox = lBox;

  // Hack to compensate for wrong orientation values applied on Lboxes at design time
  if (height > width) {
    float tmp = width;
    width = height;
    height = tmp;
    float dgrs = element.getTransform().getRotation();
    dgrs = (dgrs + 90 + 180) % 180;
    element.getTransform().setRotation(dgrs);
  }

  ((UnitLabel) element).setWidth(width);
  ((UnitLabel) element).setHeight(height);
}

private static Line parseLine(XmlPullParser parser) {
  Line line = new Line();
  float x1 = 0, y1 = 0, x2 = 0, y2 = 0;

  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "x1":
        x1 = Float.parseFloat(parser.getAttributeValue(null, "x1"));
        break;
      case "y1":
        y1 = Float.parseFloat(parser.getAttributeValue(null, "y1"));
        break;
      case "x2":
        x2 = Float.parseFloat(parser.getAttributeValue(null, "x2"));
        break;
      case "y2":
        y2 = Float.parseFloat(parser.getAttributeValue(null, "y2"));
    }
  }

  line.setStartX(x1);
  line.setStartY(y1);
  line.setStopX(x2);
  line.setStopY(y2);
  return line;
}

private static Polygon parsePolygon(XmlPullParser parser) {
  Polygon polygon = new Polygon();
  String points = null;

  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "points":
        points = parser.getAttributeValue(null, "points");
        break;
    }
  }
  if (points != null) {
    String[] spaceSeperated = points.split("\\s+");
    ArrayList<Float> numbers = new ArrayList<>();
    for (int i = 0; i < spaceSeperated.length; i++) {
      String[] pair = spaceSeperated[i].split(",");
      if (pair.length > 1) {
        numbers.add(Float.parseFloat(pair[0]));
        numbers.add(Float.parseFloat(pair[1]));
      } else {
        numbers.add(Float.parseFloat(pair[0]));
      }
    }
    polygon.setPathFromPoints(numbers);
  }
  return polygon;
}

private static JPath parsePolyline(XmlPullParser parser) {
  JPath jPath = new JPath();
  String points = null;

  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "points":
        points = parser.getAttributeValue(null, "points");
        break;
    }
  }

  if (points != null) {
    Path doPath = doPath(points);
    jPath.setPath(doPath);
  }
  return jPath;
}

private static JPath parsePath(XmlPullParser parser) {
  String d = null;

  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "d":
        d = parser.getAttributeValue(null, "d");
        break;
    }
  }

  JPath jPath = new JPath();

  if (d != null) {
    Path doPath = doPath(d);
    jPath.setPath(doPath);
  }
  return jPath;
}

private static Use parseUse(XmlPullParser parser) {
  float x = 0, y = 0, width = 0, height = 0;
  for (int i = 0; i < parser.getAttributeCount(); i++) {
    String name = parser.getAttributeName(i);
    switch (name) {
      case "x":
        x = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "y":
        y = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "width":
        width = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
      case "height":
        height = Float.parseFloat(parser.getAttributeValue(null, name));
        break;
    }
  }

  Use use = new Use();
  String hrefID = parser.getAttributeValue(null, "xlink:href");
  hrefID = hrefID.substring(1, hrefID.length());//Get rid of the #
  final MultiShape multiShape = SymbolsLib.getSymbol(hrefID);
  if (multiShape != null) {
    use.setShape(multiShape);
    use.setX(x);
    use.setY(y);
    use.setWidth(width);
    use.setHeight(height);
    setTransformMatrixAndMoveToCOG(parser, use);
  }
  return use;
}

/**
 * This is where the hard-to-start paths are handled.
 * Uppercase rules are absolute positions, lowercase are relative.
 * Types of path rules:
 * <p/>
 * <ol>
 * <li>M/m - (x y)+ - Move to (without drawing)
 * <li>Z/z - (no params) - Close path (back to starting point)
 * <li>L/l - (x y)+ - Line to
 * <li>H/h - x+ - Horizontal ine to
 * <li>V/v - y+ - Vertical line to
 * <li>C/c - (x1 y1 x2 y2 x y)+ - Cubic bezier to
 * <li>S/s - (x2 y2 x y)+ - Smooth cubic bezier to (shorthand that assumes the x2, y2 from previous C/S is the x1, y1 of this bezier)
 * <li>Q/q - (x1 y1 x y)+ - Quadratic bezier to
 * <li>T/t - (x y)+ - Smooth quadratic bezier to (assumes previous control point is "reflection" of last one w.r.t. to current point)
 * </ol>
 * <p/>
 * Numbers are separate by whitespace, comma or nothing at all (!) if they are self-delimiting, (ie. begin with a - sign)
 *
 * @param s the path string from the XML
 */
private static Path doPath(String s) {
  int n = s.length();
  ParserHelper ph = new ParserHelper(s, 0);
  ph.skipWhitespace();
  Path p = new Path();
  float lastX = 0;
  float lastY = 0;
  float lastX1 = 0;
  float lastY1 = 0;
  float subPathStartX = 0;
  float subPathStartY = 0;
  char prevCmd = 0;
  while (ph.pos < n) {
    char cmd = s.charAt(ph.pos);
    switch (cmd) {
      case '-':
      case '+':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        if (prevCmd == 'm' || prevCmd == 'M') {
          cmd = (char) (((int) prevCmd) - 1);
          break;
        } else if (prevCmd == 'c' || prevCmd == 'C') {
          cmd = prevCmd;
          break;
        } else if (prevCmd == 'l' || prevCmd == 'L') {
          cmd = prevCmd;
          break;
        } else if (prevCmd == 'a' || prevCmd == 'A') {
          cmd = prevCmd;
          break;
        } else if (prevCmd == 'v' || prevCmd == 'V') {
          cmd = prevCmd;
          break;
        } else if (prevCmd == 's' || prevCmd == 'S') {
          cmd = prevCmd;
          break;
        }
      default: {
        ph.advance();
        prevCmd = cmd;
      }
    }

    boolean wasCurve = false;
    switch (cmd) {
      case 'M':
      case 'm': {
        float x = ph.nextFloat();
        float y = ph.nextFloat();
        if (cmd == 'm') {
          subPathStartX += x;
          subPathStartY += y;
          p.rMoveTo(x, y);
          lastX += x;
          lastY += y;
        } else {
          subPathStartX = x;
          subPathStartY = y;
          p.moveTo(x, y);
          lastX = x;
          lastY = y;
        }
        break;
      }
      case 'Z':
      case 'z': {
        p.close();
        p.moveTo(subPathStartX, subPathStartY);
        lastX = subPathStartX;
        lastY = subPathStartY;
        lastX1 = subPathStartX;
        lastY1 = subPathStartY;
        wasCurve = true;
        break;
      }
      case 'L':
      case 'l': {
        float x = ph.nextFloat();
        float y = ph.nextFloat();
        if (cmd == 'l') {
          p.rLineTo(x, y);
          lastX += x;
          lastY += y;
        } else {
          p.lineTo(x, y);
          lastX = x;
          lastY = y;
        }
        break;
      }
      case 'H':
      case 'h': {
        float x = ph.nextFloat();
        if (cmd == 'h') {
          p.rLineTo(x, 0);
          lastX += x;
        } else {
          p.lineTo(x, lastY);
          lastX = x;
        }
        break;
      }
      case 'V':
      case 'v': {
        float y = ph.nextFloat();
        if (cmd == 'v') {
          p.rLineTo(0, y);
          lastY += y;
        } else {
          p.lineTo(lastX, y);
          lastY = y;
        }
        break;
      }
      case 'C':
      case 'c': {
        wasCurve = true;
        float x1 = ph.nextFloat();
        float y1 = ph.nextFloat();
        float x2 = ph.nextFloat();
        float y2 = ph.nextFloat();
        float x = ph.nextFloat();
        float y = ph.nextFloat();
        if (cmd == 'c') {
          x1 += lastX;
          x2 += lastX;
          x += lastX;
          y1 += lastY;
          y2 += lastY;
          y += lastY;
        }
        p.cubicTo(x1, y1, x2, y2, x, y);
        lastX1 = x2;
        lastY1 = y2;
        lastX = x;
        lastY = y;
        break;
      }
      case 'S':
      case 's': {
        wasCurve = true;
        float x2 = ph.nextFloat();
        float y2 = ph.nextFloat();
        float x = ph.nextFloat();
        float y = ph.nextFloat();
        if (cmd == 's') {
          x2 += lastX;
          x += lastX;
          y2 += lastY;
          y += lastY;
        }
        float x1 = 2 * lastX - lastX1;
        float y1 = 2 * lastY - lastY1;
        p.cubicTo(x1, y1, x2, y2, x, y);
        lastX1 = x2;
        lastY1 = y2;
        lastX = x;
        lastY = y;
        break;
      }
      case 'A':
      case 'a': {
        float rx = ph.nextFloat();
        float ry = ph.nextFloat();
        float theta = ph.nextFloat();
        int largeArc = (int) ph.nextFloat();
        int sweepArc = (int) ph.nextFloat();
        float x = ph.nextFloat();
        float y = ph.nextFloat();
        // dx and dy have been given instead of absolute values
        if (cmd == 'a') {
          x += lastX;
          y += lastY;
        }
        drawArc(p, lastX, lastY, x, y, rx, ry, theta, largeArc, sweepArc);
        lastX = x;
        lastY = y;
        break;
      }
    }
    if (!wasCurve) {
      lastX1 = lastX;
      lastY1 = lastY;
    }
    ph.skipWhitespace();
  }
  return p;
}

private static float angle(float x1, float y1, float x2, float y2) {
  return (float) Math.toDegrees(Math.atan2(x1, y1) - Math.atan2(x2, y2)) % 360;
}

private static final RectF arcRectf = new RectF();
private static final Matrix arcMatrix = new Matrix();
private static final Matrix arcMatrix2 = new Matrix();

private static void drawArc(Path p, float lastX, float lastY, float x, float y, float rx, float ry, float theta, int largeArc, int sweepArc) {
  // see http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes for these calculations

  // radius is 0 in both directions so it's a simple line
  if (rx == 0 || ry == 0) {
    p.lineTo(x, y);
    return;
  }

  // End is the same as the current point so nothing to draw
  if (x == lastX && y == lastY) {
    return;
  }

  // Ensure its the absolute value
  rx = Math.abs(rx);
  ry = Math.abs(ry);

  // Convert to radians and rotate point around angle
  float radTheta = theta * (float) Math.PI / 180;
  float sTheta = (float) Math.sin(radTheta);
  float cTheta = (float) Math.cos(radTheta);
  float xHalf = (lastX - x) / 2;
  float yHalf = (lastY - y) / 2;
  float xHResult = cTheta * xHalf + sTheta * yHalf;
  float yHResult = -sTheta * xHalf + cTheta * yHalf;

  // Square the rotations and the radii
  float xHR2 = xHResult * xHResult;
  float yHR2 = yHResult * yHResult;
  float rx2 = rx * rx;
  float ry2 = ry * ry;

  // Should we scale?
  // (ensure 0.1% is added so no out of range occurs due to limited precision)
  float delta = (xHR2 / rx2 + yHR2 / ry2) * 1.001f;
  if (delta > 1) {
    float sDelta = (float) Math.sqrt(delta);
    rx *= sDelta;
    ry *= sDelta;
    rx2 = rx * rx;
    ry2 = ry * ry;
  }

  // Get the adjustment factor
  float sign = (largeArc == sweepArc) ? -1 : 1;
  float numer = rx2 * ry2 - rx2 * yHR2 - ry2 * xHR2;
  float denom = rx2 * yHR2 + ry2 * xHR2;
  float lhs = (float) Math.sqrt(numer / denom) * sign;

  // Get the centre
  float xpCentre = lhs * (rx * yHResult) / ry;
  float ypCentre = -lhs * ((ry * xHResult) / rx);
  float xCentre = cTheta * xpCentre - sTheta * ypCentre + (lastX + x) / 2;
  float yCentre = sTheta * xpCentre + cTheta * ypCentre + (lastY + y) / 2;

  // Transform the ellipse into the unit circle
  float sAngle = angle(1, 0, (xHResult - xpCentre) / rx, (yHResult - ypCentre) / ry);
  float dAngle = angle((xHResult - xpCentre) / rx, (yHResult - ypCentre) / ry, (-xHResult - xpCentre) / rx, (-yHResult - ypCentre) / ry);

  // Postive or negative circle?
  if (sweepArc == 0 && dAngle > 0) {
    dAngle -= 360;
  } else if (sweepArc != 0 && dAngle < 0) {
    dAngle += 360;
  }

  // Drawing time
  if ((theta % 360) == 0) {
    // no rotation or translation is required here
    arcRectf.set(xCentre - rx, yCentre - ry, xCentre + rx, yCentre + ry);
    p.arcTo(arcRectf, sAngle, dAngle);
  } else {
    // time to do the rotation/translation as needed and then draw it
    arcRectf.set(-rx, -ry, rx, ry);

    arcMatrix.reset();
    arcMatrix.postRotate(theta);
    arcMatrix.postTranslate(xCentre, yCentre);
    arcMatrix.invert(arcMatrix2);

    p.transform(arcMatrix2);
    p.arcTo(arcRectf, sAngle, dAngle);
    p.transform(arcMatrix);
  }

}

private static NumberParse parseNumbers(String s) {
  //Util.debug("Parsing numbers from: '" + s + "'");
  int n = s.length();
  int p = 0;
  ArrayList<Float> numbers = new ArrayList<>();
  boolean skipChar = false;
  for (int i = 1; i < n; i++) {
    if (skipChar) {
      skipChar = false;
      continue;
    }
    char c = s.charAt(i);
    switch (c) {
      // This ends the parsing, as we are on the next element
      case 'M':
      case 'm':
      case 'Z':
      case 'z':
      case 'L':
      case 'l':
      case 'H':
      case 'h':
      case 'V':
      case 'v':
      case 'C':
      case 'c':
      case 'S':
      case 's':
      case 'Q':
      case 'q':
      case 'T':
      case 't':
      case 'a':
      case 'A':
      case ')': {
        String str = s.substring(p, i);
        if (str.trim().length() > 0) {
          //Util.debug("  Last: " + str);
          Float f = Float.parseFloat(str);
          numbers.add(f);
        }
        p = i;
        return new NumberParse(numbers, p);
      }
      case '\n':
      case '\t':
      case ' ':
      case ',':
      case '-': {
        String str = s.substring(p, i);
        // Just keep moving if multiple whitespace
        if (str.trim().length() > 0) {
          //Util.debug("  Next: " + str);
          Float f = Float.parseFloat(str);
          numbers.add(f);
          if (c == '-') {
            p = i;
          } else {
            p = i + 1;
            skipChar = true;
          }
        } else {
          p++;
        }
        break;
      }
    }
  }
  String last = s.substring(p);
  if (last.length() > 0) {
    //Util.debug("  Last: " + last);
    try {
      numbers.add(Float.parseFloat(last));
    } catch (NumberFormatException nfe) {
      // Just white-space, forget it
    }
    p = s.length();
  }
  return new NumberParse(numbers, p);
}

private static Matrix parseTransform(String s) {
  if (s.startsWith("matrix(")) {
    NumberParse np = parseNumbers(s.substring("matrix(".length()));
    if (np.numbers.size() == 6) {
      Matrix matrix = new Matrix();
      matrix.setValues(new float[]{
          // Row 1
          np.numbers.get(0),
          np.numbers.get(2),
          np.numbers.get(4),
          // Row 2
          np.numbers.get(1),
          np.numbers.get(3),
          np.numbers.get(5),
          // Row 3
          0,
          0,
          1,
      });
      return matrix;
    }
  } else if (s.startsWith("setTranslateRel(")) {
    NumberParse np = parseNumbers(s.substring("setTranslateRel(".length()));
    if (np.numbers.size() > 0) {
      float tx = np.numbers.get(0);
      float ty = 0;
      if (np.numbers.size() > 1) {
        ty = np.numbers.get(1);
      }
      Matrix matrix = new Matrix();
      matrix.postTranslate(tx, ty);
      return matrix;
    }
  } else if (s.startsWith("scale(")) {
    NumberParse np = parseNumbers(s.substring("scale(".length()));
    if (np.numbers.size() > 0) {
      float sx = np.numbers.get(0);
      float sy = 0;
      if (np.numbers.size() > 1) {
        sy = np.numbers.get(1);
      }
      Matrix matrix = new Matrix();
      matrix.postScale(sx, sy);
      return matrix;
    }
  } else if (s.startsWith("skewX(")) {
    NumberParse np = parseNumbers(s.substring("skewX(".length()));
    if (np.numbers.size() > 0) {
      float angle = np.numbers.get(0);
      Matrix matrix = new Matrix();
      matrix.postSkew((float) Math.tan(angle), 0);
      return matrix;
    }
  } else if (s.startsWith("skewY(")) {
    NumberParse np = parseNumbers(s.substring("skewY(".length()));
    if (np.numbers.size() > 0) {
      float angle = np.numbers.get(0);
      Matrix matrix = new Matrix();
      matrix.postSkew(0, (float) Math.tan(angle));
      return matrix;
    }
  } else if (s.startsWith("rotate(")) {
    NumberParse np = parseNumbers(s.substring("rotate(".length()));
    if (np.numbers.size() > 0) {
      float angle = np.numbers.get(0);
      float cx = 0;
      float cy = 0;
      if (np.numbers.size() > 2) {
        cx = np.numbers.get(1);
        cy = np.numbers.get(2);
      }
      Matrix matrix = new Matrix();
      matrix.postTranslate(cx, cy);
      matrix.postRotate(angle);
      matrix.postTranslate(-cx, -cy);
      return matrix;
    }
  }
  return null;
}

private static RectF parseViewBox(XmlPullParser parser) {
  RectF rectF = new RectF();
  String vb = parser.getAttributeValue(null, "viewBox");
  if (vb != null) {
    String[] vba = vb.split(" ");
    rectF.set(
        Float.parseFloat(vba[0]),
        Float.parseFloat(vba[1]),
        Float.parseFloat(vba[2]),
        Float.parseFloat(vba[3])
    );
  }
  return rectF;
}

/**
 * Attaches a transformation to an element
 *
 * @param element
 * @param x
 * @param y
 * @param transformString
 */
private static Matrix bakeTransformFoundOnElement(Element element, float x, float y, String transformString) {
  Matrix matrix = parseTransform(transformString);
  matrix.preTranslate(x, y);
  element.getTransform().setTranslationX(MatrixUtils.getTransX(matrix));
  element.getTransform().setTranslationY(MatrixUtils.getTransY(matrix));
  element.getTransform().setRotation(MatrixUtils.getRotDgrs(matrix));
  element.getTransform().setScaleX(MatrixUtils.getScaleX(matrix));
  element.getTransform().setScaleY(MatrixUtils.getScaleY(matrix));
  return matrix;
}

private static Path pathGlobalToLocal(Element element, Path path) {
  RectF r = new RectF();
  path.computeBounds(r, true);
  path.offset(-r.centerX(), -r.centerY());
  element.getTransform().setTranslationX(r.centerX());
  element.getTransform().setTranslationY(r.centerY());
  return path;
}

/**
 * add to the element all the attributes found on the svg
 * @param parser
 * @param element
 */
private static void populateAttributesFromSVG(XmlPullParser parser, Element element){
  int attributeCount = parser.getAttributeCount();
  for (int i = 0; i < attributeCount; i++) {
    String attributeName = parser.getAttributeName(i);
    String attributeValue = parser.getAttributeValue(i);
//    Log.d(TAG, "attributeName: " + attributeName+" attributeValue: "+attributeValue);
    element.attributes.put(attributeName, attributeValue);
  }
}

private static class NumberParse {
  private ArrayList<Float> numbers;
  private int nextCmd;

  public NumberParse(ArrayList<Float> numbers, int nextCmd) {
    this.numbers = numbers;
    this.nextCmd = nextCmd;
  }

  public int getNextCmd() {
    return nextCmd;
  }

  public float getNumber(int index) {
    return numbers.get(index);
  }

}

public static class ParsedSVG {
  public RectF viewBox = new RectF();
  public List<Element> elements = new ArrayList<>();
  public List<RenderStyle> renderStyles = new ArrayList<>();
  public List<MultiShape> symbols = new ArrayList<>();
}
}
