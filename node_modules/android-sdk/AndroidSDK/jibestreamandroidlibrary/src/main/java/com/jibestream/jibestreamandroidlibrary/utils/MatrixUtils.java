package com.jibestream.jibestreamandroidlibrary.utils;

import android.graphics.Matrix;

import com.jibestream.jibestreamandroidlibrary.math.Transform;

/**
 * Utility class for decomposing a matrix.
 * Created by emmanuel on 15-05-21.
 */
public class MatrixUtils {
protected static final String TAG = "MatrixUtils";
public static float[] matrixArray = new float[9];
public static final Matrix IDENTITY = new Matrix();


/**
 * Translation X value of the matrix
 * @param matrix
 * @return
 */
public static float getTransX(Matrix matrix) {
  if (matrix == null) return Float.NaN;
  matrix.getValues(matrixArray);
  float tx = matrixArray[matrix.MTRANS_X];
  return tx;
}

/**
 * Translation Y value of the matrix
 * @param matrix
 * @return
 */
public static float getTransY(Matrix matrix) {
  if (matrix == null) return Float.NaN;
  matrix.getValues(matrixArray);
  float ty = matrixArray[matrix.MTRANS_Y];
  return ty;
}

/**
 * Roation value of the matrix
 * Values range from -180 to 180
 * @param matrix
 * @return
 */
public static float getRotDgrs(Matrix matrix) {
  if (matrix == null) return Float.NaN;
  return (float) Math.toDegrees(getRotRads(matrix));
}

// TODO: 15-06-23 double check order

/**
 * The rotation in rads of matrix
 * @param matrix
 * @return
 */
public static float getRotRads(Matrix matrix) {
  if (matrix == null) return Float.NaN;
  matrix.getValues(matrixArray);
  float rads = (float) Math.atan2(matrixArray[Matrix.MSKEW_Y], matrixArray[Matrix.MSCALE_Y]);
//  float rads0 = (float) Math.atan2(matrixArray[Matrix.MSKEW_Y], matrixArray[Matrix.MSCALE_X]);
//    Log.d("Delta", String.valueOf(rads0 - rads));
  return rads;
}

/**
 * The scale X value of the matrix
 * @param matrix
 * @return
 */
public static float getScaleX(Matrix matrix) {
  if (matrix == null) return Float.NaN;
  matrix.getValues(matrixArray);
  float sX = (float) (
//      Math.signum(matrixArray[matrix.MSCALE_X]) *
      Math.sqrt(
          Math.pow(matrixArray[matrix.MSCALE_X], 2) +
              Math.pow(matrixArray[matrix.MSKEW_X], 2)
      )
  );
  return sX;
}


/**
 * The scale Y value of the matrix
 * @param matrix
 * @return
 */
public static float getScaleY(Matrix matrix) {
  if (matrix == null) return Float.NaN;
  matrix.getValues(matrixArray);
  float sY = (float) (
//      Math.signum(matrixArray[matrix.MSCALE_Y]) *
      Math.sqrt(
          Math.pow(matrixArray[matrix.MSKEW_Y], 2) +
              Math.pow(matrixArray[matrix.MSCALE_Y], 2)
      )
  );
  return sY;
}

/**
 * Returns a Transform object from matrix
 * @param matrix
 * @return
 */
public static Transform getTransform(Matrix matrix) {
  if (matrix == null) return null;
  Transform transform = new Transform();
  transform.setTranslationX(MatrixUtils.getTransX(matrix));
  transform.setTranslationY(MatrixUtils.getTransY(matrix));
  transform.setRotation(MatrixUtils.getRotDgrs(matrix));
  transform.setScaleX(MatrixUtils.getScaleX(matrix));
  transform.setScaleY(MatrixUtils.getScaleY(matrix));
  return transform;
}
}

