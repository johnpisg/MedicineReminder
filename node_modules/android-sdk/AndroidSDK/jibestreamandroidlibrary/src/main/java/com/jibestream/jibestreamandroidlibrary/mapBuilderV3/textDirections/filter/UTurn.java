package com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.filter;

import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.ASNode;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.astar.Point;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.Helpers;
import com.jibestream.jibestreamandroidlibrary.mapBuilderV3.textDirections.TDInstruction;

import java.util.ArrayList;

/**
 * Created by frankduffy on 2016-01-27.
 */
public class UTurn {

    public void uTurn(TDFilterInput inst) {
        Helpers hlp = new Helpers();
        // Filter No.3 U-Turn detection: eg.: Three lefts with combined angle of over 100 deg become Left U-Turn
        if (inst.enableDistanceFilters) {
            // Disable is not over zero
            if (inst.UTurnInMeters > 0) {
                // Skip UTurn if first floor
                if (inst.useArrayOfFloorWaypoints != inst.wayfindArray[0]) {
                    // U-Turn detection
                    TDInstruction firstConsecutiveInstructionUTurn = inst.textDirectionsFloorArray.get(0);
                    // Does this waypoint have only one connection?
                    ASNode firstNode = inst.useArrayOfFloorWaypoints.points[0];
                    // Count type 1
                    int type1counter = 0;
                    // We have to have only one of type 1
                    // Disregard the others
                    for (int i = 0; i < firstNode.edges.length; i++) {
                        if (firstNode.edges[i].type == 1) {
                            type1counter++;
                        }
                    }

                    // Only 1 type 1?
                    if (type1counter != 1){
                        // Waypoint has more than one connection
                        // This cannot be a U-Turn
                        return;
                    }
                    // else continue

                    // More than 3 directions?
                    if (inst.textDirectionsFloorArray.size() < 4){
                        // This cannot be a U-Turn. Not enough directions/waypoints
                        return;
                    }
                    // else continue

                    // Decide Direction of U-Turn
                    boolean directionIsRight = true;
                    // Can you get one more text direction?
                    TDInstruction secondConsecutiveInstructionUTurn = inst.textDirectionsFloorArray.get(1);
                    // Get angle difference
                    double angleToDifference1 = firstConsecutiveInstructionUTurn.angleToNext - secondConsecutiveInstructionUTurn.angleToNext;
                    while (angleToDifference1 < -180) angleToDifference1 += 360;
                    while (angleToDifference1 > 180) angleToDifference1 -= 360;

                    // Minus for Right
                    // Plus for Left

                    if (angleToDifference1 >= 0){
                        directionIsRight = true;
                    } else {
                        directionIsRight = false;
                    }

                    //UTurnInMetres

                    // Thresholds

                    int angle1_t = 95;
                    int angle2_t = 95;
                    int distance1_t = 2;
                    int distance2_t = 5;
                    int distance3_t = 5;

                    // Segment A
                    // Test Angle
                    if (angle1_t < Math.abs(angleToDifference1)){
                        // This cannot be a u-turn, first angle threshold broken
                        return;
                    }
                    // Test Direction
                    boolean segmentADirectionRight = true;
                    if (angleToDifference1 >= 0){
                        // Right
                        segmentADirectionRight = true;
                    } else {
                        // left
                        segmentADirectionRight = false;
                    }

                    if (directionIsRight != segmentADirectionRight){
                        // Not in the same direction
                        // This cannot be UTurn
                        return;
                    }
                    // Test Distance
                    Point point1xy = new Point(firstConsecutiveInstructionUTurn.wp.x, firstConsecutiveInstructionUTurn.wp.y, 0);
                    Point point2xy = new Point(secondConsecutiveInstructionUTurn.wp.x, secondConsecutiveInstructionUTurn.wp.y, 0);
                    float distance1= (float)hlp.distanceBetween(point1xy, point2xy);
                    double distance1Meters = hlp.convertPixelsToMeters(distance1, inst.xScale);
                    if (distance1Meters <= distance1_t){
                        // This cannot be UTurn
                        // Segment 1 is too long
                        return;
                    }

                    // Segment B
                    // Third point
                    TDInstruction thirdConsecutiveInstructionUTurn = inst.textDirectionsFloorArray.get(2);

                    double angleToDifference2 = secondConsecutiveInstructionUTurn.angleToNext - thirdConsecutiveInstructionUTurn.angleToNext;
                    while (angleToDifference2 < -180) angleToDifference2 += 360;
                    while (angleToDifference2 > 180) angleToDifference2 -= 360;
                    // test Angle
                    if (angle2_t < Math.abs(angleToDifference2)){
                        // This cannot be a u-turn, first angle threshold broken
                        return;
                    }
                    // Test Direction
                    boolean segmentBDirectionRight = true;
                    if (angleToDifference2 >= 0){
                        // Right
                        segmentBDirectionRight = true;
                    } else {
                        // left
                        segmentBDirectionRight = false;
                    }

                    if (directionIsRight != segmentBDirectionRight){
                        // Not in the same direction
                        // This cannot be UTurn
                        return;
                    }
                    // Test Distance
                    Point point3xy = new Point(thirdConsecutiveInstructionUTurn.wp.x, thirdConsecutiveInstructionUTurn.wp.y, 0);
                    float distance2 = (float)hlp.distanceBetween(point2xy, point3xy);
                    double distance2Meters = hlp.convertPixelsToMeters(distance2,inst.xScale);
                    if (distance2Meters <= distance2_t){
                        // This cannot be UTurn
                        // Segment 1 is too long
                        return;
                    }

                    //Segment C
                    //fourth point
                    TDInstruction fourthConsecutiveInstructionUTurn = inst.textDirectionsFloorArray.get(3);
                    //Test Distance ONLY
                    // It should be less than the 3rd Threshold
                    // Test Direction
                    Point point4xy = new Point(fourthConsecutiveInstructionUTurn.wp.x, fourthConsecutiveInstructionUTurn.wp.y, 0);
                    float distance3 = (float)hlp.distanceBetween(point3xy, point4xy);
                    double distance3Meters = hlp.convertPixelsToMeters(distance3,inst.xScale);
                    if (distance3_t >= distance3Meters){
                        // This cannot be UTurn
                        // Segment 3 is too short
                        return;
                    }

                    // This is a U Turn
                    // Direction
                    if (directionIsRight){
                        // Right
                        firstConsecutiveInstructionUTurn.direction = "Right";
                    } else {
                        // Left
                        firstConsecutiveInstructionUTurn.direction = "Left";
                    }
                    // Add UTurn Direction
                    firstConsecutiveInstructionUTurn.direction += " UTurn";

                    // FIrst is going to be a U-Turn on Left/Right side
                    // Combine firstConsecutiveInstruction output
                    ArrayList<String> stringList = new ArrayList<String>();
                    stringList.add("With % on your %, make %");
                    stringList.add(firstConsecutiveInstructionUTurn.landmarkDestination.name);
                    stringList.add(firstConsecutiveInstructionUTurn.directionToLandmark);
                    stringList.add(firstConsecutiveInstructionUTurn.direction);

                    // update
                    firstConsecutiveInstructionUTurn.output = hlp.stringWithFormat(stringList);

                    // Fold2
                    // Add distance
                    float combinedFirstDistance = firstConsecutiveInstructionUTurn.distanceToNextPixels;
                    // 2nd to 4rd
                    combinedFirstDistance += secondConsecutiveInstructionUTurn.distanceToNextPixels;
                    //3rd to 4th
                    combinedFirstDistance += thirdConsecutiveInstructionUTurn.distanceToNextPixels;

                    // Update first
                    firstConsecutiveInstructionUTurn.distanceToNextPixels = combinedFirstDistance;
                    firstConsecutiveInstructionUTurn.distanceToNextMeters = (float)hlp.convertPixelsToMeters(combinedFirstDistance, inst.xScale);

                    // Fold current into firstConsecutiveInstruction
                    firstConsecutiveInstructionUTurn.foldInFront(secondConsecutiveInstructionUTurn);
                    // Remove from textDirectionsFloorArray
                    inst.textDirectionsFloorArray.remove(1);

                    // Fold current into firstConsecutiveInstruction
                    firstConsecutiveInstructionUTurn.foldInFront(thirdConsecutiveInstructionUTurn);
                    // Remove from textDirectionsFloorArray
                    inst.textDirectionsFloorArray.remove(1);
                }
            }
        }
    }
}
